<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:51+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Program Induction by Rationale Generation: Learning to Solve and Explain Algebraic Word Problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>July 30-August 4, 2017. July 30-August 4, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename><surname>Ling</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dani</forename><surname>Yogatama</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dyer</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phil</forename><surname>Blunsom</surname></persName>
						</author>
						<title level="a" type="main">Program Induction by Rationale Generation: Learning to Solve and Explain Algebraic Word Problems</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</title>
						<meeting>the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) <address><addrLine>Vancouver, Canada; Vancouver, Canada</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="158" to="167"/>
							<date type="published">July 30-August 4, 2017. July 30-August 4, 2017</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.18653/v1/p17-1015</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Solving algebraic word problems requires executing a series of arithmetic operations-a program-to obtain a final answer. However, since programs can be arbitrarily complicated, inducing them directly from question-answer pairs is a formidable challenge. To make this task more feasible, we solve these problems by generating answer rationales, sequences of natural language and human-readable mathematical expressions that derive the final answer through a series of small steps. Although rationales do not explicitly specify programs, they provide a scaffolding for their structure via intermediate milestones. To evaluate our approach, we have created a new 100,000-sample dataset of questions, answers and rationales. Experimental results show that indirect supervision of program learning via answer rationales is a promising strategy for inducing arithmetic programs.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Behaving intelligently often requires mathemat- ical reasoning. Shopkeepers calculate change, tax, and sale prices; agriculturists calculate the proper amounts of fertilizers, pesticides, and wa- ter for their crops; and managers analyze produc- tivity. Even determining whether you have enough money to pay for a list of items requires applying addition, multiplication, and comparison. Solv- ing these tasks is challenging as it involves rec- ognizing how goals, entities, and quantities in the real-world map onto a mathematical formaliza- tion, computing the solution, and mapping the so- lution back onto the world. As a proxy for the richness of the real world, a series of papers have used natural language specifications of algebraic word problems, and solved these by either learn- ing to fill in templates that can be solved with equation solvers ( <ref type="bibr">Hosseini et al., 2014;</ref><ref type="bibr" target="#b3">Kushman et al., 2014</ref>) or inferring and modeling operation sequences (programs) that lead to the final an- swer ( <ref type="bibr" target="#b12">Roy and Roth, 2015)</ref>.</p><p>In this paper, we learn to solve algebraic word problems by inducing and modeling programs that generate not only the answer, but an answer ratio- nale, a natural language explanation interspersed with algebraic expressions justifying the overall solution. Such rationales are what examiners re- quire from students in order to demonstrate un- derstanding of the problem solution; they play the very same role in our task. Not only do natural language rationales enhance model interpretabil- ity, but they provide a coarse guide to the structure of the arithmetic programs that must be executed. In fact the learner we propose (which relies on a heuristic search; §4) fails to solve this task with- out modeling the rationales-the search space is too unconstrained.</p><p>This work is thus related to models that can explain or rationalize their decisions <ref type="bibr">(Hendricks et al., 2016;</ref><ref type="bibr">Harrison et al., 2017)</ref>. However, the use of rationales in this work is quite different from the role they play in most prior work, where interpretation models are trained to generate plau- sible sounding (but not necessarily accurate) post- hoc descriptions of the decision making process they used. In this work, the rationale is generated as a latent variable that gives rise to the answer-it is thus a more faithful representation of the steps used in computing the answer. This paper makes three contributions. First, we have created a new dataset with more than 100,000 algebraic word problems that includes both an- swers and natural language answer rationales ( §2). <ref type="figure">Figure 1</ref> illustrates three representative instances <ref type="bibr">Problem</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1: Question: Two trains running in opposite directions cross a man standing on the platform in 27 seconds and 17 seconds respectively and they cross each other in 23 seconds. The ratio of their speeds is: Options: A) 3/7 B) 3/2 C) 3/88 D) 3/8 E) 2/2</head><p>Rationale: Let the speeds of the two trains be x m/sec and y m/sec respectively. Then, length of the first train = 27x meters, and length of the second train = 17 y meters. (27x + 17y) / (x + y) = 23 → 27x + 17y = 23x + 23y → 4x = 6y → x/y = 3/2. Correct Option: B Problem 2: Question: From a pack of 52 cards, two cards are drawn to- gether at random. What is the probability of both the cards being kings?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Options: A) 2/1223 B) 1/122 C) 1/221 D) 3/1253 E) 2/153</head><p>Rationale: Let s be the sample space. Then n(s) = 52C2 = 1326 E = event of getting 2 kings out of 4 n(E) = 4C2 = 6 P(E) = 6/1326 = 1/221 Answer is C Correct Option: C Problem 3: Question: For which of the following does p(a)−p(b) = p(ab) for all values of a and b?</p><formula xml:id="formula_0">Options:A) p(x) = x 2 , B) p(x) = x/2, C) p(x) = x + 5, D) p(x) = 2x1, E) p(x) = |x|</formula><p>Rationale: To solve this easiest way is just put the value and see that if it equals or not. with option A. p(a) = a 2 and</p><formula xml:id="formula_1">p(b) = b 2 so L.H.S = a 2 − b 2 and R.H.S = (a − b) 2 → a 2 + b 2 − 2ab. so L.H.S not equal to R.H.S with option B. p(a) = a/2 and p(b) = b/2 L.H.S = a/2 − b/2 → 1/2(a − b) R.H.S = (a − b)/2 so L.H.S = R.H.</formula><p>S which is the correct answer. answer:B Correct Option: B <ref type="figure">Figure 1</ref>: Examples of solved math problems. from the dataset. Second, we propose a sequence to sequence model that generates a sequence of in- structions that, when executed, generates the ra- tionale; only after this is the answer chosen ( §3). Since the target program is not given in the train- ing data (most obviously, its specific form will de- pend on the operations that are supported by the program interpreter); the third contribution is thus a technique for inferring programs that generate a rationale and, ultimately, the answer. Even con- strained by a text rationale, the search space of possible programs is quite large, and we employ a heuristic search to find plausible next steps to guide the search for programs ( §4). Empirically, we are able to show that state-of-the-art sequence to sequence models are unable to perform above chance on this task, but that our model doubles the accuracy of the baseline ( §6).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Dataset</head><p>We built a dataset with 100,000 problems with the annotations shown in <ref type="figure">Figure 1</ref>. Each question is decomposed in four parts, two inputs and two out- puts: the description of the problem, which we will denote as the question, and the possible (mul- tiple choice) answer options, denoted as options. Our goal is to generate the description of the ratio- nale used to reach the correct answer, denoted as rationale and the correct option label. Problem 1 illustrates an example of an algebra problem, which must be translated into an expression (i.e., (27x + 17y)/(x + y) = 23) and then the desired quantity (x/y) solved for. Problem 2 is an exam- ple that could be solved by multi-step arithmetic operations proposed in ( <ref type="bibr" target="#b12">Roy and Roth, 2015)</ref>. Fi- nally, Problem 3 describes a problem that is solved by testing each of the options, which has not been addressed in the past.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Construction</head><p>We first collect a set of 34,202 seed problems that consist of multiple option math questions covering a broad range of topics and difficulty levels. Ex- amples of exams with such problems include the GMAT (Graduate Management Admission Test) and GRE (General Test). Many websites contain example math questions in such exams, where the answer is supported by a rationale.</p><p>Next, we turned to crowdsourcing to generate new questions. We create a task where users are presented with a set of 5 questions from our seed dataset. Then, we ask the Turker to choose one of the questions and write a similar question. We also force the answers and rationale to differ from the original question in order to avoid paraphrases of the original question. Once again, we manually check a subset of the jobs for each Turker for qual- ity control. The type of questions generated us- ing this method vary. Some turkers propose small changes in the values of the questions (e.g., chang- ing the equality p(a)p(b) = p(ab) in Problem 3 to a different equality is a valid question, as long as the rationale and options are rewritten to reflect the change). We designate these as replica prob- lems as the natural language used in the question and rationales tend to be only minimally unaltered.</p><p>Others propose new problems in the same topic where the generated questions tend to differ more radically from existing ones. Some Turkers also copy math problems available on the web, and we define in the instructions that this is not allowed, as it will generate multiple copies of the same prob- lem in the dataset if two or more Turkers copy from the same resource. These Turkers can be de- tected by checking the nearest neighbours within the collected datasets as problems obtained from online resources are frequently submitted by more than one Turker. Using this method, we obtained 70,318 additional questions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Statistics</head><p>Descriptive statistics of the dataset is shown in <ref type="figure">Figure 1</ref>. In total, we collected 104,519 problems (34,202 seed problems and 70,318 crowdsourced problems). We removed 500 problems as heldout set (250 for development and 250 for testing). As replicas of the heldout problems may be present in the training set, these were removed manually by listing for each heldout instance the closest prob- lems in the training set in terms of character-based Levenstein distance. After filtering, 100,949 prob- lems remained in the training set. We also show the average number of tokens (to- tal number of tokens in the question, options and rationale) and the vocabulary size of the questions and rationales. Finally, we provide the same statis- tics exclusively for tokens that are numeric values and tokens that are not. <ref type="figure">Figure 2</ref> shows the distribution of examples based on the total number of tokens. We can see that most examples consist of 30 to 500 tokens, but there are also extremely long examples with more than 1000 tokens in our dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Model</head><p>Generating rationales for math problems is chal- lenging as it requires models that learn to per- form math operations at a finer granularity as each step within the solution must be explained. 17y)/(x + y) = 23 must be solved to obtain the answer. In previous work <ref type="bibr" target="#b3">(Kushman et al., 2014</ref>), this could be done by feeding the equation into an expression solver to obtain x/y = 3/2. However, this would skip the intermediate steps 27x + 17y = 23x + 23y and 4x = 6y, which must also be generated in our problem. We propose a model that jointly learns to generate the text in the rationale, and to perform the math operations re- quired to solve the problem. This is done by gener- ating a program, containing both instructions that generate output and instructions that simply gener- ate intermediate values used by following instruc- tions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem Definition</head><p>In traditional sequence to sequence mod- els ( <ref type="bibr" target="#b14">Sutskever et al., 2014;</ref><ref type="bibr">Bahdanau et al., 2014</ref>), the goal is to predict the output sequence y = y 1 , . . . , y |y| from the input sequence x = x 1 , . . . , x |x| , with lengths |y| and |x|.</p><p>In our particular problem, we are given the problem and the set of options, and wish to pre- dict the rationale and the correct option. We set x as the sequence of words in the problem, concate- nated with words in each of the options separated by a special tag. Note that knowledge about the possible options is required as some problems are solved by the process of elimination or by testing each of the options (e.g. Problem 3). We wish to generate y, which is the sequence of words in the rationale. We also append the correct option as the last word in y, which is interpreted as the chosen option. For example, y in Problem 1 is "Let the . . . = 3/2 . EOR B EOS", whereas in Problem 2 it is "Let s be . . . Answer is C EOR C EOS", where "EOS" is the end of sentence symbol and "EOR" is the end of rationale symbol.</p><formula xml:id="formula_2">i x z v r 1 From Id("Let") Let y1 2 a Id("s") s y2 3 pack</formula><p>Id("be") be y3 4 of Id("the") the y4 5 52</p><p>Id("sample") sample y5 6 cards Id("space") space y6 7 ,</p><p>Id(".") . y7 8 two</p><p>Id("\n") \n y8 9 cards</p><p>Id("Then") Then y9 10 are</p><p>Id("n") n y10 11 drawn</p><p>Id("(") ( y11 12 together Id("s") s y12 13 at</p><p>Id(")") ) y13 14 random</p><p>Id("=") = y14 15 .</p><p>Str to Float(x5) 52 m1</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="16">What</head><p>Float to Str(m1) 52 y15 17 is</p><p>Id("C") C y16 18 the Id("2") 2 y17 19 probability Id("=") = y18 20 of Str to Float(y17) 2 m2 21 both</p><p>Choose(m1,m2) 1326 m3</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="22">cards</head><p>Float to Str(m3) 1326 y19 23 being <ref type="table">Table 2</ref>: Example of a program z that would gen- erate the output y. In v, italics indicates string types; bold indicates float types. Refer to §3.3 for description of variable names.</p><formula xml:id="formula_3">Id("E") E y20 24 kings Id("=") = y21 25 ? Id("event") event y22 26 &lt;O&gt; Id("of") of y23 27 A) Id("getting") getting y24 28 2/1223 Id("2") 2 y25 29 &lt;O&gt; Id("kings") kings y26 30 B) Id("out") out y27 31 1/122 Id("of") of y28 . . . . . . . . . . . . . . . |z| Id("EOS") EOS y |y|</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Generating Programs to Generate Rationales</head><p>We wish to generate a latent sequence of program instructions, z = z 1 , . . . , z |z| , with length |z|, that will generate y when executed.</p><p>We express z as a program that can access x, y, and the memory buffer m. Upon finishing execu- tion we expect that the sequence of output tokens to be placed in the output vector y. <ref type="table">Table 2</ref> illustrates an example of a sequence of instructions that would generate an excerpt from Problem 2, where columns x, z, v, and r denote the input sequence, the instruction sequence (pro- gram), the values of executing the instruction, and where each value v i is written (i.e., either to the output or to the memory). In this example, instruc- tions from indexes 1 to 14 simply fill each position with the observed output y 1 , . . . , y 14 with a string, where the Id operation simply returns its parame- ter without applying any operation. As such, run- ning this operation is analogous to generating a word by sampling from a softmax over a vocabu- lary. However, instruction z 15 reads the input word x 5 , 52, and applies the operation Str to Float, which converts the word 52 into a floating point number, and the same is done for instruction z 20 , which reads a previously generated output word y 17 . Unlike, instructions z 1 , . . . , z 14 , these op- erations write to the external memory m, which stores intermediate values. A more sophisticated instruction-which shows some of the power of our model-is</p><formula xml:id="formula_4">z 21 = Choose(m 1 , m 2 ) → m 3 which evaluates m 1 m 2</formula><p>and stores the result in m 3 .</p><p>This process repeats until the model generates the end-of-sentence symbol. The last token of the pro- gram as said previously must generate the correct option value, from "A" to "E".</p><p>By training a model to generate instructions that can manipulate existing tokens, the model ben- efits from the additional expressiveness needed to solve math problems within the generation process. In total we define 22 different oper- ations, 13 of which are frequently used opera- tions when solving math problems. These are: Id, Add, Subtract, Multiply, Divide, Power, Log, Sqrt, Sine, Cosine, Tangent, Factorial, and Choose (number of combi- nations). We also provide 2 operations to con- vert between Radians and Degrees, as these are needed for the sine, cosine and tangent opera- tions. There are 6 operations that convert floating point numbers into strings and vice-versa. These include the Str to Float and Float to Str operations described previously, as well as opera- tions which convert between floating point num- bers and fractions, since in many math problems the answers are in the form "3/4". For the same reason, an operation to convert between a float- ing point number and number grouped in thou- sands is also used (e.g. 1000000 to "1,000,000" or "1.000.000"). Finally, we define an opera- tion (Check) that given the input string, searches through the list of options and returns a string with the option index in {"A", "B", "C", "D", "E"}. If the input value does not match any of the options, or more than one option contains that value, it can- not be applied. For instance, in Problem 2, once the correct probability "1/221" is generated, by ap- plying the check operation to this number we can obtain correct option "C".  <ref type="figure">Figure 3</ref>: Illustration of the generation process of a single instruction tuple at timestamp i.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Generating and Executing Instructions</head><p>In our model, programs consist of sequences of instructions, z. We turn now to how we model each z i , conditional on the text program specifi- cation, and the program's history. The instruction z i is a tuple consisting of an operation (o i ), an or- dered sequence of its arguments (a i ), and a deci- sion about where its results will be placed (r i ) (is it appended in the output y or in a memory buffer m?), and the result of applying the operation to its arguments (v i ). That is,</p><formula xml:id="formula_5">z i = (o i , r i , a i , v i ).</formula><p>Formally, o i is an element of the pre-specified set of operations O, which contains, for example add, div, Str to Float, etc. The number of arguments required by o i is given by argc(o i ), e.g., argc(add) = 2 and argc(log) = 1. The argu- ments are a i = a i,1 , . . . , a i,argc(o i ) . An instruc- tion will generate a return value v i upon execution, which will either be placed in the output y or hid- den. This decision is controlled by r i . We define the instruction probability as:</p><formula xml:id="formula_6">p(o i , a i , r i ,v i | z &lt;i , x, y, m) = p(o i | z &lt;i , x) × p(r i | z &lt;i , x, o i )× argc(o i ) j=1 p(a i,j | z &lt;i , x, o i , m, y)× [v i = apply(o i , a)],</formula><p>where [p] evaluates to 1 if p is true and 0 otherwise, and apply(f, x) evaluates the operation f with ar- guments x. Note that the apply function is not learned, but pre-defined.</p><p>The network used to generate an instruction at a given timestamp i is illustrated in <ref type="figure">Figure 3</ref>. We first use the recurrent state h i to generate p(o i | z &lt;i , x) = softmax o i ∈O (h i ), using a softmax over the set of available operations O.</p><p>In order to predict r i , we generate a new hid- den state r i , which is a function of the current pro- gram context h i , and an embedding of the cur- rent predicted operation, o i . As the output can either be placed in the memory m or the output y, we compute the probability p(r i = OUTPUT | z &lt;i , x, o i ) = σ(r i · w r + b r ), where σ is the lo- gistic sigmoid function. If r i = OUTPUT, v i is appended to the output y; otherwise it is appended to the memory m.</p><p>Once we generate r i , we must predict a i , the argc(o i )-length sequence of arguments that oper- ation o i requires. The jth argument a i,j can be either generated from a softmax over the vocab- ulary, copied from the input vector x, or copied from previously generated values in the output y or memory m. This decision is modeled us- ing a latent predictor network ( <ref type="bibr">Ling et al., 2016)</ref>, where the control over which method used to gen- erate a i,j is governed by a latent variable q i,j ∈ {SOFTMAX, COPY-INPUT, COPY-OUTPUT}. Sim- ilar to when predicting r i , in order to make this choice, we also generate a new hidden state for each argument slot j, denoted by q i,j with an LSTM, feeding the previous argument in at each time step, and initializing it with r i and by reading the predicted value of the output r i .</p><p>• If q i,j = SOFTMAX, a i,j is generated by sam- pling from a softmax over the vocabulary Y,</p><formula xml:id="formula_7">p(a i,j | q i,j = SOFTMAX) = softmax a i,j ∈Y (q i,j ).</formula><p>This corresponds to a case where a string is used as argument (e.g. y 1 ="Let").</p><p>• If q i,j = COPY-INPUT, a i,j is obtained by copy- ing an element from the input vector with a pointer network (Vinyals et al., 2015) over input words x 1 , . . . , x |x| , represented by their encoder LSTM state u 1 , . . . , u |x| . As such, we compute the probability distribution over input words as:</p><formula xml:id="formula_8">p(a i,j | q i,j =COPY-INPUT) =<label>(1)</label></formula><formula xml:id="formula_9">softmax a i,j ∈x 1 ,...,x |x| f (u a i,j , q i,j )</formula><p>Function f computes the affinity of each to- ken x a i,j and the current output context q i,j . A common implementation of f , which we follow, is to apply a linear projection from [u a i,j ; q i,j ] into a fixed size vector (where [u; v] is vector concatenation), followed by a tanh and a linear projection into a single value.</p><p>• If q i,j = COPY-OUTPUT, the model copies from either the output y or the memory m. This is equivalent to finding the instruction z i , where the value was generated. Once again, we de- fine a pointer network that points to the output instructions and define the distribution over pre- viously generated instructions as:</p><formula xml:id="formula_10">p(a i,j | q i,j =COPY-OUTPUT) = softmax a i,j ∈z 1 ,...,z i−1 f (h a i,j , q i,j )</formula><p>Here, the affinity is computed using the decoder state h a i,j and the current state q i,j .</p><p>Finally, we embed the argument a i,j 1 and the state q i,j to generate the next state q i,j+1 . Once all arguments for o i are generated, the operation is executed to obtain v i . Then, the embedding of v i , the final state of the instruction q i,|a i | and the previous state h i are used to generate the state at the next timestamp h i+1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Inducing Programs while Learning</head><p>The set of instructions z that will generate y is un- observed. Thus, given x we optimize the marginal probability function:</p><formula xml:id="formula_11">p(y | x) = z∈Z p(y | z)p(z | x) = z∈Z(y) p(z | x),</formula><p>where p(y | z) is the Kronecker delta function δ e(z),y , which is 1 if the execution of z, denoted as e(z), generates y and 0 otherwise. Thus, we can redefine p(y|x), the marginal over all programs Z, as a marginal over programs that would generate y, defined as Z(y). As marginalizing over z ∈ Z(y) is intractable, we approximate the marginal by generating samples from our model. Denote the set of samples that are generated byˆZbyˆ byˆZ(y). We maximize z ∈ ˆ Z(y)p(z|x). However, generating programs that generate y is not trivial, as randomly sampling from the RNN distribution over instructions at each timestamp is unlikely to generate a sequence z ∈ Z(y). This is analogous to the question answering work in <ref type="bibr" target="#b5">Liang et al. (2016)</ref>, where the query that generates the correct answer must be found dur- ing inference, and training proved to be difficult without supervision. In <ref type="bibr" target="#b12">Roy and Roth (2015)</ref> this problem is also addressed by adding prior knowl- edge to constrain the exponential space.</p><p>In our work, we leverage the fact that we are generating rationales, where there is a sense of progression within the rationale. That is, we as- sume that the rationale solves the problem step by step. For instance, in Problem 2, the rationale first describes the number of combinations of two cards in a deck of 52 cards, then describes the number of combinations of two kings, and finally com- putes the probability of drawing two kings. Thus, while generating the final answer without the ra- tionale requires a long sequence of latent instruc- tions, generating each of the tokens of the rationale requires far less operations.</p><p>More formally, given the sequence z 1 , . . . , z i−1 generated so far, and the possible values for z i given by the network, denoted Z i , we wish to filter Z i to Z i (y k ), which denotes a set of possible op- tions that contain at least one path capable of gen- erating the next token at index k. Finding the set Z i (y k ) is achieved by testing all combinations of instructions that are possible with at most one level of indirection, and keeping those that can generate y k . This means that the model can only gener- ate one intermediate value in memory (not includ- ing the operations that convert strings into floating point values and vice-versa).</p><p>Decoding. During decoding we find the most likely sequence of instructions z given x, which can be performed with a stack-based decoder. However, it is important to refer that each gen- erated instruction z i = (o i , r i , a i,1 , . . . , a i,|a i | , v i ) must be executed to obtain v i . To avoid generating unexecutable code-e.g., log(0)-each hypothesis instruction is executed and removed if an error oc- curs. Finally, once the "EOR" tag is generated, we only allow instructions that would generate one of the option "A" to "E" to be generated, which guarantees that one of the options is chosen.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Staged Back-propagation</head><p>As it is shown in <ref type="figure">Figure 2</ref>, math rationales with more than 200 tokens are not uncommon, and with additional intermediate instructions, the size z can easily exceed 400. This poses a practical challenge for training the model. For both the attention and copy mechanisms, for each instruction z i , the model needs to com- pute the probability distribution between all the at- tendable units c conditioned on the previous state h i−1 . For the attention model and input copy mechanisms, c = x 0,i−1 and for the output copy mechanism c = z. These operations generally involve an exponential number of matrix multi- plications as the size of c and z grows. For in- stance, during the computation of the probabilities for the input copy mechanism in Equation 1, the affinity function f between the current context q and a given input u k is generally implemented by projecting u and q into a single vector followed by a non-linearity, which is projected into a sin- gle affinity value. Thus, for each possible input u, 3 matrix multiplications must be performed. Furthermore, for RNN unrolling, parameters and intermediate outputs for these operations must be replicated for each timestamp. Thus, as z becomes larger the attention and copy mechanisms quickly become a memory bottleneck as the computation graph becomes too large to fit on the GPU. In con- trast, the sequence-to-sequence model proposed in <ref type="bibr" target="#b14">(Sutskever et al., 2014</ref>), does not suffer from these issues as each timestamp is dependent only on the previous state h i−1 .</p><p>To deal with this, we use a training method we call staged back-propagation which saves mem- ory by considering slices of K tokens in z, rather than the full sequence. That is, to train on a mini- batch where |z| = 300 with K = 100, we would actually train on 3 mini-batches, where the first batch would optimize for the first z 1:100 , the sec- ond for z 101:200 and the third for z 201:300 . The advantage of this method is that memory intensive operations, such as attention and the copy mecha- nism, only need to be unrolled for K steps, and K can be adjusted so that the computation graph fits in memory.</p><p>However, unlike truncated back-propagation for language modeling, where context outside the scope of K is ignored, sequence-to-sequence models require global context. Thus, the sequence of states h is still built for the whole sequence z. Afterwards, we obtain a slice h j:j+K , and com- pute the attention vector. <ref type="bibr">2</ref> Finally, the prediction of the instruction is conditioned on the LSTM state and the attention vector.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experiments</head><p>We apply our model to the task of generating ratio- nales for solutions to math problems, evaluating it on both the quality of the rationale and the ability of the model to obtain correct answers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Baselines</head><p>As the baseline we use the attention-based se- quence to sequence model proposed by <ref type="bibr">Bahdanau et al. (2014)</ref>, and proposed augmentations, allow- ing it to copy from the input ( <ref type="bibr">Ling et al., 2016)</ref> and from the output (Merity et al., 2016).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Hyperparameters</head><p>We used a two-layer LSTM with a hidden size of H = 200, and word embeddings with size 200. The number of levels that the graph G is expanded during sampling D is set to 5. Decoding is per- formed with a beam of 200. As for the vocabulary of the softmax and embeddings, we keep the most frequent 20,000 word types, and replace the rest of the words with an unknown token. During train- ing, the model only learns to predict a word as an unknown token, when there is no other alternative to generate the word.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Evaluation Metrics</head><p>The evaluation of the rationales is performed with average sentence level perplexity and BLEU- 4 ( <ref type="bibr" target="#b9">Papineni et al., 2002</ref>). When a model cannot generate a token for perplexity computation, we predict unknown token. This benefits the baselines as they are less expressive. As the perplexity of our model is dependent on the latent program that is generated, we force decode our model to gener- ate the rationale, while maximizing the probability of the program. This is analogous to the method used to obtain sample programs described in Sec- tion 4, but we choose the most likely instructions at each timestamp instead of sampling. Finally, the correctness of the answer is evaluated by com- puting the percentage of the questions, where the chosen option matches the correct one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Results</head><p>The test set results, evaluated on perplexity, BLEU, and accuracy, are presented in <ref type="table" target="#tab_3">Table 3</ref>.</p><p>Perplexity. In terms of perplexity, we observe that the regular sequence to sequence model fares poorly on this dataset, as the model requires the generation of many values that tend to be  sparse. Adding an input copy mechanism greatly improves the perplexity as it allows the genera- tion process to use values that were mentioned in the question. The output copying mechanism improves perplexity slightly over the input copy mechanism, as many values are repeated after their first occurrence. For instance, in Problem 2, the value "1326" is used twice, so even though the model cannot generate it easily in the first occur- rence, the second one can simply be generated by copying the first one. We can observe that our model yields significant improvements over the baselines, demonstrating that the ability to gener- ate new values by algebraic manipulation is essen- tial in this task. An example of a program that is inferred is shown in <ref type="figure">Figure 4</ref>. The graph was gen- erated by finding the most likely program z that generates y. Each node isolates a value in x, m, or y, where arrows indicate an operation executed with the outgoing nodes as arguments and incom- ing node as the return of the operation. For sim- plicity, operations that copy or convert values (e.g. from string to float) were not included, but nodes that were copied/converted share the same color. Examples of tokens where our model can obtain the perplexity reduction are the values "0.025", "0.023", "0.002" and finally the answer "E" , as these cannot be copied from the input or output.</p><p>BLEU. We observe that the regular sequence to sequence model achieves a low BLEU score. In fact, due to the high perplexities the model gener- ates very short rationales, which frequently consist of segments similar to "Answer should be D", as most rationales end with similar statements. By applying the copy mechanism the BLEU score improves substantially, as the model can define the variables that are used in the rationale. In- terestingly, the output copy mechanism adds no further improvement in the perplexity evaluation. This is because during decoding all values that can be copied from the output are values that could have been generated by the model either from the softmax or the input copy mechanism. As such, adding an output copying mechanism adds little to the expressiveness of the model during decoding. Finally, our model can achieve the highest BLEU score as it has the mechanism to generate the intermediate and final values in the rationale.</p><p>Accuracy. In terms of accuracy, we see that all baseline models obtain values close to chance (20%), indicating that they are completely unable to solve the problem. In contrast, we see that our model can solve problems at a rate that is signifi- cantly higher than chance, demonstrating the value of our program-driven approach, and its ability to learn to generate programs.</p><p>In general, the problems we solve correctly cor- respond to simple problems that can be solved in one or two operations. Examples include ques- tions such as "Billy cut up each cake into 10 slices, and ended up with 120 slices altogether. How many cakes did she cut up? A) 9 B) 7 C) 12 D) 14 E) 16", which can be solved in a single step. In this case, our model predicts "120 / 10 = 12 cakes. Answer is C" as the rationale, which is reasonable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.5">Discussion.</head><p>While we show that our model can outperform the models built up to date, generating complex ratio- nales as those shown in <ref type="figure">Figure 1</ref> correctly is still an unsolved problem, as each additional step adds complexity to the problem both during inference and decoding. Yet, this is the first result showing that it is possible to solve math problems in such a manner, and we believe this modeling approach and dataset will drive work on this problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Extensive efforts have been made in the domain of math problem solving ( <ref type="bibr">Hosseini et al., 2014;</ref><ref type="bibr" target="#b3">Kushman et al., 2014;</ref><ref type="bibr" target="#b12">Roy and Roth, 2015)</ref>, which aim at obtaining the correct answer to a given math problem. Other work has focused on learning to map math expressions into formal languages <ref type="bibr" target="#b13">(Roy et al., 2016)</ref>. We aim to generate natural language rationales, where the bindings between variables and the problem solving approach are mixed into a single generative model that attempts to solve the problem while explaining the approach taken.</p><p>Our approach is strongly tied with the work on sequence to sequence transduction using the encoder-decoder paradigm <ref type="bibr" target="#b14">(Sutskever et al., 2014;</ref><ref type="bibr"></ref> Bottle R contains 250 capsules and costs $ 6.25 <ref type="table" target="#tab_3">.  Bottle T contains 130 capsules and costs $ 2.99 .  What is the difference between the cost per capsule for bottle R and the  cost per capsule for bottle T ?</ref> (A) $ 0.25 (B) $ 0.12 (C) $ 0.05 (D) $ 0.03 (E) $ 0.002  <ref type="figure">Figure 4</ref>: Illustration of the most likely latent program inferred by our algorithm to explain a held-out question-rationale pair. <ref type="bibr">Bahdanau et al., 2014;</ref><ref type="bibr" target="#b2">Kalchbrenner and Blunsom, 2013)</ref>, and inherits ideas from the extensive literature on semantic parsing ( <ref type="bibr">Jones et al., 2012;</ref><ref type="bibr">Berant et al., 2013;</ref><ref type="bibr" target="#b0">Andreas et al., 2013;</ref><ref type="bibr" target="#b10">Quirk et al., 2015;</ref><ref type="bibr" target="#b5">Liang et al., 2016;</ref><ref type="bibr" target="#b8">Neelakantan et al., 2016)</ref> and program generation <ref type="bibr" target="#b11">(Reed and de Freitas, 2016;</ref><ref type="bibr">Graves et al., 2016)</ref>, namely, the usage of an external memory, the application of differ- ent operators over values in the memory and the copying of stored values into the output sequence.</p><p>Providing textual explanations for classification decisions has begun to receive attention, as part of increased interest in creating models whose deci- sions can be interpreted. <ref type="bibr" target="#b4">Lei et al. (2016)</ref>, jointly modeled both a classification decision, and the se- lection of the most relevant subsection of a docu- ment for making the classification decision. <ref type="bibr">Hendricks et al. (2016)</ref> generate textual explanations for visual classification problems, but in contrast to our model, they first generate an answer, and then, conditional on the answer, generate an ex- planation. This effectively creates a post-hoc jus- tification for a classification decision rather than a program for deducing an answer. These papers, like ours, have jointly modeled rationales and an- swer predictions; however, we are the first to use rationales to guide program induction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>In this work, we addressed the problem of generat- ing rationales for math problems, where the task is to not only obtain the correct answer of the prob- lem, but also generate a description of the method used to solve the problem. To this end, we collect 100,000 question and rationale pairs, and propose a model that can generate natural language and perform arithmetic operations in the same decod- ing process. Experiments show that our method outperforms existing neural models, in both the fluency of the rationales that are generated and the ability to solve the problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 2: Distribution of examples per length.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>h i softmax o i r i softmax r i q i,j=1 softmax q ij softmax copy input a ij q i,j+1 copy output h i+1 j &lt; argc(o i )? v i execute</head><label></label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Results over the test set measured in Per-
plexity, BLEU and Accuracy. 

</table></figure>

			<note place="foot" n="1"> The embeddings of a given argument ai,j and the return value vi are obtained with a lookup table embedding and two flags indicating whether it is a string and whether it is a float. Furthermore, if the the value is a float we also add its numeric value as a feature.</note>

			<note place="foot" n="2"> This modeling strategy is sometimes known as late fusion, as the attention vector is not used for state propagation, it is incorporated &quot;later&quot;.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Semantic parsing as machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Vlachos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Ben</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Recurrent continuous translation models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nal</forename><surname>Kalchbrenner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phil</forename><surname>Blunsom</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Learning to automatically solve algebra word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Rationalizing neural predictions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Lei</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tommi</forename><surname>Jaakkola</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Neural symbolic machines: Learning semantic parsers on freebase with weak supervision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chen</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quoc</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">D</forename><surname>Forbus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ni</forename><surname>Lao</surname></persName>
		</author>
		<idno>arXiv 1611.00020</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Karl Moritz Hermann, Tomás Kocisk´yKocisk´y, Andrew Senior, Fumin Wang, and Phil Blunsom. 2016. Latent predictor networks for code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wang</forename><surname>Ling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Grefenstette</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Pointer sentinel mixture models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Merity</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caiming</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Bradbury</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<idno>arXiv 1609.07843</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Neural programmer: Inducing latent programs with gradient descent</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arvind</forename><surname>Neelakantan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Le</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sutskever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ICLR</title>
		<meeting>ICLR</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Bleu: A method for automatic evaluation of machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kishore</forename><surname>Papineni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Salim</forename><surname>Roukos</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Todd</forename><surname>Ward</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weijing</forename><surname>Zhu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL</meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Language to code: Learning semantic parsers for if-this-then-that recipes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Quirk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><surname>Mooney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michel</forename><surname>Galley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Neural programmer-interpreters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Scott</forename><forename type="middle">E</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nando De Freitas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ICLR</title>
		<meeting>of ICLR</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Solving general arithmetic word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhro</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Equation parsing: Mapping sentences to grounded equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhro</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shyam</forename><surname>Upadhyay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Sequence to sequence learning with neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Quoc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Le</surname></persName>
		</author>
		<idno>arXiv 1409.3215</idno>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Pointer networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Meire</forename><surname>Fortunato</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navdeep</forename><surname>Jaitly</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of NIPS</title>
		<meeting>of NIPS</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
