<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T10:38+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">An Efficient Dynamic Oracle for Unrestricted Non-Projective Parsing</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>July 26-31, 2015. 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gómez-Rodríguez</surname></persName>
							<email>carlos.gomez@udc.es</email>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Computación</orgName>
								<orgName type="laboratory">Departamento de Informática Universidade de Vigo Campus As Lagoas, s/n</orgName>
								<orgName type="institution">Universidade da Coruña Campus de Elviña</orgName>
								<address>
									<postCode>32004</postCode>
									<settlement>s/n 15071 A Coruña, Ourense</settlement>
									<country>Spain, Spain</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Fernández-González</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Departamento de Computación</orgName>
								<orgName type="laboratory">Departamento de Informática Universidade de Vigo Campus As Lagoas, s/n</orgName>
								<orgName type="institution">Universidade da Coruña Campus de Elviña</orgName>
								<address>
									<postCode>32004</postCode>
									<settlement>s/n 15071 A Coruña, Ourense</settlement>
									<country>Spain, Spain</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">An Efficient Dynamic Oracle for Unrestricted Non-Projective Parsing</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
						<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing <address><addrLine>Beijing, China</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="256" to="261"/>
							<date type="published">July 26-31, 2015. 2015</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We define a dynamic oracle for the Cov-ington non-projective dependency parser. This is not only the first dynamic oracle that supports arbitrary non-projectivity, but also considerably more efficient (O(n)) than the only existing oracle with restricted non-projectivity support. Experiments show that training with the dynamic oracle significantly improves parsing accuracy over the static oracle baseline on a wide range of treebanks.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Greedy transition-based dependency parsers build analyses for sentences incrementally by following a sequence of transitions defined by an automaton, using a scoring model to choose the best trans- ition to take at each state <ref type="bibr" target="#b18">(Nivre, 2008)</ref>. While this kind of parsers have become very popular, as they achieve competitive accuracy with espe- cially fast parsing times; their raw accuracy is still behind that of slower alternatives like transition- based parsers that use beam search ( <ref type="bibr" target="#b23">Zhang and Nivre, 2011;</ref><ref type="bibr" target="#b6">Choi and McCallum, 2013)</ref>. For this reason, a current research challenge is to improve the accuracy of greedy transition-based parsers as much as possible without sacrificing efficiency.</p><p>A relevant recent advance in this direction is the introduction of dynamic oracles <ref type="bibr" target="#b8">(Goldberg and Nivre, 2012)</ref>, an improvement in the training pro- cedure of greedy parsers that can boost their ac- curacy without any impact on parsing speed. An oracle is a training component that selects the best transition(s) to take at a given configuration, us- ing knowledge about the gold tree. Traditionally, transition-based parsers were trained to follow a so-called static oracle, which is only defined on the configurations of a canonical computation that generates the gold tree, returning the next trans- ition in said computation. In contrast, dynamic oracles are non-deterministic (not limited to one sequence, but supporting all the possible computa- tions leading to the gold tree), and complete (also defined for configurations where the gold tree is unreachable, choosing the transition(s) that lead to a tree with minimum error). This extra robustness in training provides higher parsing accuracy.</p><p>However, defining a usable dynamic oracle for a given parser is non-trivial in general, due to the need of calculating the loss of each configura- tion, i.e., the minimum Hamming loss to the gold tree from a tree reachable from that configuration. While it is always easy to do this in exponential time by simulating all possible computations in the algorithm to obtain all reachable trees, it is not always clear how to achieve this calculation in polynomial time. At the moment, this prob- lem has been solved for several projective pars- ers exploiting either arc-decomposability <ref type="bibr" target="#b9">(Goldberg and Nivre, 2013</ref>) or tabularization of compu- tations ( <ref type="bibr" target="#b10">Goldberg et al., 2014</ref>). However, for pars- ers that can handle crossing arcs, the only known dynamic oracle ( <ref type="bibr" target="#b12">Gómez-Rodríguez et al., 2014)</ref> has been defined for a variant of the parser by At- tardi (2006) that supports a restricted set of non- projective trees. To our knowledge, no dynamic oracles are known for any transition-based parser that can handle unrestricted non-projectivity.</p><p>In this paper, we define such an oracle for the Covington non-projective parser <ref type="bibr" target="#b7">(Covington, 2001;</ref><ref type="bibr" target="#b18">Nivre, 2008)</ref>, which can handle arbitrary non-projective dependency trees. As this al- gorithm is not arc-decomposable and its tabular- ization is NP-hard <ref type="bibr" target="#b14">(Neuhaus and Bröker, 1997</ref>), we do not use the existing techniques to define dynamic oracles, but a reasoning specific to this parser. It is worth noting that, apart from being the first dynamic oracle supporting unrestricted non- projectivity, our oracle is very efficient, solving the loss calculation in O(n). In contrast, the restricted non-projective oracle of <ref type="bibr" target="#b12">Gómez-Rodríguez et al. (2014)</ref> has O(n 8 ) time complexity.</p><p>The rest of the paper is organized as follows: after a quick outline of Covington's parser in Sect. 2, we present the oracle and prove its cor- rectness in Sect. 3. Experiments are reported in Sect. 4, and Sect. 5 contains concluding remarks.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head><p>We will define a dynamic oracle for the non- projective parser originally defined by <ref type="bibr" target="#b7">Covington (2001)</ref>, and implemented by <ref type="bibr" target="#b18">Nivre (2008)</ref> under the transition-based parsing framework. For space reasons, we only sketch the parser very briefly, and refer to the above reference for more details.</p><p>Parser configurations are of the form c = λ 1 , λ 2 , B, A, where λ 1 and λ 2 are lists of par- tially processed words, B is another list (called the buffer) with currently unprocessed words, and A is the set of dependencies built so far. Suppose that we parse a string w 1 · · · w n , whose word occur- rences will be identified with their indices 1 · · · n for simplicity. Then, the parser starts at an initial configuration c s ( <ref type="bibr">[1 . . . n]</ref>, ∅∅, and executes transitions chosen from those in <ref type="figure">Fig- ure 1</ref> until a terminal configuration of the form {{λ 1 , λ 2 , [], A ∈ C} is reached, and the sen- tence's parse tree is obtained from A. <ref type="bibr">1</ref> The transition semantics is very simple, mirror- ing the double nested loop traversing word pairs in the formulation by <ref type="bibr" target="#b7">Covington (2001)</ref>. When the algorithm is in a configuration λ 1 |i, λ 2 , j|B, A, we will say that it is considering the focus words i and j, located at the end of the first list and at the beginning of the buffer. A decision is then made about whether these two words should be linked with a rightward arc i → j (Right-Arc transition), a leftward arc i ← j (Left-Arc transition) or not linked (No-Arc transition). The first two choices will be unavailable in configurations where the newly-created arc would violate the single-head constraint (a node cannot have more than one in- coming arc) or the acyclicity constraint (cycles are not allowed). In any of these three transitions, i is then moved to the second list to make i−1 and j the focus words for the next step. Alternatively, we can choose to read a new word from the string with a Shift transition, so that the focus words in the resulting configuration will be j and j + 1.</p><formula xml:id="formula_0">w 1 . . . w n ) = [], [],</formula><p>The result is a parser that can generate any pos- sible dependency tree for the input, and runs in quadratic worst-case time. Although in theory this complexity can seem like a drawback compared to linear-time transition-based parsers (e.g. <ref type="bibr" target="#b17">(Nivre, 2003;</ref><ref type="bibr" target="#b11">Gómez-Rodríguez and Nivre, 2013)</ref>), it has been shown by <ref type="bibr" target="#b20">Volokh and Neumann (2012)</ref> to ac- tually outperform linear algorithms in practice, as it allows for relevant optimizations in feature ex- traction that cannot be implemented in other pars- ers. In fact, one of the fastest dependency parsers to date uses this algorithm (Volokh, 2013).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The oracle</head><p>As sketched in Sect. 1, a dynamic oracle is a train- ing component that, given a configuration c and a gold tree t G , provides the set of transitions that are applicable in c and lead to trees with minimum Hamming loss with respect to t G . The Hamming loss between a tree t and t G , written L(t, t G ), is the number of nodes that have a different head in t than in t G . Following <ref type="bibr" target="#b9">Goldberg and Nivre (2013)</ref>, we say that a set of arcs A is reachable from con- figuration c, written c A, if there is some (pos- sibly empty) path of transitions from c to some configuration c = λ 1 , λ 2 , B, A , with A ⊆ A . Then, we can define the loss of a configuration as</p><formula xml:id="formula_1">(c) = min t|ct L(t, t G ),</formula><p>and the set of transitions that must be returned by a correct dynamic oracle is then</p><formula xml:id="formula_2">o d (c, t G ) = {τ | (c) − (τ (c)) = 0},</formula><p>i.e., the transitions that do not increase configur- ation loss, and hence lead to the best parse (in terms of loss) reachable from c. Therefore, imple- menting a dynamic oracle reduces to computing the loss (c) for each configuration c. <ref type="bibr" target="#b9">Goldberg and Nivre (2013)</ref> show that the calcu- lation of the loss is easy for parsers that are arc- decomposable, i.e., those where for every config- uration c and arc set A that is tree-compatible (i.e. that can be a part of a well-formed parse 2 ), c A is entailed by c (i → j) for every i → j ∈ A. That is, if each arc in a tree-compatible set is indi- vidually reachable from configuration c, then that Shift:</p><formula xml:id="formula_3">λ 1 , λ 2 , j|B, A ⇒ λ 1 · λ 2 |j, [], B, A No-Arc: λ 1 |i, λ 2 , B, A ⇒ λ 1 , i|λ 2 , B, A Left-Arc: λ 1 |i, λ 2 , j|B, A ⇒ λ 1 , i|λ 2 , j|B, A ∪ {j → i}} only if k | k → i ∈ A (single-head) and i → * j ∈ A (acyclicity).</formula><p>Right-Arc: set of arcs is reachable from c. If this holds, then computing the loss of a configuration c reduces to determining and counting the gold arcs that are not reachable from c, which is easy in most parsers. Unfortunately, the Covington parser is not arc- decomposable. This can be seen in the example of <ref type="figure">Figure 2</ref>: while any of the gold arcs 2→3, 3→4, 4→1 can be reachable individually from the depic- ted configuration, they are not jointly reachable as they form a cycle with the already-built arc 1→2. Thus, the configuration has only one individually unreachable arc (0→2), but its loss is 2.</p><formula xml:id="formula_4">λ 1 |i, λ 2 , j|B, A ⇒ λ 1 , i|λ 2 , j|B, A ∪ {i → j}} only if k | k → j ∈ A (single-head) and j → * i ∈ A (acyclicity).</formula><p>However, it is worth noting that non-arc- decomposability in the parser is exclusively due to cycles. If a set of individually reachable arcs do not form a cycle together with already-built arcs, then we can show that the set will be reachable. This idea is the basis for an expression to compute loss based on counting individually unreachable arcs, and then correcting for the effect of cycles:</p><p>Theorem 1 Let c = λ 1 , λ 2 , B, A be a config- uration of the Covington parser, and t G the set of arcs of a gold tree. We call I(c, t G ) = {x → y ∈ t G | c (x → y)} the set of individually reach- able arcs of t G ; note that this set may overlap A. Conversely, we call U(c, t G ) = t G \ I(c, t G ) the set of individually unreachable arcs of t G from c. Finally, let n c (G) denote the number of cycles in a graph G.</p><p>Then</p><formula xml:id="formula_5">(c) = |U(c, t G )| + n c (A ∪ I(c, t G )). 2</formula><p>We now sketch the proof. To prove Theorem 1, it is enough to show that (1) there is at least one tree reachable from c with exactly that Hamming loss to t G , and (2) there are no trees reachable from c with a smaller loss. To this end, we will use some properties of the graph A∪I(c, t G ). First, we note that no node in this graph has in-degree greater than 1. In particular, each node except for the dummy root has exactly one head, either explicit or (if no head has been assigned in A or in the gold tree) the dummy root. No node has more than one head: a node cannot have two heads in A because the parser transitions enforce the single-head con- straint, it cannot have two heads in I(c, t G ) be- cause t G must satisfy this constraint as well, and it cannot have one head in A and another in I(c, t G ) because the corresponding arc in I(c, t G ) would be unreachable due to the single-head constraint.</p><p>This, in turn, implies that the graph A∪I(c, t G ) has no overlapping cycles, as overlapping cycles can only appear in graphs with in-degree greater than 1. This is the key property enabling us to exactly calculate loss using the number of cycles.</p><p>To show (1), consider the graph A ∪ I(c, t G ). In each of its cycles, there is at least one arc that belongs to I(c, t G ), as A must satisfy the acyclicity constraint. We arbitrarily choose one such arc from each cycle, and remove it from the graph. Note that this results in removing ex- actly n c <ref type="figure">(A ∪ I(c, t G )</ref>) arcs, as we have shown that the cycles in A ∪ I(c, t G ) are disjoint. We call the resulting graph B(c, t G ). As it has max- imum in-degree 1 and it is acyclic (because we have broken all the cycles), B(c, t G ) is a tree, mod- ulo our standard assumption that headless nodes are assumed to be linked to the dummy root.</p><p>This tree B(c, t G ) is reachable from c and has loss (c) = |U(c, t G )| + n c <ref type="figure">(A ∪ I(c, t G )</ref>). Reach- ability is shown by building a sequence of trans-itions that will visit the pairs of words corres- ponding to remaining arcs in order, and inter- calating the corresponding Left-Arc or Right-Arc transitions, which cannot violate the acyclicity or single-head constraints. The term U(c, t G ) in the loss stems from the fact that A ∪ I(c, t G ) can- not contain arcs in U(c, t G ), and the term n c <ref type="figure">(A ∪  I(c, t G )</ref>) from not including the n c <ref type="figure">(A ∪ I(c, t G )</ref>) arcs that we discarded to break cycles.</p><p>Finally, from these observations, it is easy to see that B(c, t G ) has the best loss among reach- able trees, and thus prove (2): the arcs in U(c, t G ) are always unreachable by definition, and for each cycle in n c <ref type="figure">(A ∪ I(c, t G )</ref>), the acyclicity con- straint forces us to miss at least one arc. As the cycles are disjoint, this means that we neces- sarily miss at least n c (A ∪ I(c, t G )) arcs, hence |U(c, t G )| + n c (A ∪ I(c, t G )) is indeed the min- imum loss among reachable trees.</p><p>Thus, to calculate the loss of a configuration c, we only need to compute both of the terms in The- orem 1. For the first term, note that if c has focus words i and j (i.e., c = λ 1 |i, λ 2 , j|B, A), then an arc x → y is in U(c, t G ) if it is not in A, and at least one of the following holds:</p><p>• j &gt; max(x, y), as in this case we have read too far in the string and will not be able to get x and y as focus words, • j = max(x, y) ∧ i &lt; min(x, y), as in this case we have max(x, y) as the right focus word but the left focus word is to the left of min(x, y), and we cannot move it back, • there is some z = 0, z = x such that z → y ∈ A, as in this case the single-head constraint prevents us from creating x → y, • x and y are on the same weakly connected component of A, as in this case the acyclicity constraint will not let us create x → y. All of these arcs can be trivially enumerated in O(n) time (in fact, they can be updated in O(1) if we start from the configuration that preceded c). The second term of the loss, n c <ref type="figure">(A ∪ I(c, t G )</ref>), can be computed by obtaining I(c, t G ) as t G \U(c, t G ) to then apply a standard cycle-finding algorithm <ref type="bibr" target="#b19">(Tarjan, 1972)</ref> which, for a graph with maximum in-degree 1, runs in O(n) time.</p><p>Algorithm 1 presents the resulting loss cal- culation algorithm in pseudocode form, where COUNTCYCLES is a function that counts the num- ber of cycles in the given graph in linear time as mentioned above. Note that the for loop runs in Algorithm 1 Computation of the loss of a config- uration.</p><p>1: function LOSS(c = λ 1 |i, λ 2 , j|B, A, t G ) 2:</p><formula xml:id="formula_6">U ← ∅ Variable U is for U(c, t G ) 3:</formula><p>for each x → y ∈ (t G \ A) do</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>left ← min(x, y)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5:</head><p>right ← max(x, y)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>if j &gt; right ∨ 7:</p><formula xml:id="formula_7">(j = right ∧ i &lt; left) ∨ 8: (∃z &gt; 0, z = x : z → y ∈ A) ∨ 9:</formula><p>WEAKLYCONNECTED(A, x, y) then 10:</p><formula xml:id="formula_8">U ← u ∪ {x → y} 11: I ← t G \ U Variable I is for I(c, t G ) 12:</formula><p>return |U | + COUNTCYCLES(A ∪ I ) linear time: the condition on line 8 can be com- puted in constant time by recovering the head of y. The call to WEAKLYCONNECTED in line 9 finds out whether the two given nodes are weakly connected in A, and can also be resolved in O <ref type="formula">(1)</ref>, by querying the disjoint set data structure that implementations of the Covington algorithm commonly use for the parser's acyclicity checks <ref type="bibr" target="#b18">(Nivre, 2008)</ref>. It is worth noting that the linear-time com- plexity can also be achieved by a standalone im- plementation of the loss calculation algorithm, without recurse to the parser's auxiliary data struc- tures (although this is dubiously practical). To do so, we can implement WEAKLYCONNECTED so that the first call computes the connected com- ponents of A in linear time <ref type="bibr" target="#b13">(Hopcroft and Tarjan, 1973)</ref> and subsequent calls use this information to find out if two nodes are weakly connected in con- stant time.</p><p>On the other hand, a more efficient implementa- tion than the one shown in Algorithm 1 (which we chose for clarity) can be achieved by more tightly coupling the oracle to the parser, as the relevant sets of arcs associated with a configuration can be obtained incrementally from those of the previous configuration. <ref type="table">Table 1</ref>: Feature templates. L 0 and R 0 denote the left and right focus words; L 1 , L 2 , . . . are the words to the left of L 0 and R 1 , R 2 , . . . those to the right of R 0 . X ih means the head of X i , X ih2 the grandparent, X il and X il the farthest and closest left dependents, and X ir and X ir the farthest and closest right dependents, respectively. CL and CR are the first and last words between L 0 and R 0 whose head is not in the interval [L 0 , R 0 ]. Finally, w stands for word form; p for PoS tag; l for de- pendency label; d is the distance between L 0 and R 0 ; v l , v r are the left/right valencies (number of left/right dependents); and s l , s r the left/right label sets (dependency labels of left/right dependents). sets from the CoNLL-XI shared task ( <ref type="bibr" target="#b16">Nivre et al., 2007)</ref>. We use the same feature templates for all languages, which result from adapting the features described by <ref type="bibr" target="#b23">Zhang and Nivre (2011)</ref> to the data structures of the Covington non-projective parser, and are listed in detail in <ref type="table">Table 1</ref>. <ref type="table" target="#tab_1">Table 2</ref> reports the accuracy obtained by the Covington non-projective parser with both or- acles. As we can see, the dynamic oracle imple- mented in the Covington algorithm improves over the accuracy of the static version on all datasets except Japanese and Swedish, and most improve- ments are statistically significant at the .05 level. <ref type="bibr">3</ref> In addition, the Covington dynamic oracle achieves a greater average improvement in ac- curacy than the Attardi dynamic oracle ( <ref type="bibr">GómezRodríguez et al., 2014</ref>) over their respective static versions. Concretely, the Attardi oracle accom- plishes an average improvement of 0.52 percent-  age points in UAS and 0.71 in LAS, while our ap- proach achieves 0.80 in UAS and 0.74 in LAS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have defined the first dynamic oracle for a transition-based parser supporting unrestricted non-projectivity. The oracle is very efficient, com- puting loss in O(n), compared to O(n 8 ) for the only previously known dynamic oracle with sup- port for a subset of non-projective trees <ref type="bibr">(GómezRodríguez et al., 2014</ref>). Experiments on the treebanks from the CoNLL- X and CoNLL-XI shared tasks show that the dy- namic oracle significantly improves accuracy on many languages over a static oracle baseline.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Figure 1: Transitions of the Covington non-projective dependency parser.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Parsing accuracy (UAS and LAS, in-
cluding punctuation) of Covington non-projective 
parser with static (s-Covington) and dynamic (d-
Covington) oracles on CoNLL-XI (first block) and 
CoNLL-X (second block) datasets. For each lan-
guage, we run five experiments with the same 
setup but different seeds and report the averaged 
accuracy. Best results for each language are shown 
in boldface. Statistically significant improvements 
(α = .05) (Yeh, 2000) are marked with  *  . 

</table></figure>

			<note place="foot" n="1"> The arcs in A form a forest, but we convert it to a tree by linking any node without a head as a dependent of an artificial node at position 0 that acts as a dummy root. From now on, when we refer to some dependency graph as a tree, we assume that this transformation is being implicitly made.</note>

			<note place="foot" n="2"> In the cited paper, tree-compatibility required projectivity, as the authors were dealing with projective parsers. In our case, since the parser is non-projective, tree-compatibility only consists of the single-head and acyclicity constraints.</note>

			<note place="foot" n="4"> Experiments To evaluate the performance of our approach, we conduct experiments on both static and dynamic Covington non-projective oracles. Concretely, we train an averaged perceptron model for 15 iterations on nine datasets from the CoNLL-X shared task (Buchholz and Marsi, 2006) and all data</note>

			<note place="foot" n="3"> Note that the loss of accuracy in Japanese and Swedish is not statistically significant.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Research partially funded by the Spanish Min-istry of Economy and Competitiveness/ERDF (grants FFI2014-51978-C2-1-R, FFI2014-51978-C2-2-R), Ministry of Education (FPU grant pro-gram) and Xunta de Galicia (grant R2014/034).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><surname>R2wp; Clw; Clp; Clwp; Crw; Crp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Crwp</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">L0p+R0wp; L0w+R0w; L0p+R0p</title>
		<imprint>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Triples</title>
		<imprint/>
	</monogr>
	<note>R0p+R1p+R2p; L0p+R0p+R1p; L 0h p+L0p+R0p</note>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">L0p+L 0l p+R0p</title>
		<imprint/>
	</monogr>
	<note>L0p+L 0r p+R0p; L0p+R0p+R 0l p</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Experiments with a multilanguage non-projective dependency parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuseppe</forename><surname>References</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Attardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL-X)</title>
		<meeting>the 10th Conference on Computational Natural Language Learning (CoNLL-X)<address><addrLine>Morristown, NJ, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="166" to="170" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">CoNLLX shared task on multilingual dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sabine</forename><surname>Buchholz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Erwin</forename><surname>Marsi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th Conference on Computational Natural Language Learning (CoNLL)</title>
		<meeting>the 10th Conference on Computational Natural Language Learning (CoNLL)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="149" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Transition-based dependency parsing with selectional branching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Jinho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Choi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 51st Annual Meeting of the Association for Computational Linguistics<address><addrLine>Sofia, Bulgaria</addrLine></address></meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2013" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1052" to="1062" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A fundamental algorithm for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Michael</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Covington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th Annual ACM Southeast Conference</title>
		<meeting>the 39th Annual ACM Southeast Conference<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A dynamic oracle for arc-eager dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mumbai, India, December. Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="959" to="976" />
		</imprint>
	</monogr>
	<note>Proceedings of COLING 2012</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Training deterministic parsers with non-deterministic oracles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="403" to="414" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A tabular method for dynamic oracles in transition-based parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesco</forename><surname>Sartorio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Satta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="119" to="130" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Divisible transition systems and multiplanar dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gómez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-Rodríguez</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="799" to="845" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A polynomial-time dynamic oracle for non-projective dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gómez-Rodríguez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francesco</forename><surname>Sartorio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Satta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP)</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="917" to="927" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Algorithm 447: Efficient algorithms for graph manipulation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">Endre</forename><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Commun. ACM</title>
		<imprint>
			<biblScope unit="volume">16</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="372" to="378" />
			<date type="published" when="1973-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The complexity of recognition of linguistically adequate dependency grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Neuhaus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Norbert</forename><surname>Bröker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 35th</title>
		<meeting>the 35th</meeting>
		<imprint>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
				<title level="m">Annual Meeting of the Association for Computational Linguistics (ACL) and the 8th Conference of the European Chapter of the Association for Computational Linguistics (EACL)</title>
		<imprint>
			<biblScope unit="page" from="337" to="343" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">The CoNLL 2007 shared task on dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Johan</forename><surname>Hall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandra</forename><surname>Kübler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jens</forename><surname>Nilsson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Riedel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deniz</forename><surname>Yuret</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the CoNLL Shared Task Session of EMNLP-CoNLL</title>
		<meeting>the CoNLL Shared Task Session of EMNLP-CoNLL</meeting>
		<imprint>
			<date type="published" when="2007-06" />
			<biblScope unit="page" from="915" to="932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An efficient algorithm for projective dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Parsing Technologies (IWPT 03)</title>
		<meeting>the 8th International Workshop on Parsing Technologies (IWPT 03)</meeting>
		<imprint>
			<publisher>ACL/SIGPARSE</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="149" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithms for Deterministic Incremental Dependency Parsing. Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="513" to="553" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Depth-first search and linear graph algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Robert Endre Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM J. Comput</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="146" to="160" />
			<date type="published" when="1972" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Dependency parsing with efficient feature extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Volokh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Günter</forename><surname>Neumann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<editor>Birte Glimm and Antonio Krüger</editor>
		<imprint>
			<biblScope unit="volume">7526</biblScope>
			<biblScope unit="page" from="253" to="256" />
			<date type="published" when="2012" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Performance-Oriented Dependency Parsing. Doctoral dissertation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Volokh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<pubPlace>Saarbrücken, Germany</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Saarland University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">More accurate tests for the statistical significance of result differences</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Yeh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th International Conference on Computational Linguistics (COLING)</title>
		<meeting>the 18th International Conference on Computational Linguistics (COLING)</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="947" to="953" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Transition-based dependency parsing with rich non-local features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="188" to="193" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
