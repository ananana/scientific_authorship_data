<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:50+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Learning Semantic Correspondences in Technical Documentation</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>July 30-August 4, 2017. July 30-August 4, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyle</forename><surname>Richardson</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Kuhn</surname></persName>
						</author>
						<title level="a" type="main">Learning Semantic Correspondences in Technical Documentation</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</title>
						<meeting>the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) <address><addrLine>Vancouver, Canada; Vancouver, Canada</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="1612" to="1622"/>
							<date type="published">July 30-August 4, 2017. July 30-August 4, 2017</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.18653/v1/p17-1148</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We consider the problem of translating high-level textual descriptions to formal representations in technical documentation as part of an effort to model the meaning of such documentation. We focus specifically on the problem of learning translational correspondences between text descriptions and grounded representations in the target documentation, such as formal representation of functions or code templates. Our approach exploits the parallel nature of such documentation, or the tight coupling between high-level text and the low-level representations we aim to learn. Data is collected by mining technical documents for such parallel text-representation pairs, which we use to train a simple semantic parsing model. We report new baseline results on sixteen novel datasets, including the standard library documentation for nine popular programming languages across seven natural languages, and a small collection of Unix utility manuals.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Technical documentation in the computer domain, such as source code documentation and other how- to manuals, provide high-level descriptions of how lower-level computer programs and utilities work. Often these descriptions are coupled with formal representations of these lower-level features, ex- pressed in the target programming languages. For example, <ref type="figure" target="#fig_0">Figure 1</ref>.1 shows the source code doc- umentation (in red/bold) for the max function in the Java programming language paired with the representation of this function in the underlying Java language (in black). This formal representa- tion captures the name of the function, the return value, the types of arguments the function takes, among other details related to the function's place and visibility in the overall source code collection or API.</p><p>Given the high-level nature of the textual anno- tations, modeling the meaning of any given de- scription is not an easy task, as it involves much more information than what is directly provided in the associated documentation. For example, cap- turing the meaning of the description the greater of might require having a background theory about quantity/numbers and relations between different quantities. A first step towards capturing the meaning, however, is learning to translate this de- scription to symbols in the target representation, in this case to the max symbol. By doing this trans- lation to a formal language, modeling and learn- ing the subsequent semantics becomes easier since we are eliminating the ambiguity of ordinary lan-   guage. Similarly, we would want to first translate the description two long values, which specifies the number and type of argument taken by this function, to the sequence long a,long b.</p><p>By focusing on translation, we can create new datasets by mining these types of source code collections for sets of parallel text-representation pairs. Given the wide variety of available pro- gramming languages, many such datasets can be constructed, each offering new challenges related to differences in the formal representations used by different programming languages. <ref type="figure" target="#fig_0">Figure 1</ref>.2 shows example documentation for the Clojure pro- gramming language, which is part of the Lisp fam- ily of languages. In this case, the description Re- turns random probability of should be translated to the function name random-sample since it describes what the overall function does. Simi- larly, the argument descriptions from coll and of prob should translate to coll and prob.</p><p>Given the large community of programmers around the world, many source code collections are available in languages other than English. <ref type="bibr">Figure 1.3</ref> shows an example entry from the French version of the PHP standard library, which was translated by volunteer developers. Having multi- lingual data raises new challenges, and broadens the scope of investigations into this type of seman- tic translation.</p><p>Other types of technical documentation, such as utility manuals, exhibit similar features. <ref type="figure" target="#fig_3">Fig- ure 2</ref> shows an example manual in the domain of Unix utilities. The textual description in red/bold describes an example use of the dappprof util- ity paired with formal representations in the form of executable code. As with the previous exam- ples, such formal representations do not capture the full meaning of the different descriptions, but serve as a convenient operationalization, or trans- lational semantics, of the meaning in Unix. Print elapsed time, for example, roughly describes what the dappprof utility does, whereas PID 1871 describes the second half of the code sequence.</p><p>In both types of technical documentation, infor- mation is not limited to raw pairs of descriptions and representations, but can include other infor- mation and clues that are useful for learning. Java function annotations include textual descriptions of individual arguments and return values (shown in green). Taxonomic information and pointers to related functions or utilities are also annotated (e.g., the @see section in <ref type="figure" target="#fig_0">Figure 1</ref>, or SEE ALSO section in <ref type="figure" target="#fig_3">Figure 2</ref>). Structural information about code sequences, and the types of abstract argu- ments these sequences take, are described in the SYNOPSIS section of the Unix manual. This last piece of information allows us to generate abstract code templates, and generalize individual argu- ments. For example, the raw argument 1871 in the sequence dappprof -p 1871 can be typed as a PID instance, and an argument of the -p flag.</p><p>Given this type of data, a natural experiment is to see whether we can build programs that trans- late high-level textual descriptions to correct for- mal representations. We aim to learn these trans- lations using raw text-meaning pairs as the sole su- pervision. Our focus is on learning function trans- lations or representations within nine program- ming language APIs, each varying in size, repre- sentation style, and source natural language. To our knowledge, our work is the first to look at translating source code descriptions to formal rep- resentations using such a wide variety of program- ming and natural languages. In total, we intro- duce fourteen new datasets in the source code do- main that include seven natural languages, and re- port new results for an existing dataset. As well, we look at learning simple code templates using a small collection of English Unix manuals.</p><p>The main goal of this paper is to establish strong baselines results on these resources, which we hope can be used for benchmarking and develop- ing new semantic parsing methods. We achieved initial baselines using the language modeling and translation approach of <ref type="bibr" target="#b10">Deng and Chrupała (2014)</ref>. We also show that modest improvements can be achieved by using a more conventional discriminative model <ref type="bibr" target="#b42">(Zettlemoyer and Collins, 2009</ref>) that, in part, exploits document-level fea- tures from the technical documentation sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Our work is situated within research on seman- tic parsing, which focuses on the problem of generating formal meaning representations from text for natural language understanding applica- tions. Recent interest in this topic has centered around learning meaning representation from ex- ample text-meaning pairs, for applications such as automated question-answering ( <ref type="bibr" target="#b3">Berant et al., 2013)</ref>, robot control ( <ref type="bibr" target="#b26">Matuszek et al., 2012</ref>) and text generation <ref type="bibr" target="#b39">(Wong and Mooney, 2007a)</ref>.</p><p>While generating representations for natural language understanding is a complex task, most studies focus on the translation or generation prob- lem independently of other semantic or knowledge representation issues. Earlier work looks at super- vised learning of logical representations using ex- ample text-meaning pairs using tools from statisti- cal machine translation ( <ref type="bibr" target="#b38">Wong and Mooney, 2006</ref>) and parsing <ref type="bibr" target="#b42">(Zettlemoyer and Collins, 2009</ref>). These methods are meant to be applicable to a wide range of translation problems and represen- tation types, which make new parallel datasets or resources useful for furthering the research.</p><p>In general, however, such datasets are hard to construct since building them requires consider- able domain knowledge and knowledge of logic. Alternatively, we construct parallel datasets au- tomatically from technical documentation, which obviates the need for annotation. While the for- mal representations are not actual logical forms, they still provide a good test case for testing how well semantic parsers learn translations to repre- sentations.</p><p>To date, most benchmark datasets are limited to small controlled domains, such as geography and navigation. While attempts have been made to do open-domain semantic parsing using larger, more complex datasets ( <ref type="bibr" target="#b3">Berant et al., 2013;</ref><ref type="bibr" target="#b29">Pasupat and Liang, 2015</ref>), such resources are still scarce. In <ref type="figure" target="#fig_5">Figure 3</ref>, we compare the details of one widely used dataset, Geoquery ( <ref type="bibr" target="#b41">Zelle and Mooney, 1996)</ref>, to our new datasets. Our new resources are on av- erage much larger than geoquery in terms of the number of example pairs, and the size of the differ- ent language vocabularies. Most existing datasets are also primarily English-based, while we focus on learning in a multilingual setting using several new moderately sized datasets.</p><p>Within semantic parsing, there has also been work on situated or grounded learning, that in- volves learning in domains with weak supervision and indirect cues <ref type="bibr" target="#b22">(Liang, 2016;</ref><ref type="bibr" target="#b35">Richardson and Kuhn, 2016)</ref>. This has sometimes involved learn- ing from automatically generated parallel data and representations <ref type="bibr" target="#b7">(Chen and Mooney, 2008</ref>) of the type we consider in this paper. Here one can find work in technical domains, including learning to generate regular expressions ( <ref type="bibr" target="#b25">Manshadi et al., 2013;</ref><ref type="bibr" target="#b19">Kushman and Barzilay, 2013</ref>) and other types of source code <ref type="bibr" target="#b31">(Quirk et al., 2015)</ref>, which ultimately aim to solve the problem of natural lan- guage programming. We view our work as one small step in this general direction.</p><p>Our work is also related to software components retrieval and builds on the approach of <ref type="bibr" target="#b10">Deng and Chrupała (2014)</ref>. Robustly learning the translation from language to code representations can help to facilitate natural language querying of API collec- tions ( <ref type="bibr" target="#b23">Lv et al., 2015)</ref>. As part of this effort, recent work in machine learning has focused on the sim- ilar problem of learning code representations us- ing resources such as StackOverflow and Github. These studies primarily focus on learning longer programs ( <ref type="bibr" target="#b0">Allamanis et al., 2015</ref>) as opposed to function representations, or focus narrowly on a single programming language such as Java ( <ref type="bibr" target="#b14">Gu et al., 2016</ref>) or on related tasks such as text gener- ation ( <ref type="bibr" target="#b15">Iyer et al., 2016;</ref><ref type="bibr" target="#b28">Oda et al., 2015)</ref>. To our knowledge, none of this work has been applied to languages other than English or such a wide vari- ety of programming languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Mapping Text to Representations</head><p>In this section, we formulate the basic problem of translating to representations in technical doc- umentation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Problem Description</head><p>We use the term technical documentation to re- fer to two types of resources: textual descriptions inside of source code collections, and computer utility manuals. In this paper, the first type in- cludes high-level descriptions of functions in stan- dard library source code documentation. The sec- ond type includes a collection of Unix manuals, also known as man pages. Both types include pairs of text and code representations. </p><note type="other">#Descr. Symbols#Words Vocab. Example Pairs (x, z), Goal: learn a function x → z</note></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Java 7,183 4,804 4,072 82,696 3,721</head><p>x : Compares this Calendar to the specified Object. z : boolean util.Calendar.equals(Object obj)  We will refer to the target representations in these resources as API components, or compo- nents. In source code, components are formal rep- resentations of functions, or function signatures <ref type="bibr" target="#b10">(Deng and Chrupała, 2014)</ref>. The form of a func- tion signature varies depending on the resource, but in general gives a specification of how a func- tion is named and structured. The example func- tion signatures in <ref type="figure" target="#fig_5">Figure 3</ref> all specify a function name, a list of arguments, and other optional in- formation such as a return value and a names- pace. Components in utility manuals are short ex- ecutable code sequences intended to show an ex- ample use of a utility. We assume typed code se- quences following <ref type="bibr" target="#b34">Richardson and Kuhn (2014)</ref>, where the constituent parts of the sequences are abstracted by type.</p><p>Given a set of example text-component pairs,</p><formula xml:id="formula_0">D = {(x i , z i )} n i=1</formula><p>, the goal is to learn how to gen- erate correct, well-formed components z ∈ C for each input x. Viewed as a semantic parsing prob- lem, this treats the target components as a kind of formal meaning representation, analogous to a logical form. In our experiments, we assume that the complete set of output components are known. In the API documentation sets, this is because each standard library contains a finite number of func- tion representations, roughly corresponding to the number of pairs as shown in <ref type="figure" target="#fig_5">Figure 3</ref>. For a given input, therefore, the goal is to find the best candi- date function translation within the space of the to- tal API components C ( <ref type="bibr" target="#b10">Deng and Chrupała, 2014)</ref>.</p><p>Given these constraints, our setup closely re- sembles that of <ref type="bibr" target="#b18">Kushman et al. (2014)</ref>, who learn to parse algebra word problems using a small set of equation templates. Their approach is inspired by template-based information extraction, where templates are recognized and instantiated by slot- filling. Our function signatures and code tem- plates have a similar slot-like structure, consisting of slots such as return value, arguments, function name and namespace.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Language Modeling Baselines</head><p>Existing approaches to semantic parsing formalize the mapping from language to logic using a va- riety of formalisms including <ref type="bibr">CFGs (Börschinger et al., 2011</ref>), CCGs ( <ref type="bibr" target="#b20">Kwiatkowski et al., 2010)</ref>, synchronous CFGs ( <ref type="bibr" target="#b40">Wong and Mooney, 2007b</ref>). Deciding to use one formalism over another is of- ten motivated by the complexities of the target rep- resentations being learned. For example, recent in- terest in learning graph-based representations such as those in the AMR bank ( <ref type="bibr" target="#b2">Banarescu et al., 2013)</ref> requires parsing models that can generate com- plex graph shaped derivations such as CCGs ( <ref type="bibr" target="#b1">Artzi et al., 2015</ref>) or HRGs ( <ref type="bibr" target="#b30">Peng et al., 2015)</ref>. Given the simplicity of our API representations, we opt for a simple semantic parsing model that exploits the finiteness of our target representations.</p><p>Following <ref type="bibr" target="#b10">((Deng and Chrupała, 2014)</ref>; hence- forth DC), we treat the problem of component translation as a language modeling problem <ref type="bibr" target="#b36">(Song and Croft, 1999</ref>). For a given query sequence or text x = w i , .., w I and component sequence z = u j , .., u J , the probability of the component given the query is defined as follows using Bayes' theorem: p(z|x) ∝ p(x|z)p(z).</p><p>By assuming a uniform prior over the proba- bility of each component p(z), the problem re- duces to computing p(x|z), which is where lan- guage modeling is used. Given each word w i in the query, a unigram model is defined as p(x|z) = ∏ I i=1 p(w i |z). Using this formulation, we can then define different models to estimate p(w|z).</p><p>Term Matching As a baseline for p(w|z), DC define a term matching approach that exploits the fact that many queries in our English datasets share vocabulary with target component vocabu- lary. A smoothed version of this baseline is de- fined below, where f (w|z) is the frequency of matching terms in the target signature, f (w|C) is frequency of the term word in the overall docu- mentation collection, and λ is a smoothing param- eter (for Jelinek-Mercer smoothing):</p><formula xml:id="formula_1">p(x|z) = ∏ w∈x (1 − λ)f (w|z) + λf (w|C)</formula><p>Translation Model In order to account for the co-occurrence between non-matching words and component terms, DC employ a word-based trans- lation model, which models the relation between natural language words w j and individual compo- nent terms u j . In this paper, we limit ourselves to sequence-based word alignment models <ref type="bibr" target="#b27">(Och and Ney, 2003)</ref>, which factor in the following manner:</p><formula xml:id="formula_2">p(x|z) = I ∏ i=1 J ∑ j=0 p t (w i |u j )p d (l(j)|i, I, J)</formula><p>Here each p t (w i |u j ) defines an (unsmoothed) multinomial distribution over a given component term u j for all words w j . The function p d is a dis- tortion parameter, and defines a dependency be- tween the alignment positions and the lengths of</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 1 Rank Decoder</head><p>Input: Query x, Components C of size m, rank k, model A, sort function K-BEST Output: Top k components ranked by A model score p 1: procedure RANKCOMPONENTS(x, C, k, A) 2:</p><formula xml:id="formula_3">SCORES ← [ ] ▷ Initialize score list 3:</formula><p>for each component c ∈ C do 4:</p><p>p ← ALIGNA(x, c) ▷ Score using A 5:</p><p>SCORES += (c, p) ▷ Add to list 6:</p><p>return K-Best(SCORES,k) ▷ k best components both input strings. This function, and the defi- nition of l(j), assumes different forms according to the particular alignment model being used. We consider three different types of alignment models each defined in the following way: We also define a new tree based alignment model (3) that takes into account the syntax asso- ciated with the function representations. Each l(j) is the relative tree position of the alignment point, shown as t(j), and tlen(J) is the length of the tree associated with z. This approach assumes a tree representation for each z. We generated these trees heuristically by preserving the information that is lost when components are converted to a linear se- quence representation. An example structure for PHP is shown in <ref type="figure" target="#fig_7">Figure 4</ref>, where the red solid line indicates the types of potential errors avoided by this model. Learning is done by applying the standard EM training procedure of <ref type="bibr" target="#b6">Brown et al. (1993)</ref>.</p><formula xml:id="formula_4">p d (l(j)|...) =    1 J+1 (1) a(j|i, I, J)<label>(2</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Ranking and Decoding</head><p>Algorithm 1 shows how to rank API components. For a text input x, we iterate through all known API components C and assign a score using a model A. We then rank the components by their scores using a K-BEST function. This method serves as a type of word-based decoding algorithm bool ZipArchive::deleteName(string $name) bool3 bool string $name2 name string deleteName1 name delete</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ZipArchive0</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ZipArchive</head><p>Delete entry in an archive using its name which is simplified by the finite nature of the tar- get language. The complexity of the scoring pro- cedure, lines 3-5, is linear over the number com- ponents m in C. In practice, we implement the K-BEST sorting function on line 6 as a binary in- sertion sort on line 5, resulting in an overall com- plexity of O(m log m). While iterating over m API components might not be feasible given more complicated formal lan- guages with recursion, a more clever decoding al- gorithm could be applied, e.g., one based on the lattice decoding approach of ( <ref type="bibr" target="#b13">Dyer et al., 2008</ref>). Since we are interested in providing initial base- line results, we leave this for future work.</p><formula xml:id="formula_5">X012 → ⟨ X 01 X 2 , X 01 X 2 bool ⟩ X01 → ⟨ X 1 in an X 0 , X 0 X 1 ⟩ X1 → ⟨ Delete X 1 , delete X 1 ⟩ X1 → ⟨ entry, name ⟩ X0 → ⟨ archive, ZipArchive ⟩ X2 → ⟨ using its X 2 , X 2 ⟩ X2 → ⟨ name, string $name ⟩</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Discriminative Approach</head><p>In this section, we introduce a new model that aims to improve on the previous baseline methods.</p><p>While the previous models are restricted to word-level information, we extend this approach by using a discriminative reranking model that captures phrase information to see if this leads to an improvement. This model can also capture document-level information from the APIs, such as the additional textual descriptions of param- eters, see also declarations or classes of related functions and syntax information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Modeling</head><p>Like in most semantic parsing approaches <ref type="bibr" target="#b42">(Zettlemoyer and Collins, 2009;</ref><ref type="bibr" target="#b21">Liang et al., 2011)</ref>, our model is defined as a conditional log-linear  model over components z ∈ C with parameters θ ∈ R b , and a set of feature functions ϕ(x, z): p( z| x; θ) ∝ e θ·ϕ(x,z) . Formally, our training objective is to maxi- mize the conditional log-likehood of the correct component output z for each input x:</p><formula xml:id="formula_6">O(θ) = ∑ n i=1 log p (z i | x i ; θ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Features</head><p>Our model uses word-level features, such as word match, word pairs, as well as information from the underlying aligner model such as Viterbi align- ment information and model score. Two ad- ditional categories of non-word features are de- scribed below. An illustration of the feature ex- traction procedure is shown in <ref type="figure" target="#fig_9">Figure 5</ref> 1 .</p><p>Phrases Features We extract phrase features (e.g., (hyper. cosine, cosh) in <ref type="figure" target="#fig_9">Figure 5</ref>) from ex- ample text component pairs by training symmetric word aligners and applying standard word-level heuristics ( <ref type="bibr" target="#b17">Koehn et al., 2003)</ref>. Additional fea- tures, such as phrase match/overlap, tree positions of phrases, are defined over the extracted phrases.</p><p>We also extract hierarchical phrases <ref type="bibr" target="#b8">(Chiang, 2007</ref>) using a variant of the SAMT method of <ref type="bibr" target="#b43">Zollmann and Venugopal (2006)</ref> and the compo- nent syntax trees. Example rules are shown in <ref type="figure" target="#fig_7">Fig- ure 4</ref>, where gaps (i.e., symbols in square brack- ets) are filled with smaller phrase-tree alignments.</p><p>Document Level Features Document features are of two categories. The first includes additional textual descriptions of parameters, return values, and modules. One class of features is whether certain words under consideration appear in the @param and @return descriptions of the tar- get components. For example, the arg token in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 Online Rank Learner</head><p>Input: <ref type="bibr">Dataset D, components C, iterations T , rank k, learn</ref> ing rate α, model A, ranker function RANK Output: Weight vector θ 1: procedure LEARNRERANKER(D, C, T, k, α, A, RANK) 2:</p><formula xml:id="formula_7">θ ← 0 ▷ Initialize 3:</formula><p>for t ∈ 1..T do 4:</p><p>for pairs (xi, zi) ∈ D do 5: S = RANK(xi, C, k, A) ▷ Scored candidates 6:</p><formula xml:id="formula_8">∆ = ϕ(xi, zi) − E s∈S∼p(s|x i ;θ) [ϕ(xi, s)] 7: θ = θ + α∆ ▷ Update online 8:</formula><p>return θ <ref type="figure" target="#fig_9">Figure 5</ref> appears in the textual description of the $arg parameter elsewhere in the documentation string.</p><p>Other features relate to general information about abstract symbol categories, as specified in see-also assertions, or hyper-link pointers. By exploiting this information, we extract general classes of functions, for example the set of hyper- bolic function (e.g., sinh, cosh, shown as c 4 in <ref type="figure" target="#fig_9">Figure 5</ref>), and associate these classes with words and phrases (e.g., hyperbolic and hyperbolic co- sine).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Learning</head><p>To optimize our objective, we use Algorithm 2. We estimate the model parameters θ using a K- best approximation of the standard stochastic gra- dient updates (lines 6-7), and a ranker function RANK. We note that while we use the ranker de- scribed in Algorithm 1, any suitable ranker or de- coding method could be used here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Setup</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Datasets</head><p>Source code documentation Our source code documentation collection consists of the standard library for nine programming languages, which are listed in <ref type="figure" target="#fig_5">Figure 3</ref>. We also use the translated version of the PHP collection for six additional languages, the details of which are shown in <ref type="figure">Fig- ure 6</ref>. The Java dataset was first used in DC, while we extracted all other datasets for this work.</p><p>The size of the different datasets are detailed in both figures. The number of pairs is the number of single sentences paired with function represen- tations, which constitutes the core part of these datasets. The number of descriptions is the num- ber of additional textual descriptions provided in the overall document, such as descriptions of pa- rameters or return values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dataset # Pairs</head><p>#Descr. Symbols Words Vocab. PHP f r <ref type="table" target="#tab_2">6,155  14,058 7,922  70,800 5,904  PHPes  5,823  13,285 7,571  69,882 5,790  PHPja  4,903  11,251 6,399  65,565 3,743  PHPru 2,549  6,030  3,340  23,105 4,599  PHPtr  1,822  4,414  2,725  16,033 3,553  PHP de  1,538  3,733  2,417</ref> 17,460 3,209</p><p>Figure 6: The non-English PHP datasets.</p><p>We also quantify the different datasets in terms of unique symbols in the target representations, shown as Symbols. All function representations and code sequences are linearized, and in some cases further tokenized, for example, by convert- ing out of camel case or removing underscores.</p><p>Man pages The collection of man pages is from <ref type="bibr" target="#b34">Richardson and Kuhn (2014)</ref> and includes 921 text-code pairs that span 330 Unix utilities and man pages. Using information from the synopsis and parameter declarations, the target code repre- sentations are abstracted by type. The extra de- scriptions are extracted from parameter descrip- tions, as shown in the DESCRIPTION section in <ref type="figure" target="#fig_0">Figure 1</ref>, as well as from the NAME sections of each manual.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Evaluation</head><p>For evaluation, we split our datasets into sepa- rate training, validation and test sets. For Java, we reserve 60% of the data for training and the remaining 40% for validation (20%) and testing (20%). For all other datasets, we use a 70%-30% split. From a retrieval perspective, these left out descriptions are meant to mimic unseen queries to our model. After training our models, we eval- uate on these held out sets by ranking all known components in each resource using Algorithm 1. A predicted component is counted as correct if it matches exactly a gold component.</p><p>Following DC, we report the accuracy of pre- dicting the correct representation at the first posi- tion in the ranked list (Accuracy @1) and within the top 10 positions (Accuracy @10). We also re- port the mean reciprocal rank MRR, or the multi- plicative inverse of the rank of the correct answer.</p><p>Baselines For comparison, we trained a bag-of- words classifier (the BoW Model in <ref type="table" target="#tab_2">Table 1</ref>). This model uses the occurrence of word-component symbol pairs as binary features, and aims to see if word co-occurrence alone is sufficient to for rank- ing representations.  Since our discriminative models use more data than the baseline models, which therefore make the results not directly comparable, we train a more comparable translation model, shown as M1 Descr. in <ref type="table" target="#tab_2">Table 1</ref>, by adding the additional textual data (i.e. parameter and return or module descrip- tions) to the models' parallel training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and Discussion</head><p>Test results are shown in <ref type="table" target="#tab_2">Table 1</ref>. Among the base- line models, IBM Model 1 outperforms virtually all other models and is in general a strong baseline. Of particular note is the poor performance of the higher-order translation models based on Model 2 and the Tree Model. While Model 2 is known to outperform Model 1 on more conventional trans- lation tasks <ref type="bibr" target="#b27">(Och and Ney, 2003</ref>), it appears that such improvements are not reflected in this type of semantic translation context.</p><p>The bag-of-words (BoW) and Term Match baselines are outperformed by all other models. This shows that translation in this context is more complicated than simple word matching. In some cases the term matching baseline is competitive with other models, suggesting that API collections differ in how language descriptions overlap with component names and naming conventions. It is clear, however, that this heuristic only works for English, as shown by results on the non-English PHP datasets in <ref type="table" target="#tab_2">Table 1</ref>.</p><p>We achieve improvements on many datasets by adding additional data to the translation model (M1 Descr.). We achieve further improvements on all datasets using the discriminative model (Reranker), with most increases in performance occurring at how the top ten items are ranked.</p><p>This last result suggests that phrase-level and document-level features can help to improve the overall ranking and translation, though in some cases the improvement is rather modest.</p><p>Despite the simplicity of our semantic parsing model and decoder, there is still much room for improvement, especially on achieving better Ac- curacy @1. While one might expect better results when moving from a word-based model to a model that exploits phrase and hierarchical phrase fea- tures, the sparsity of the component vocabulary is such that most phrase patterns in the training are not observed in the evaluation. In many bench- mark semantic parsing datasets, such sparsity is- sues do not occur ( <ref type="bibr" target="#b9">Cimiano and Minock, 2009)</ref>, suggesting that state-of-the-art methods will have similar problems when applied to our datasets.</p><p>Recent approaches to open-domain semantic parsing have dealt with this problem by using paraphrasing techniques <ref type="bibr" target="#b4">(Berant and Liang, 2014)</ref> or distant supervision ( <ref type="bibr" target="#b33">Reddy et al., 2014</ref>). We expect that these methods can be used to improve our models and results, especially given the wide availability of technical documentation, for exam- ple, distributed within the Opus project <ref type="bibr" target="#b37">(Tiedemann, 2012</ref>).</p><p>Model Errors We performed analysis on some of the incorrect predictions made by our mod- els. For some documentation sets, such as those in the GNU documentation collection 2 , informa- tion is organized into a small and concrete set of categories/chapters, each corresponding to vari- ous features or modules in the language and re- lated functions. Given this information, <ref type="figure">Figure</ref>   7 shows the confusion between predicting differ- ent categories of functions, where the rows show the categories of functions to be predicted and the columns show the different categories predicted. We built these plots by finding the categories of the top 50 non-gold (or erroneous) representations generated for each validation example.</p><p>The step-like lines through the diagonal of both plots show that alternative predictions (shaded ac- cording to occurrence) are often of the same cat- egory, most strikingly for the corner categories. This trend seems stable across other datasets, even among datasets with large numbers of categories. Interestingly, many confusions appear to be be- tween related categories. For example, when making predictions about Strings functions in Scheme, the model often generates function re- lated to BitStrings, Characters and IO. Again, this trend seems to hold for other documen- tation sets, suggesting that the models are often making semantically sensible decisions.</p><p>Looking at errors in other datasets, one com- mon error involves generating functions with the same name and/or functionality. In large libraries, different modules sometimes implement that same core functions, such the genericpath or posixpath modules in Python. When generat- ing a representation for the text return size of file, our model confuses the getsize(filename) function in one module with others. Similarly, other subtle distinctions that are not explicitly ex- pressed in the text descriptions are not captured, such as the distinction in Haskell between safe and unsafe bit shifting functions.</p><p>While many of these predictions might be cor- rect, our evaluation fails to take into account these various equivalences, which is an issue that should be investigated in future work. Future work will also look systematically at the effect that types (i.e., in statically typed versus dynamic languages) have on prediction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Future Work</head><p>We see two possible use cases for this data. First, for benchmarking semantic parsing models on the task of semantic translation. While there has been a trend towards learning executable seman- tic parsers <ref type="bibr" target="#b3">(Berant et al., 2013;</ref><ref type="bibr" target="#b22">Liang, 2016)</ref>, there has also been renewed interest in supervised learn- ing of formal representations in the context of neu- ral semantic parsing models <ref type="bibr" target="#b12">(Dong and Lapata, 2016;</ref><ref type="bibr" target="#b16">Jia and Liang, 2016)</ref>. We believe that good performance on our datasets should lead to better performance on more conventional semantic pars- ing tasks, and raise new challenges involving spar- sity and multilingual learning.</p><p>We also see these resources as useful for in- vestigations into natural language programming. While our experiments look at learning rudimen- tary translational correspondences between text and code, a next step might be learning to syn- thesize executable programs via these translations, along the lines of <ref type="bibr" target="#b11">(Desai et al., 2016;</ref><ref type="bibr" target="#b32">Raza et al., 2015)</ref>. Other document-level features, such as ex- ample input-output pairs, unit tests, might be use- ful in this endeavor.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Example source code documentation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>NAME : dappprof profile user and lib function usage. SYNOPSIS dappprof [-ac] -p PID | command DESCRIPTION -p PID examine the PID ... EXAMPLES Print elapsed time for PID 1871 dappprof -p PID=1871 SEE ALSO: dapptrace(1M), dtrace(1M), ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: An example computer utility manual in the Unix domain. Descriptions of example uses are shown in red.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Description of our English corpus collection with example text/function pairs.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>) a(t(j)|i, I, tlen(J)) (3) Models (1-2) are the classic IBM word-alignment models of Brown et al. (1993). IBM Model 1, for example, assumes a uniform distribution over all positions, and is the main model investi- gated in DC. For comparison, we also experiment with IBM Model 2, where each l(j) refers to the string position of j in the component input, and a(..) defines a multinomial distribution such that ∑ J j=0 a(j|i, I, J) = 1.0.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An example tree structure (above) associated with an input component. Below are Hiero rules (Chiang, 2007) extracted from the alignment and tree information.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>Pairs/Alignments: (hyperbolic, cosh) = 1, (cosine, cosh) = 1, ... Phrases: (hyperbolic cosine, cosh) = 1, (of arg, float $arg) = ... See also: (hyperbolic, c 4 = {cos,..}) = 1, (arg, c 4 ) = 1, ... In Descr.: (arg, , $arg) = 1, (arg , float) = 0, ... Trees/Matches (hyperbolic, cosh, NAME NODE) = 1, number of matches= ...</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Example features used by our rerankers.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Function predictions by documentation category for Scheme (left) and Elisp (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 1 : Test results according to the table below.</head><label>1</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1"> A more complete description of features is included as supplementary material, along with all source code.</note>

			<note place="foot" n="2"> https://www.gnu.org/doc/doc.en.html</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was funded by the Deutsche Forschungsgemeinschaft (DFG) via SFB 732, project D2. Thanks also to our IMS colleagues, in particular Christian Scheible, for providing feedback on earlier drafts, as well as to Jonathan Berant for helpful discussions.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Bimodal modelling of source code and natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miltiadis</forename><surname>Allamanis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Tarlow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Andrew D Gordon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wei</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 32th International Conference on Machine Learning</title>
		<meeting>the 32th International Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="volume">951</biblScope>
			<biblScope unit="page">2015</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Broad-coverage CCG semantic parsing with AMR</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenton</forename><surname>Lee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1699" to="1710" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Abstract meaning representation for sembanking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Banarescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Bonial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madalina</forename><surname>Georgescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kira</forename><surname>Griffitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martha</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Linguistic Annotation Workshop and Interoperability with Discourse</title>
		<meeting>the 7th Linguistic Annotation Workshop and Interoperability with Discourse</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Semantic parsing on Freebase from question-answer pairs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Chou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roy</forename><surname>Frostig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP-2013</title>
		<meeting>EMNLP-2013</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="1533" to="1544" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Semantic parsing via paraphrasing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL2014</title>
		<meeting>ACL2014</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1415" to="1425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reducing grounded learning tasks to grammatical inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Benjamin</forename><surname>Börschinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bevan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP2011</title>
		<meeting>EMNLP2011</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1416" to="1425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The mathematics of statistical machine translation: Parameter estimation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vincent J Della</forename><surname>Peter F Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen A Della</forename><surname>Pietra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert L</forename><surname>Pietra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mercer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational linguistics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="263" to="311" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning to sportscast: A test of grounded language acquisition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ICML-2008</title>
		<meeting>ICML-2008</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="128" to="135" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Hierarchical phrase-based translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">computational linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="201" to="228" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Natural language interfaces: what is the problem?-a datadriven quantitative analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Cimiano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Minock</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Application of Natural Language to Information Systems</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="192" to="206" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Semantic approaches to software component retrieval with English queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huijing</forename><surname>Deng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Grzegorz</forename><surname>Chrupała</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LREC-14</title>
		<meeting>LREC-14</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="441" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Program synthesis using natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aditya</forename><surname>Desai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Vineet</forename><surname>Hingorani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nidhi</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amey</forename><surname>Karkare</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Marron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhajit</forename><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th International Conference on Software Engineering</title>
		<meeting>the 38th International Conference on Software Engineering</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2016" />
			<biblScope unit="page" from="345" to="356" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Language to logical form with neural attention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1601.01280</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Generalizing word lattice translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Smaranda</forename><surname>Muresan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Resnik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL-08</title>
		<meeting>ACL-08</meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page">1012</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaodong</forename><surname>Gu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongmei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sunghun</forename><surname>Kim</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1605.08535</idno>
		<title level="m">Deep API Learning</title>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Summarizing source code using a neural attention model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivasan</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ioannis</forename><surname>Kostas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL2016</title>
		<meeting>ACL2016</meeting>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Data recombination for neural semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robin</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1606.03622</idno>
		<imprint>
			<date type="published" when="2016" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Statistical phrase-based translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Franz</forename><forename type="middle">Josef</forename><surname>Och</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Marcu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the NACL-2003</title>
		<meeting>the NACL-2003</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="48" to="54" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Learning to automatically solve algebra word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL-2014</title>
		<meeting>ACL-2014</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="271" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using semantic unification to generate regular expressions from natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NAACL2013</title>
		<meeting>NAACL2013</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Inducing probabilistic CCG grammars from logical form with higherorder unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharon</forename><surname>Goldwater</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP-2010</title>
		<meeting>EMNLP-2010</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1223" to="1233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Learning dependency-based compositional semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL-11</title>
		<meeting>ACL-11</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="590" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Learning executable semantic parsers for natural language understanding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">59</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="68" to="76" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fei</forename><surname>Lv</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hongyu</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian-Guang</forename><surname>Lou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shaowei</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongmei</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianjun</forename><surname>Zhao</surname></persName>
		</author>
		<title level="m">Codehow: Effective code search based on api understanding and extended boolean model (e)</title>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
				<title level="m">30th IEEE/ACM International Conference on. IEEE</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="260" to="270" />
		</imprint>
	</monogr>
	<note>Automated Software Engineering (ASE)</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Integrating programming by example and natural language programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Mehdi Hafezi Manshadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James F</forename><surname>Gildea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Allen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI-2013</title>
		<meeting>AAAI-2013</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Learning to parse natural language commands to a robot control system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Cynthia</forename><surname>Matuszek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evan</forename><surname>Herbst</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dieter</forename><surname>Fox</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the International Symposium on Experimental Robotics (ISER)</title>
		<meeting>the International Symposium on Experimental Robotics (ISER)</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A systematic comparison of various statistical alignment models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josef</forename><surname>Franz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hermann</forename><surname>Och</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational linguistics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="19" to="51" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Learning to generate pseudo-code from source code using statistical machine translation (t)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Oda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hiroyuki</forename><surname>Fudaba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hideaki</forename><surname>Hata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sakriani</forename><surname>Sakti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomoki</forename><surname>Toda</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Satoshi</forename><surname>Nakamura</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">30th IEEE/ACM International Conference on. IEEE</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="574" to="584" />
		</imprint>
	</monogr>
	<note>Automated Software Engineering (ASE)</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Compositional semantic parsing on semi-structured tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Panupong</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL-2015</title>
		<meeting>ACL-2015</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">A Synchronous Hyperedge Replacement Grammar based approach for AMR parsing. Proceedings of CoNLL-2015 page 32</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaochang</forename><surname>Peng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Linfeng</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Gildea</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Language to code: Learning semantic parsers for if-this-then-that recipes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Quirk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Raymond</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michel</forename><surname>Mooney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Galley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL2015</title>
		<meeting>ACL2015</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="878" to="888" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Compositional program synthesis from natural language and examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><surname>Raza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natasa</forename><surname>Milicfrayling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCAI</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="792" to="800" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Large-scale semantic parsing without questionanswer pairs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siva</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="377" to="392" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">UnixMan corpus: A resource for language learning in the Unix domain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyle</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of LREC-2014</title>
		<meeting>LREC-2014</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Learning to make inferences in a semantic parsing task</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyle</forename><surname>Richardson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="155" to="168" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A general language model for information retrieval</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Croft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings International Conference on Information and Knowledge Management</title>
		<meeting>International Conference on Information and Knowledge Management</meeting>
		<imprint>
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Parallel data, tools and interfaces in opus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jörg</forename><surname>Tiedemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LREC</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">2012</biblScope>
			<biblScope unit="page" from="2214" to="2218" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Learning for semantic parsing with statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuk</forename><forename type="middle">Wah</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HLT-NAACL-2006</title>
		<meeting>HLT-NAACL-2006</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="439" to="446" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Generation by inverting a semantic parser that uses statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuk</forename><forename type="middle">Wah</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HLTNAACL-2007</title>
		<meeting>HLTNAACL-2007</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="172" to="179" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Learning synchronous grammars for semantic parsing with lambda calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuk</forename><forename type="middle">Wah</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL2007</title>
		<meeting>ACL2007<address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Learning to parse database queries using inductive logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond J</forename><surname>Zelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of AAAI-1996</title>
		<meeting>AAAI-1996</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="1050" to="1055" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Learning context-dependent mappings from sentences to logical form</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL-2009</title>
		<meeting>ACL-2009</meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="976" to="984" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">Syntax augmented machine translation via chart parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Zollmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Venugopal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Workshop on Statistical Machine Translation</title>
		<meeting>the Workshop on Statistical Machine Translation</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="138" to="141" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
