<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T10:37+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Shift-Reduce CCG Parsing with a Dependency Model</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>June 23-25 2014. 2014</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wenduan</forename><surname>Xu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Laboratory</orgName>
								<orgName type="institution" key="instit1">University of Cambridge Computer Laboratory</orgName>
								<orgName type="institution" key="instit2">University of Cambridge</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Computer Laboratory</orgName>
								<orgName type="institution" key="instit1">University of Cambridge Computer Laboratory</orgName>
								<orgName type="institution" key="instit2">University of Cambridge</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
							<email>yue zhang@sutd.edu.sg</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Laboratory</orgName>
								<orgName type="institution" key="instit1">University of Cambridge Computer Laboratory</orgName>
								<orgName type="institution" key="instit2">University of Cambridge</orgName>
								<address>
									<country key="SG">Singapore</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Shift-Reduce CCG Parsing with a Dependency Model</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics</title>
						<meeting>the 52nd Annual Meeting of the Association for Computational Linguistics <address><addrLine>Baltimore, Maryland, USA</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="218" to="227"/>
							<date type="published">June 23-25 2014. 2014</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents the first dependency model for a shift-reduce CCG parser. Modelling dependencies is desirable for a number of reasons, including handling the &quot;spurious&quot; ambiguity of CCG; fitting well with the theory of CCG; and optimizing for structures which are evaluated at test time. We develop a novel training technique using a dependency oracle, in which all derivations are hidden. A challenge arises from the fact that the oracle needs to keep track of exponentially many gold-standard derivations, which is solved by integrating a packed parse forest with the beam-search decoder. Standard CCGBank tests show the model achieves up to 1.05 labeled F-score improvements over three existing, competitive CCG parsing models.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Combinatory Categorial Grammar (CCG; <ref type="bibr" target="#b24">Steedman (2000)</ref>) is able to derive typed dependency structures <ref type="bibr" target="#b14">(Hockenmaier, 2003;</ref><ref type="bibr" target="#b3">Clark and Curran, 2007)</ref>, providing a useful approximation to the un- derlying predicate-argument relations of "who did what to whom". To date, CCG remains the most competitive formalism for recovering "deep" de- pendencies arising from many linguistic phenom- ena such as raising, control, extraction and coordi- nation ( <ref type="bibr" target="#b22">Rimell et al., 2009;</ref><ref type="bibr" target="#b21">Nivre et al., 2010)</ref>.</p><p>To achieve its expressiveness, CCG exhibits so-called "spurious" ambiguity, permitting many non-standard surface derivations which ease the recovery of certain dependencies, especially those arising from type-raising and composition. But this raises the question of what is the most suit- able model for CCG: should we model the deriva- tions, the dependencies, or both? The choice for some existing parsers <ref type="bibr" target="#b14">(Hockenmaier, 2003;</ref><ref type="bibr" target="#b3">Clark and Curran, 2007</ref>) is to model derivations directly, restricting the gold-standard to be the normal-form derivations <ref type="bibr" target="#b8">(Eisner, 1996)</ref> from CCGBank <ref type="bibr" target="#b13">(Hockenmaier and Steedman, 2007)</ref>.</p><p>Modelling dependencies, as a proxy for the se- mantic interpretation, fits well with the theory of CCG, in which <ref type="bibr" target="#b24">Steedman (2000)</ref> argues that the derivation is merely a "trace" of the underlying syntactic process, and that the structure which is built, and predicated over when applying con- straints on grammaticality, is the semantic inter- pretation. The early dependency model of , in which model features were defined over only dependency structures, was partly moti- vated by these theoretical observations. More generally, dependency models are desir- able for a number of reasons. First, modelling dependencies provides an elegant solution to the spurious ambiguity problem <ref type="bibr" target="#b3">(Clark and Curran, 2007)</ref>. Second, obtaining training data for de- pendencies is likely to be easier than for syn- tactic derivations, especially for incomplete data ( <ref type="bibr" target="#b23">Schneider et al., 2013)</ref>. <ref type="bibr" target="#b2">Clark and Curran (2006)</ref> show how the dependency model from <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> extends naturally to the partial- training case, and also how to obtain dependency data cheaply from gold-standard lexical category sequences alone. And third, it has been argued that dependencies are an ideal representation for parser evaluation, especially for CCG <ref type="bibr" target="#b1">(Briscoe and Carroll, 2006;</ref>), and so optimizing for dependency recovery makes sense from an evaluation perspective.</p><p>In this paper, we fill a gap in the literature by developing the first dependency model for a shift- reduce CCG parser. Shift-reduce parsing applies naturally to <ref type="bibr">CCG (Zhang and Clark, 2011)</ref>, and the left-to-right, incremental nature of the decoding fits with CCG's cognitive claims. The discrimina- tive model is global and trained with the structured perceptron. The decoder is based on beam-search <ref type="bibr" target="#b27">(Zhang and Clark, 2008)</ref> with the advantage of linear-time decoding <ref type="bibr" target="#b12">(Goldberg et al., 2013)</ref>.</p><p>A main contribution of the paper is a novel tech- nique for training the parser using a dependency oracle, in which all derivations are hidden. A challenge arises from the potentially exponential number of derivations leading to a gold-standard dependency structure, which the oracle needs to keep track of. Our solution is an integration of a packed parse forest, which efficiently stores all the derivations, with the beam-search decoder at training time. The derivations are not explicitly part of the data, since the forest is built from the gold-standard dependencies. We also show how perceptron learning with beam-search ( <ref type="bibr" target="#b6">Collins and Roark, 2004</ref>) can be extended to handle the ad- ditional ambiguity, by adapting the "violation- fixing" perceptron of <ref type="bibr" target="#b17">Huang et al. (2012)</ref>.</p><p>Results on the standard CCGBank tests show that our parser achieves absolute labeled F-score gains of up to 0.5 over the shift-reduce parser of <ref type="bibr" target="#b28">Zhang and Clark (2011)</ref>; and up to 1.05 and 0.64 over the normal-form and hybrid models of <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Shift-Reduce with Beam-Search</head><p>This section describes how shift-reduce tech- niques can be applied to CCG, following <ref type="bibr" target="#b28">Zhang and Clark (2011)</ref>. First we describe the determin- istic process which a parser would follow when tracing out a single, correct derivation; then we describe how a model of normal-form derivations -or, more accurately, a sequence of shift-reduce actions leading to a normal-form derivation - can be used with beam-search to develop a non- deterministic parser which selects the highest scor- ing sequence of actions. Note this section only de- scribes a normal-form derivation model for shift- reduce parsing. Section 3 explains how we extend the approach to dependency models.</p><p>The shift-reduce algorithm adapted to CCG is similar to that of shift-reduce dependency parsing ( <ref type="bibr" target="#b25">Yamada and Matsumoto, 2003;</ref><ref type="bibr" target="#b19">Nivre and McDonald, 2008;</ref><ref type="bibr" target="#b27">Zhang and Clark, 2008;</ref><ref type="bibr" target="#b16">Huang and Sagae, 2010)</ref>. Following Zhang and Clark (2011), we define each item in the parser as a pair s, q, where q is a queue of remaining input, consisting of words and a set of possible lexical categories for each word (with q 0 being the front word), and s is the stack that holds subtrees s 0 , s 1 , ... (with s 0 at the top). Subtrees on the stack are partial deriva- <ref type="figure">Figure 1</ref>: Deterministic example of shift-reduce CCG parsing (lexical categories omitted on queue).</p><formula xml:id="formula_0">step stack (sn, ..., s 1 , s 0 ) queue (q 0 , q 1 , ..., qm) action 0 Mr. President visited Paris 1 N /N President visited Paris SHIFT 2 N /N N visited Paris SHIFT 3 N visited Paris REDUCE 4 NP visited Paris UNARY 5 NP (S [dcl]\NP)/NP Paris SHIFT 6 NP (S [dcl]\NP)/NP N SHIFT 7 NP (S [dcl]\NP)/NP NP UNARY 8 NP S [dcl]\NP REDUCE 9 S [dcl] REDUCE</formula><p>tions that have been built as part of the shift-reduce process. SHIFT, REDUCE and UNARY are the three types of actions that can be applied to an item. A SHIFT action shifts one of the lexical categories of q 0 onto the stack. A REDUCE action combines s 0 and s 1 according to a CCG combinatory rule, producing a new category on the top of the stack. A UNARY action applies either a type-raising or type-changing rule to the stack-top category s 0 . 1 <ref type="figure">Figure 1</ref> shows a deterministic example for the sentence Mr. President visited Paris, giving a sin- gle sequence of shift-reduce actions which pro- duces a correct derivation (i.e. one producing the correct set of dependencies). Starting with the ini- tial item s, q 0 (row 0), which has an empty stack and a full queue, a total of nine actions are applied to produce the complete derivation.</p><p>Applying beam-search to a statistical shift- reduce parser is a straightforward extension to the deterministic example. At each step, a beam is used to store the top-k highest-scoring items, re- sulting from expanding all items in the previous beam. An item becomes a candidate output once it has an empty queue, and the parser keeps track of the highest scored candidate output and returns the best one as the final output. Compared with greedy local-search ( <ref type="bibr" target="#b20">Nivre and Scholz, 2004)</ref>, the use of a beam allows the parser to explore a larger search space and delay difficult ambiguity-resolving de- cisions by considering multiple items in parallel.</p><p>We refer to the shift-reduce model of <ref type="bibr" target="#b28">Zhang and Clark (2011)</ref> as the normal-form model, where the oracle for each sentence specifies a unique se- quence of gold-standard actions which produces the corresponding normal-form derivation. No de- pendency structures are involved at training and test time, except for evaluation. In the next sec- tion, we describe a dependency oracle which con- siders all sequences of actions producing a gold- standard dependency structure to be correct.</p><formula xml:id="formula_1">visited Paris N /N N (S [dcl ]\NP )/NP NP &gt; &gt; N S [dcl ]\NP &gt;TC NP &lt; S [dcl ] (a) Mr. President visited Paris N /N N (S [dcl ]\NP )/NP NP &gt; N &gt;TC NP &gt;T S [dcl ]/(S [dcl ]\NP ) &gt;B S [dcl ]/NP &gt; S [dcl ] (b)</formula><p>Figure 2: Two derivations leading to the same dependency structure. TC denotes type-changing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Dependency Model</head><p>Categories in CCG are either basic (such as NP and PP ) or complex (such as (S [dcl ]\NP )/NP ). Each complex category in the lexicon defines one or more predicate-argument relations, which can be realized as a predicate-argument dependency when the corresponding argument slot is con- sumed. For example, the transitive verb category above defines two relations: one for the subject NP and one for the object NP . In this paper a CCG predicate-argument dependency is a 4-tuple: h f , f, s, h a where h f is the lexical item of the lexical category expressing the relation; f is the lexical category; s is the argument slot; and h a is the head word of the argument. Since the lexical items in a dependency are indexed by their sen- tence positions, all dependencies for a sentence form a set, which is referred to as a CCG depen- dency structure. <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> contains a detailed description of dependency structures. <ref type="figure">Fig. 2</ref> shows an example demonstrating spu- rious ambiguity in relation to a CCG depen- dency structure. In both derivations, the first two lexical categories are combined using for- ward application (&gt;) and the following depen- dency is realized: Mr., N /N1 , 1, President. In the normal-form derivation (a), the dependency visited, (S \NP1 )/NP2 , 2, Paris is created by com- bining the transitive verb category with the ob- ject NP using forward application. One final de- pendency, visited, (S \NP1 )/NP2 , 1, President, is re- alized when the root node S [dcl ] is produced through backward application (&lt;). <ref type="figure">Fig. 2</ref>(b) shows a non-normal-form derivation which uses type-raising (T) and composition (B) (which are not required to derive the correct de- pendency structure). In this alternative derivation, the dependency visited, (S \NP1 )/NP2 , 1, President is realized using forward composition (B), and visited, (S \NP1 )/NP2 , 2, Paris is realized when the</p><formula xml:id="formula_2">S [dcl ] root is produced.</formula><p>The chart-based dependency model of <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> treats all derivations as hid- den, and defines a probabilistic model for a de- pendency structure by summing probabilities of all derivations leading to a particular structure. Features are defined over both derivations and CCG predicate-argument dependencies. We fol- low a similar approach, but rather than define a probabilistic model (which requires summing), we define a linear model over sequences of shift- reduce actions, as for the normal-form shift-reduce model. However, the difference compared to the normal-form model is that we do not assume a sin- gle gold-standard sequence of actions.</p><p>Similar to Goldberg and Nivre (2012), we de- fine an oracle which determines, for a gold- standard dependency structure, G, what the valid transition sequences are (i.e. those sequences cor- responding to derivations leading to G). More specifically, the oracle can determine, given G and an item s, q, what the valid actions are for that item (i.e. what actions can potentially lead to G, starting with s, q and the dependencies already built on s). However, there can be exponentially many valid action sequences for G, which we rep- resent efficiently using a packed parse forest. We show how the forest can be used, during beam- search decoding, to determine the valid actions for a parse item (Section 3.2). We also show, in Section 3.3, how perceptron training with early- update ( <ref type="bibr" target="#b6">Collins and Roark, 2004</ref>) can be used in this setting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The Oracle Forest</head><p>A CCG parse forest efficiently represents an exponential number of derivations. Following <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> (which builds on <ref type="bibr" target="#b18">Miyao and Tsujii (2002)</ref>), and using the same nota- tion, we define a CCG parse forest Φ as a tuple C, D, R, γ, δ, where C is a set of conjunctive <ref type="bibr">Algorithm 1 (Clark and Curran, 2007)</ref> Input: A packed forest C, D, R, γ, δ, with dmax(c) and dmax(d) already computed 1: function MAIN 2: for each dr ∈ R s.t. dmax . (dr) = |G| do 3: MARK(dr) 4: procedure MARK(d) 5: mark d as a correct node 6: for each c ∈ γ(d) do</p><formula xml:id="formula_3">7: if dmax(c) == dmax(d) then 8:</formula><p>mark c as a correct node 9:</p><p>for each d ∈ δ(c) do 10:</p><p>if d has not been visited then 11:</p><p>MARK <ref type="formula">(d )</ref> nodes and D is a set of disjunctive nodes. <ref type="bibr">2</ref> Con- junctive nodes are individual CCG categories in Φ, and are either obtained from the lexicon, or by combining two disjunctive nodes using a CCG rule, or by applying a unary rule to a disjunctive node. Disjunctive nodes are equivalence classes of con- junctive nodes. Two conjunctive nodes are equiv- alent iff they have the same category, head and un- filled dependencies (i.e. they will lead to the same derivation, and produce the same dependencies, in any future parsing). R ⊆ D is a set of root dis- junctive nodes. γ : D → 2 C is the conjunctive child function and δ : C → 2 D is the disjunctive child function. The former returns the set of all conjunctive nodes of a disjunctive node, and the latter returns the disjunctive child nodes of a con- junctive node.</p><p>The dependency model requires all the conjunc- tive and disjunctive nodes of Φ that are part of the derivations leading to a gold-standard dependency structure G. We refer to such derivations as cor- rect derivations and the packed forest containing all these derivations as the oracle forest, denoted as Φ G , which is a subset of Φ. It is prohibitive to enumerate all correct derivations, but it is possible to identify, from Φ, all the conjunctive and dis- junctive nodes that are part of Φ G . <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> gives an algorithm for doing so, which we use here. The main intuition behind the algo- rithm is that a gold-standard dependency structure decomposes over derivations; thus gold-standard dependencies realized at conjunctive nodes can be counted when Φ is built, and all nodes that are part of Φ G can then be marked out of Φ by traversing it top-down. A key idea in understanding the algo-rithm is that dependencies are created when dis- junctive nodes are combined, and hence are asso- ciated with, or "live on", conjunctive nodes in the forest.</p><p>Following <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>, we also define the following three values, where the first decomposes only over local rule productions, while the other two decompose over derivations:</p><formula xml:id="formula_4">cdeps(c) = * if ∃ τ ∈ deps(c), τ / ∈ G |deps(c)| otherwise dmax(c) =      * if cdeps(c) == * * if dmax(d) == * for some d ∈ δ(c) d∈δ(c) dmax(d) + cdeps(c) otherwise dmax(d) = max{dmax(c) | c ∈ γ(d)} deps(c)</formula><p>is the set of all dependencies on con- junctive node c, and cdeps(c) counts the number of correct dependencies on c. dmax(c) is the max- imum number of correct dependencies over any sub-derivation headed by c and is calculated re- cursively; dmax(d) returns the same value for a disjunctive node. In all cases, a special value * indicates the presence of incorrect dependencies. To obtain the oracle forest, we first pre-compute dmax(c) and dmax(d) for all d and c in Φ when Φ is built using CKY, which are then used by Algo- rithm 1 to identify all the conjunctive and disjunc- tive nodes in Φ G .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The Dependency Oracle Algorithm</head><p>We observe that the canonical shift-reduce algo- rithm (as demonstrated in <ref type="figure">Fig. 1</ref>) applied to a sin- gle parse tree exactly resembles bottom-up post- order traversal of that tree. As an example, con- sider the derivation in <ref type="figure">Fig. 2a</ref>, where the corre- sponding sequence of actions is:</p><formula xml:id="formula_5">sh N /N , sh N , re N , un NP , sh (S [dcl ]\NP )/NP , sh NP , re S [dcl ]\NP , re S [dcl ]</formula><p>. <ref type="bibr">3</ref> The order of traversal is left-child, right-child and parent. For a single parse, the corresponding shift-reduce action se- quence is unique, and for a given item this canoni- cal order restricts the possible derivations that can be formed using further actions. We now extend this observation to the more general case of an oracle forest, where there may be more than one gold-standard action for a given item.</p><formula xml:id="formula_6">Definition 1. Given a gold-standard dependency visited Paris N /N N (S [dcl ]\NP )/NP NP &gt; &gt; N S[dcl]\NP (a) Mr. President visited Paris N/N N (S [dcl ]\NP )/NP NP &gt; S[dcl]\NP (b)</formula><p>Figure 3: Example subtrees on two stacks, with two subtrees in (a) and three in (b); roots of subtrees are in bold.</p><p>structure G, an oracle forest Φ G , and an item s, q, we say s is a realization of G, denoted s G, if |s| = 1, q is empty and the single deriva- tion on s is correct. If |s| &gt; 0 and the subtrees on s can lead to a correct derivation in Φ G using fur- ther actions, we say s is a partial-realization of G, denoted as s ∼ G. And we define s ∼ G for |s| = 0.</p><p>As an example, assume that Φ G contains only the derivation in <ref type="figure">Fig. 2a</ref>; then a stack containing the two subtrees in <ref type="figure">Fig. 3a</ref> is a partial-realization, while a stack containing the three subtrees in <ref type="figure">Fig. 3b</ref> is not. Note that each of the three sub- trees in <ref type="figure">Fig. 3b</ref> is present in Φ G ; however, these subtrees cannot be combined into the single cor- rect derivation, since the correct sequence of shift- reduce actions must first combine the lexical cat- egories for Mr. and President before shifting the lexical category for visited.</p><p>We denote an action as a pair (x, c), where x ∈ {SHIFT, REDUCE, UNARY} and c is the root of the subtree resulting from that action. For all three types of actions, c also corresponds to a unique conjunctive node in the complete forest Φ; and we use c s i to denote the conjunctive node in Φ corresponding to subtree s i on the stack. Let s , q = s, q • (x, c) be the resulting item from applying the action (x, c) to s, q; and let the set of all possible actions for s, q be X s,q = {(x, c) | (x, c) is applicable to s, q}.</p><note type="other">Definition 2. Given Φ G and an item s, q s.t. s ∼ G, we say an applicable action (x, c) for the item is valid iff s ∼ G or s G, where s , q = s, q • (x, c).</note><p>Definition 3. Given Φ G , the dependency oracle function f d is defined as:</p><formula xml:id="formula_7">f d (s, q, (x, c), Φ G ) = true if s ∼ G or s G false otherwise</formula><p>where (x, c) ∈ X s,q and s , q = s, q • (x, c).</p><p>The pseudocode in Algorithm 2 implements f d . It determines, for a given item, whether an appli- cable action is valid in Φ G .</p><p>It is trivial to determine the validity of a SHIFT action for the initial item, s, q 0 , since the SHIFT action is valid iff its category matches the gold- standard lexical category of the first word in the sentence. For any subsequent SHIFT action (SHIFT, c) to be valid, the necessary condition is c ≡ c lex 0 , where c lex 0 denotes the gold-standard lexical category of the front word in the queue, q 0 (line 3). However, this condition is not sufficient; a counterexample is the case where all the gold- standard lexical categories for the sentence in <ref type="figure">Fig- ure 2</ref> are shifted in succession. Hence, in general, the conditions under which an action is valid are more complex than the trivial case above.</p><p>First, suppose there is only one correct deriva- tion in Φ G . A SHIFT action (SHIFT, c lex 0 ) is valid whenever c s 0 (the conjunctive node in Φ G cor- responding to the subtree s 0 on the stack) and c lex 0 (the conjunctive node in Φ G corresponding to the next gold-standard lexical category from the queue) are both dominated by the conjunctive node parent p of c s 0 in Φ G . <ref type="bibr">4</ref>  Definition 5. The ancestor set A(c) of conjunc- tive node c ∈ Φ G is the set of all reachable ances- tor conjunctive nodes of c in Φ G .</p><p>Definition 6. Given an item s, q, if |s| = 1 we say s is a frontier stack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2 The Dependency Oracle Function f d</head><p>Input: ΦG, an item s, q s.t. s ∼ G, (x, c) ∈ X s,q Let s be the stack of s , q = s, q • (x, c) 1: function MAIN(s, q, (x, c), ΦG) 2: if x is SHIFT then 3:</p><p>if c ≡ c lex 0 then c not gold lexical category 4: return false 5:</p><p>else if c ≡ c lex 0 and |s| = 0 then the initial item 6: return true 7:</p><p>else if c ≡ c lex 0 and |s| = 0 then 8:</p><p>compute R(c s 1 , c s 0 ) 9:</p><p>return R(c s 1 , c s 0 ) = ∅ 10: if x is REDUCE then s is non-frontier 11:</p><p>if c ∈ R(cs 1 , cs 0 ) then 12:</p><p>compute if |s| = 1 and c ∈ ΦG then s is non-frontier 19:</p><p>compute</p><formula xml:id="formula_8">R(c s 1 , c s 0 ) 20: return R(c s 1 , c s 0 ) = ∅</formula><p>A key to defining the dependency oracle func- tion is the notion of a shared ancestor set. In- tuitively, shared ancestor sets are built up through shift actions, and contain sets of nodes which can potentially become the results of reduce or unary actions. A further intuition is that shared ances- tor sets define the space of possible correct deriva- tions, and nodes in these sets are "ticked off" when reduce and unary actions are applied, as a single correct derivation is built through the shift-reduce process (corresponding to a bottom-up post-order traversal of the derivation). The following defi- nition shows how the dependency oracle function builds shared ancestor sets for each action type. • R(, c 0 s 0 ) = ∅ where c 0 s 0 is the conjunctive node cor- responding to the gold-standard lexical category of the first word in the sentence ( is a dummy symbol indi- cating the bottom of stack).</p><p>The base case for Definition 7 is when the gold- standard lexical category of the first word in the sentence has been shifted, which creates an empty shared ancestor set. Furthermore, the shared an- cestor set is always empty when the stack is a fron- tier stack.</p><p>The dependency oracle algorithm checks the va- lidity of applicable actions. A SHIFT action is valid if R(c s 1 , c s 0 ) = ∅ for the resulting stack s . A valid REDUCE action consumes s 1 and s 0 . For the new node, its shared ancestor set is the subset of the conjunctive nodes in R(c s 2 , c s 1 ) which dominate the resulting conjunctive node of a valid REDUCE action. The UNARY case for a frontier stack is trivial: any UNARY action ap- plicable to s in Φ G is valid. For a non-frontier stack, the UNARY case is similar to REDUCE ex- cept the resulting shared ancestor set is a subset of R(c s 1 , c s 0 ).</p><p>We now turn to the problem of finding the shared ancestor sets. In practice, we do not do this by traversing Φ G top-down from the conjunctive nodes in p L (c s 0 ) on-the-fly to find each member of R. Instead, when we build Φ G in bottom-up topo- logical order, we pre-compute the set of reachable disjunctive nodes of each conjunctive node c in Φ G as:</p><formula xml:id="formula_9">D(c) = δ(c) ∪ (∪ c ∈γ(d),d∈δ(c) (D(c )))</formula><p>Each D is implemented as a hash map, which allows us to test the membership of one potential conjunctive node in O <ref type="formula">(1)</ref>  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Training</head><p>We use the averaged perceptron <ref type="bibr" target="#b7">(Collins, 2002)</ref> to train a global linear model and score each ac- tion. The normal-form model of <ref type="bibr" target="#b28">Zhang and Clark (2011)</ref> uses an early update mechanism ( <ref type="bibr" target="#b6">Collins and Roark, 2004</ref>), where decoding is stopped to update model weights whenever the single gold action falls outside the beam. In our parser, there can be multiple gold items in a beam. One option would be to apply early update whenever at least</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 Dependency Model Training</head><p>Input: (y, G) and beam size k 1: w ← 0; B0 ← ∅; i ← 0 2: B0.push(s, q0) the initial item 3: cand ← ∅ candidate output priority queue 4: gold ← ∅ gold output priority queue 5: while Bi = ∅ do 6: for each s, q ∈ Bi do 7: if |q| = 0 then candidate output 8:</p><p>cand.push(s,</p><note type="other">q) 9: if s G then s is a realization of G 10: gold.push(s, q) 11: expand s, q into Bi+1 12: Bi+1 ← Bi+1[1 : k] apply beam 13: if ΠG = ∅, ΠG ∩ Bi+1 = ∅ and cand[0] G then 14:</note><formula xml:id="formula_10">w ← w + φ(ΠG[0]) − φ(Bi+1[0])</formula><note type="other">early update 15: return 16: i ← i + 1 continue to next step 17: if cand[0] G then final update 18: w</note><formula xml:id="formula_11">← w + φ(gold[0]) − φ(cand[0])</formula><p>one of these gold items falls outside the beam. However, this may not be a true violation of the gold-standard ( <ref type="bibr" target="#b17">Huang et al., 2012</ref>). Thus, we use a relaxed version of early update, in which all gold- standard actions must fall outside the beam before an update is performed. This update mechanism is provably correct under the violation-fixing frame- work of <ref type="bibr" target="#b17">Huang et al. (2012)</ref>.</p><p>Let (y, G) be a training sentence paired with its gold-standard dependency structure and let Π s,q be the following set for an item s, q: <ref type="figure">s, q, (x, c)</ref>, Φ G ) = true} Π s,q contains all correct items at step i + 1 ob- tained by expanding s, q. Let the set of all cor- rect items at a step i + 1 be: 5</p><formula xml:id="formula_12">{{s, q • (x, c) | f d (</formula><formula xml:id="formula_13">Π G = s,q∈B i Π s,q</formula><p>Algorithm 3 shows the pseudocode for training the dependency model with early update for one input (y, G). The score of an item s, q is calcu- lated as w · φ(s, q) with respect to the current model w, where φ(s, q) is the feature vector for the item. At step i, all items are expanded and added onto the next beam B i+1 , and the top-k re- tained. Early update is applied when all gold items first fall outside the beam, and any candidate out- put is incorrect (line 14). Since there are poten- tially many gold items, and one gold item is re- quired for the perceptron update, a decision needs to be made regarding which gold item to update against. We choose to reward the highest scoring gold item, in line with the violation-fixing frame- work; and penalize the highest scoring incorrect item, using the standard perceptron update. A fi- nal update is performed if no more expansions are possible but the final output is incorrect.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We implement our shift-reduce parser on top of the core C&amp;C code base <ref type="bibr" target="#b3">(Clark and Curran, 2007)</ref> and evaluate it against the shift-reduce parser of Zhang and Clark (2011) (henceforth Z&amp;C) and the chart- based normal-form and hybrid models of <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>. For all experiments, we use CCGBank with the standard split: sections 2-21 for training (39,604 sentences), section 00 for de- velopment (1,913 sentences) and section 23 (2,407 sentences) for testing.</p><p>The way that the CCG grammar is implemented in C&amp;C has some implications for our parser. First, unlike Z&amp;C, which uses a context-free cover <ref type="bibr" target="#b9">(Fowler and Penn, 2010)</ref> and hence is able to use all sentences in the training data, we are only able to use 36,036 sentences. The reason is that the grammar in C&amp;C does not have complete cover- age of CCGBank, due to the fact that e.g. not all rules in CCGBank conform to the combinatory rules of CCG. Second, our parser uses the unifica- tion mechanism from C&amp;C to output dependencies directly, and hence does not need a separate post- processing step to convert derivations into CCG de- pendencies, as required by Z&amp;C.</p><p>The feature templates of our model consist of all of those in Z&amp;C, except the ones which re- quire lexical heads to come from either the left or right child, as such features are incompatible with the head passing mechanism used by C&amp;C. Each Z&amp;C template is defined over a parse item, and captures various aspects of the stack and queue context. For example, one template returns the top category on the stack plus its head word, to- gether with the first word and its POS tag on the queue. Another template returns the second cat- egory on the stack, together with the POS tag of its head word. Every Z&amp;C feature is defined as a pair, consisting of an instantiated context tem- plate and a parse action. In addition, we use all the CCG predicate-argument dependency features from <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>, which contribute to the score of a REDUCE action when dependencies  are realized. Detailed descriptions of all the tem- plates in our model can be found in the respective papers. We run 20 training iterations and the re- sulting model contains 16.5M features with a non- zero weight.</p><p>We use 10-fold cross validation for POS tagging and supertagging the training data, and automat- ically assigned POS tags for all experiments. A probability cut-off value of 0.0001 for the β pa- rameter in the supertagger is used for both train- ing and testing. The β parameter determines how many lexical categories are assigned to each word; β = 0.0001 is a relatively small value which al- lows in a large number of categories, compared to the default value used in <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>. For training only, if the gold-standard lexical cat- egory is not supplied by the supertagger for a par- ticular word, it is added to the list of categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Results and Analysis</head><p>The beam size was tuned on the development set, and a value of 128 was found to achieve a rea- sonable balance of accuracy and speed; hence this value was used for all experiments. Since C&amp;C al- ways enforces non-fragmentary output (i.e. it can only produce spanning analyses), it fails on some sentences in the development and test sets, and thus we also evaluate on the reduced sets, follow- ing <ref type="bibr" target="#b3">Clark and Curran (2007)</ref>. Our parser does not fail on any sentences because it permits fragmen- tary output (those cases where there is more than one subtree left on the final stack). The results for Z&amp;C, and the C&amp;C normal-form and hybrid mod- els, are taken from <ref type="bibr" target="#b28">Zhang and Clark (2011)</ref>. <ref type="table">Table 1</ref> shows the accuracies of all parsers on the development set, in terms of labeled precision and recall over the predicate-argument dependen- cies in CCGBank. On both the full and reduced sets, our parser achieves the highest F-score. In comparison with C&amp;C, our parser shows signif- icant increases across all metrics, with 0.57% and 1.06% absolute F-score improvements over the hybrid and normal-form models, respectively. Another major improvement over the other two parsers is in sentence level accuracy, LSent, which measures the number of sentences for which the dependency structure is completely correct. <ref type="table">Table 1</ref> also shows that our parser has improved recall over Z&amp;C at some expense of precision. To probe this further we compare labeled precision and recall relative to dependency length, as mea- sured by the distance between the two words in a dependency, grouped into bins of 5 values. <ref type="figure" target="#fig_3">Fig. 4</ref> shows clearly that Z&amp;C favors precision over re- call, giving higher precision scores for almost all dependency lengths compared to our parser. In   terms of recall ( <ref type="figure" target="#fig_3">Fig. 4b)</ref>, our parser outperforms Z&amp;C over all dependency lengths, especially for longer dependencies <ref type="bibr">(x ≥ 20)</ref>. When compared with C&amp;C, the recall of the Z&amp;C parser drops quickly for dependency lengths over 10. While our parser also suffers from this problem, it is less severe and is able to achieve higher recall at x ≥ 30. <ref type="table" target="#tab_3">Table 2</ref> compares our parser with Z&amp;C and the C&amp;C hybrid model, for the most frequent depen- dency relations. While our parser achieved lower precision than Z&amp;C, it is more balanced and gives higher recall for all of the dependency relations ex- cept the last one, and higher F-score for over half of them. <ref type="table" target="#tab_4">Table 3</ref> presents the final test results on Section 23. Again, our parser achieves the highest scores across all metrics (for both the full and reduced test sets), except for precision and lexical category assignment, where Z&amp;C performed better.</p><formula xml:id="formula_14">category LP % (o) LP % (z) LP % (c) LR % (o) LR % (z) LR % (c) LF % (o) LF % (z) LF % (c) freq. N /N 95</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We have presented a dependency model for a shift- reduce CCG parser, which fully aligns CCG parsing with the left-to-right, incremental nature of a shift- reduce parser. Our work is in part inspired by the dependency models of <ref type="bibr" target="#b3">Clark and Curran (2007)</ref> and, in the use of a dependency oracle, is close in spirit to that of <ref type="bibr" target="#b11">Goldberg and Nivre (2012)</ref>. The difference is that the Goldberg and Nivre parser builds, and scores, dependency structures directly, whereas our parser uses a unification mechanism to create dependencies, and scores the CCG deriva- tions, allowing great flexibility in terms of what dependencies can be realized. Another related work is <ref type="bibr" target="#b26">Yu et al. (2013)</ref>, which introduced a sim- ilar technique to deal with spurious ambiguity in MT. Finally, there may be potential to integrate the techniques of <ref type="bibr" target="#b0">Auli and Lopez (2011)</ref>, which cur- rently represents the state-of-the-art in CCGBank parsing, into our parser.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>A REDUCE action (REDUCE, c) is valid if c matches the category of the conjunctive node parent of c s 0 and c s 1 in Φ G . A UNARY action (UNARY, c) is valid if c matches the conjunctive node parent of c s 0 in Φ G . We now generalize the case where Φ G contains a single correct parse to the case of an oracle forest, where each parent p is replaced by a set of conjunctive nodes in Φ G . Definition 4. The left parent set p L (c) of con- junctive node c ∈ Φ G is the set of all parent con- junctive nodes of c in Φ G , which have the disjunc- tive node d containing c (i.e. c ∈ γ(d)) as a left child.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Definition 7 .</head><label>7</label><figDesc>Let s, q be an item and let s , q = s, q • (x, c). We define the shared an- cestor set R(c s 1 , c s 0 ) of c s 0 , after applying action (x, c), as: • {c | c ∈ pL(cs 0 ) ∩ A(c)}, if s is frontier and x = SHIFT • {c | c ∈ pL(cs 0 ) ∩ A(c) and there is some c ∈ R(cs 1 , cs 0 ) s.t. c ∈ A(c )}, if s is non-frontier and x = SHIFT • {c | c ∈ R(cs 2 , cs 1 ) ∩ A(c)}, if x = REDUCE • {c | c ∈ R(cs 1 , cs 0 ) ∩ A(c)}, if s is non-frontier and x = UNARY</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>time. For example, a conjunctive node c ∈ p L (c s 0 ) is reachable from c lex 0 if there is a disjunctive node d ∈ D(c) s.t. c lex 0 ∈ γ(d). With this implementation, the com- plexity of checking each valid SHIFT action is then O(|p L (c s 0 )|).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Labeled precision and recall relative to dependency length on the development set. C&amp;C normal-form model is used.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Accuracy comparison on most frequent dependency types, for our parser (o), Z&amp;C (z) and C&amp;C 
hybrid model (c). Categories in bold indicate the argument slot in the relation. 

LP % LR % LF % LSent. % CatAcc. % coverage % 
our parser 
87.03 85.08 86.04 35.69 
93.10 
100 

Z&amp;C 

87.43 83.61 85.48 35.19 
93.12 
100 
C&amp;C (normal-form) 85.58 82.85 84.20 32.90 
92.84 
100 
our parser 
87.04 85.16 86.09 35.84 
93.13 
99.58 (C&amp;C coverage) 

Z&amp;C 

87.43 83.71 85.53 35.34 
93.15 
99.58 (C&amp;C coverage) 
C&amp;C (hybrid) 
86.17 84.74 85.45 32.92 
92.98 
99.58 (C&amp;C coverage) 
C&amp;C (normal-form) 85.48 84.60 85.04 33.08 
92.86 
99.58 (C&amp;C coverage) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Accuracy comparison on section 23 (auto POS). 

</table></figure>

			<note place="foot" n="1"> See Hockenmaier (2003) and Clark and Curran (2007) for a description of CCG rules.</note>

			<note place="foot" n="2"> Under the hypergraph framework (Gallo et al., 1993; Huang and Chiang, 2005), a conjunctive node corresponds to a hyperedge and a disjunctive node corresponds to the head of a hyperedge or hyperedge bundle.</note>

			<note place="foot" n="3"> The derivation is &quot;upside down&quot;, following the convention used for CCG, where the root is S [dcl ]. We use sh, re and un to denote the three types of shift-reduce action.</note>

			<note place="foot" n="4"> Strictly speaking, the conjunctive node parent is a parent of the disjunctive node containing the conjunctive node cs 0. We will continue to use this shorthand for parents of conjunctive nodes throughout the paper.</note>

			<note place="foot" n="5"> In Algorithm 3 we abuse notation by using ΠG[0] to denote the highest scoring gold item in the set.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the anonymous reviewers for their help-ful comments. Wenduan Xu is fully supported by the Carnegie Trust and receives additional fund-ing from the Cambridge Trusts. Stephen Clark is supported by ERC Starting Grant DisCoTex (306920) and EPSRC grant EP/I037512/1. Yue Zhang is supported by Singapore MOE Tier2 grant T2MOE201301.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A comparison of loopy belief propagation and dual decomposition for integrated CCG supertagging and parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Auli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Lopez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL 2011</title>
		<meeting>ACL 2011<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="470" to="480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Evaluating the accuracy of an unlexicalized statistical parser on the PARC DepBank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ted</forename><surname>Briscoe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Carroll</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of COLING/ACL</title>
		<meeting>of COLING/ACL<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="41" to="48" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Partial training for a lexicalized-grammar parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">R</forename><surname>Curran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NAACL-06</title>
		<meeting>NAACL-06<address><addrLine>New York, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="144" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Widecoverage efficient statistical parsing with CCG and log-linear models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">R</forename><surname>Curran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="493" to="552" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Evaluating a wide-coverage CCG parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the LREC 2002 Beyond Parseval Workshop</title>
		<meeting>of the LREC 2002 Beyond Parseval Workshop<address><addrLine>Las Palmas, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="60" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Building deep dependency structures with a wide-coverage CCG parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL</title>
		<meeting>ACL<address><addrLine>Philadelphia, PA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
	<note>and Mark Steedman</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Incremental parsing with the perceptron algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Roark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL</title>
		<meeting>of ACL<address><addrLine>Barcelona, Spain</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="111" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Discriminative training methods for hidden Markov models: Theory and experiments with perceptron algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP<address><addrLine>Philadelphia, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Efficient normal-form parsing for Combinatory Categorial Grammar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Eisner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL</title>
		<meeting>ACL<address><addrLine>Santa Cruz, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="79" to="86" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Accurate context-free parsing with Combinatory Categorial Grammar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Timothy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gerald</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Penn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL</title>
		<meeting>ACL<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="335" to="344" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Directed hypergraphs and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Gallo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giustino</forename><surname>Longo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefano</forename><surname>Pallottino</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sang</forename><surname>Nguyen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete applied mathematics</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="177" to="201" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A dynamic oracle for arc-eager dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. COLING</title>
		<meeting>COLING<address><addrLine>Mumbai, India</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient implementation for beam search incremental parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Zhao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Short Papers of ACL</title>
		<meeting>the Short Papers of ACL<address><addrLine>Sofia, Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">CCGbank: A corpus of CCG derivations and dependency structures extracted from the Penn Treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="355" to="396" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Data and Models for Statistical Parsing with Combinatory Categorial Grammar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
		<respStmt>
			<orgName>University of Edinburgh</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Better kbest parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Ninth International Workshop on Parsing Technology</title>
		<meeting>the Ninth International Workshop on Parsing Technology<address><addrLine>Vancouver, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="53" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Dynamic programming for linear-time incremental parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenji</forename><surname>Sagae</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL</title>
		<meeting>ACL<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1077" to="1086" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Structured perceptron with inexact search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Suphan</forename><surname>Fayong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Guo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. NAACL</title>
		<meeting>NAACL<address><addrLine>Montreal, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="142" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Maximum entropy estimation for feature forests</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Miyao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun&amp;apos;ichi</forename><surname>Tsujii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Human Language Technology Conference</title>
		<meeting>the Human Language Technology Conference<address><addrLine>San Diego, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Integrating graph-based and transition-based dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of ACL/HLT</title>
		<meeting>of ACL/HLT<address><addrLine>Columbus, Ohio</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="950" to="958" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Deterministic dependency parsing of English text</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Nivre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Scholz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of COLING 2004</title>
		<meeting>COLING 2004<address><addrLine>Geneva, Switzerland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="64" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Evaluation of dependency parsers on unbounded dependencies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Rimell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gomez-Rodriguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of COLING</title>
		<meeting>of COLING<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Unbounded dependency recovery for parser evaluation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Rimell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EMNLP</title>
		<meeting>EMNLP<address><addrLine>Edinburgh, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="813" to="821" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A framework for (under)specifying dependency syntax without overloading annotators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O&amp;apos;</forename><surname>Brendan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naomi</forename><surname>Connor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Saphra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manaal</forename><surname>Bamman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Faruqui</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Baldridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 7th Linguistic Annotation Workshop and Interoperability with Discourse</title>
		<meeting>of the 7th Linguistic Annotation Workshop and Interoperability with Discourse<address><addrLine>Sofia, Bulgaria</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">The Syntactic Process</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2000" />
			<publisher>The MIT Press</publisher>
			<pubPlace>Cambridge, Mass</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Statistical dependency analysis using support vector machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Yamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Matsumoto</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of IWPT</title>
		<meeting>of IWPT<address><addrLine>Nancy, France</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Max-violation perceptron and forced decoding for scalable mt training</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heng</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Haitao</forename><surname>Mi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EMNLP, Seattle</title>
		<meeting>EMNLP, Seattle<address><addrLine>Washington, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A tale of two parsers: investigating and combining graphbased and transition-based dependency parsing using beam-search</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of EMNLP</title>
		<meeting>of EMNLP<address><addrLine>Hawaii, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Shift-reduce CCG parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yue</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. ACL 2011</title>
		<meeting>ACL 2011<address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="683" to="692" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
