<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:11+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient techniques for parsing with tree automata</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 7-12, 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Groschwitz</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Linguistics</orgName>
								<orgName type="department" key="dep2">Department of Computing</orgName>
								<orgName type="institution">University of Potsdam</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Linguistics</orgName>
								<orgName type="department" key="dep2">Department of Computing</orgName>
								<orgName type="institution">University of Potsdam</orgName>
								<address>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Johnson</surname></persName>
							<email>mark.johnson@mq.edu.au</email>
							<affiliation key="aff1">
								<orgName type="institution">Macquarie University</orgName>
								<address>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient techniques for parsing with tree automata</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
						<meeting>the 54th Annual Meeting of the Association for Computational Linguistics <address><addrLine>Berlin, Germany</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page" from="2042" to="2051"/>
							<date type="published">August 7-12, 2016</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Parsing for a wide variety of grammar formalisms can be performed by intersecting finite tree automata. However, naive implementations of parsing by intersection are very inefficient. We present techniques that speed up tree-automata-based parsing , to the point that it becomes practically feasible on realistic data when applied to context-free, TAG, and graph parsing. For graph parsing, we obtain the best runtimes in the literature.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Grammar formalisms that go beyond context-free grammars have recently enjoyed renewed atten- tion throughout computational linguistics. Clas- sical grammar formalisms such as TAG <ref type="bibr" target="#b12">(Joshi and Schabes, 1997</ref>) and CCG <ref type="bibr" target="#b22">(Steedman, 2001</ref>) have been equipped with expressive statistical mod- els, and high-performance parsers have become available <ref type="bibr" target="#b4">(Clark and Curran, 2007;</ref><ref type="bibr" target="#b18">Lewis and Steedman, 2014;</ref><ref type="bibr" target="#b13">Kallmeyer and Maier, 2013)</ref>. Synchronous grammar formalisms such as syn- chronous context-free grammars <ref type="bibr" target="#b3">(Chiang, 2007)</ref> and tree-to-string transducers ( <ref type="bibr" target="#b8">Galley et al., 2004;</ref><ref type="bibr" target="#b10">Graehl et al., 2008;</ref><ref type="bibr" target="#b20">Seemann et al., 2015)</ref> are being used as models that incorporate syntac- tic information in statistical machine translation. Synchronous string-to-tree ( <ref type="bibr" target="#b23">Wong and Mooney, 2006</ref>) and string-to-graph grammars <ref type="bibr" target="#b2">(Chiang et al., 2013</ref>) have been applied to semantic parsing; and so forth.</p><p>Each of these grammar formalisms requires its users to develop new algorithms for parsing and training. This comes with challenges that are both practical and theoretical. From a theoretical per- spective, many of these algorithms are basically the same, in that they rest upon a CKY-style pars- ing algorithm which recursively explores substruc- tures of the input object and assigns them non- terminal symbols, but their exact relationship is rarely made explicit. On the practical side, this parsing algorithm and its extensions (e.g. to EM training) have to be implemented and optimized from scratch for each new grammar formalism. Thus, development time is spent on reinventing wheels that are slightly different from previous ones, and the resulting implementations still tend to underperform. <ref type="bibr" target="#b15">Koller and Kuhlmann (2011)</ref> introduced Inter- preted Regular Tree Grammars (IRTGs) in order to address this situation. An IRTG represents a language by describing a regular language of derivation trees, each of which is mapped to a term over some algebra and evaluated there. Gram- mars from a wide range of monolingual and syn- chronous formalisms can be mapped into IRTGs by using different algebras: Context-free and tree- adjoining grammars use string algebras of differ- ent kinds, graph grammars can be captured by us- ing graph algebras, and so on. In addition, IRTGs come with a universal parsing algorithm based on closure results for tree automata. Implementing and optimizing this parsing algorithm once, one could apply it to all grammar formalisms that can be mapped to IRTG. However, while Koller and Kuhlmann show that asymptotically optimal pars- ing is possible in theory, it is non-trivial to imple- ment their algorithm optimally.</p><p>In this paper, we introduce practical algorithms for the two key operations underlying IRTG pars- ing: computing the intersection of two tree au- tomata and applying an inverse tree homomor- phism to a tree automaton. After defining IRTGs (Section 2), we will first illustrate that a naive bottom-up implementation of the intersection al- gorithm yields asymptotic parsing complexities that are too high (Section 3). We will then show how the parsing complexity can be im- proved by combining algebra-specific index data structures with a generic parsing algorithm (Sec- tion 4), and by replacing bottom-up with top-down queries (Section 5). In contrast to the naive al- gorithm, both of these methods achieve the ex- pected asymptotic complexities, e.g. O(n 3 ) for context-free parsing, O(n 6 ) for TAG parsing, etc. Furthermore, an evaluation with realistic gram- mars shows that our algorithms improve practi- cal parsing times with IRTG grammars encoding context-free grammars, tree-adjoining grammars, and graph grammars by orders of magnitude (Sec- tion 6). Thus our algorithms make IRTG pars- ing practically feasible for the first time; for graph parsing, we obtain the fastest reported runtimes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Interpreted Regular Tree Grammars</head><p>We will first define IRTGs and explain how the universal parsing algorithm for IRTGs works.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Formal foundations</head><p>First, we introduce some fundamental theoretical concepts and notation.</p><p>A signature Σ is a finite set of symbols r, f, . . ., each of which has an arity ar(r) ≥ 0. A tree t over the signature Σ is a term of the form r(t 1 , . . . , t n ), where the t i are trees and r ∈ Σ has arity n. We identify the nodes of t by their Gorn addresses, i.e. paths π ∈ N * from the root to the node, and write t(π) for the label of π. We write T Σ for the set of all trees over Σ, and T Σ (X k ) for the trees in which each node either has a label from Σ, or is a leaf labeled with one of the variables {x 1 , . . . , x k }.</p><p>A (linear, nondeleting) tree homomorphism h from a signature Σ to a signature ∆ is a mapping h : T Σ → T ∆ . It is defined by specifying, for each symbol r ∈ Σ of arity k, a term h(r) ∈ T ∆ (X k ) in which each variable occurs exactly once. This symbol-wise mapping is lifted to entire trees by letting h(r(t 1 , . . . , t k )) = h(r)[h(t 1 ), . . . , h(t k )], i.e. by replacing the variable x i in h(r) by the re- cursively computed value h(t i ).</p><p>Let ∆ be a signature. A ∆-algebra A con- sists of a nonempty set A, called the domain, and for each symbol f ∈ ∆ with arity k, a function f A : A k → A, the operation associated with f . We can evaluate any term t ∈ T ∆ to a value t A ∈ A, by evaluating the operation symbols bottom-up. In this paper, we will be particularly interested in the string algebra E * over the finite automaton rule homomorphism</p><formula xml:id="formula_0">S → r 1 (NP, VP) * (x 1 , x 2 ) NP → r 2 John VP → r 3 walks VP → r 4 (VP, NP) * (x 1 , * (on, x 2 )) NP → r 5</formula><p>Mars <ref type="figure" target="#fig_0">Figure 1</ref>: An example IRTG.</p><p>alphabet E. Its domain is the set of all strings over E. For each symbol a ∈ E, it has a nullary oper- ation symbol a with a E * = a. It also has a single binary operation symbol * , such that * E * (w 1 , w 2 ) is the concatenation of the strings w 1 and w 2 . Thus the term * (John, * (walks, * (on, Mars))) in <ref type="figure">Fig. 2b</ref> evaluates to the string "John walks on Mars". A finite tree automaton M over the signature Σ is a structure M = (Σ, Q, R, X F ), where Q is a finite set of states and X F ∈ Q is a final state. R is a finite set of transition rules of the form X → r(X 1 , . . . , X k ), where the terminal symbol r ∈ Σ is of arity k and X, X 1 , . . . , X k ∈ Q. A tree automaton can run non-deterministically on a tree t ∈ T Σ by assigning states to the nodes of t bottom-up. If we have t = r(t 1 , . . . , t n ) and M can assign the state X i to each t i , written X i → * t i , then we also have X → * t. We say that M accepts t if X F → * t, and define the language L(M ) ⊆ T Σ of M as the (possibly infinite) set of all trees that M accepts. An example of a tree automaton (with states S, NP, etc.) is shown in the "automaton rule" column of <ref type="figure" target="#fig_0">Fig. 1</ref>. It accepts, among others, the tree τ 1 in <ref type="figure">Fig. 2a</ref>.</p><p>Tree automata can be defined top-down or bottom-up, and are equivalent to regular tree grammars. The languages that can be accepted by finite tree automata are called the regular tree lan- guages. See e.g. <ref type="bibr" target="#b6">Comon et al. (2008)</ref> for details.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Interpreted regular tree grammars</head><p>We can combine tree automata, homomorphisms, and algebras into grammars that can describe lan- guages of arbitrary objects, as well as relations be- tween such objects -in a way that inherits many technical properties from context-free grammars, while extending the expressive capacity.</p><p>An interpreted regular tree grammar (IRTG, <ref type="bibr" target="#b15">Koller and Kuhlmann (2011)</ref></p><formula xml:id="formula_1">) G = (M, (h 1 , A 1 ), . . . , (h n , A n ))</formula><p>consists of a tree automaton M over some signature Σ, together with an arbitrary number n of inter-</p><formula xml:id="formula_2">r 1 r 2 r 4 r 3 r 5 (a) Tree τ1. h − → * John * walks * on Mars (b) Term h (τ1).</formula><p>evaluate − −−− → "John walks on Mars"</p><formula xml:id="formula_3">(c) h (τ1) evaluated in E * .</formula><p>Figure 2: The tree τ 1 , evaluated by the homomorphism h and the algebra E * pretations (h i , A i ), where each A i is an algebra over some signature ∆ i and each h i is a tree homomorphism from Σ to ∆ i . The automaton M describes a language L(M ) of derivation trees which represent abstract syntactic structures. Each derivation tree τ is then interpreted n ways: we map it to a term h i (τ ) ∈ T ∆ i , and then we evaluate</p><formula xml:id="formula_4">h i (τ ) to a value a i = h i (τ ) A i ∈ A i of the algebra A i . Thus, the IRTG G defines a language L(G) = {(h 1 (τ ) A 1 , . . . , h n (τ ) An ) | τ ∈ L(M )},</formula><p>which is an n-place relation between the domains of the algebras.</p><p>Consider the IRTG G shown in <ref type="figure" target="#fig_0">Fig. 1</ref>. The "au- tomaton rule" column indicates the five rules of M ; the final state is S. We already saw the deriva- tion tree τ 1 ∈ L(M ). G has a single interpre- tation, into a string algebra E * , and with a ho- momorphism that is specified by the "homomor- phism" column; for instance, h(r 1 ) = * (x 1 , x 2 ) and h(r 2 ) = John. Applying this homomorphism to τ 1 , we obtain the term h(τ 1 ) in <ref type="figure">Fig. 2b</ref>. As we saw earlier, this term evaluates in the string alge- bra to the string "John walks on Mars" <ref type="figure">(Fig. 2c</ref>). Thus this string is an element of L(G).</p><p>We assume that no two rules of M use the same terminal symbol; this is generally not required in tree automata, but every IRTG can be brought into this convenient form. Furthermore, we focus (but only for simplicity of presentation) on IRTGs that use a single string-algebra interpretation, as in <ref type="figure" target="#fig_0">Fig. 1</ref>. Such grammars capture context-free gram- mars. However, IRTGs can capture a wide vari- ety of grammar formalisms by using different al- gebras. For instance, an interpretation that uses a TAG string algebra (or TAG derived-tree alge- bra) models a tree-adjoining grammar <ref type="bibr" target="#b16">(Koller and Kuhlmann, 2012)</ref>, and an interpretation into an s-graph algebra models a hyperedge replacement graph grammar (HRG, <ref type="bibr" target="#b11">Groschwitz et al. (2015)</ref>). By using multiple algebras, IRTGs can also repre- sent synchronous grammars and (bottom-up) tree- to-tree and tree-to-string transducers. In general, any grammar formalism whose grammars describe derivations in terms of a finite set of states can typ- ically be converted into IRTG.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Parsing IRTGs</head><p>Koller and Kuhlmann (2011) present a uniform parsing algorithm for IRTGs based on tree au- tomata. The (monolingual) parsing problem of IRTG consists in determining, for an IRTG G and an input object a ∈ A, a representation of the set parses(a) = {τ ∈ L(M ) | h(τ ) A = a}, i.e. of the derivation trees that are grammatically correct and are mapped to a by the interpretation. In the ex- ample, we have parses("John walks on Mars") = {τ 1 }, where τ 1 is as above. In general, parses(a) may be infinite, and thus we aim to represent it using a tree automaton Ch a with L(Ch a ) = parses(a), the parse chart of a.</p><p>We can compute Ch a as follows. First, ob-</p><formula xml:id="formula_5">serve that parses(a) = L(M ) ∩ h −1 (terms(a)), where h −1 (L) = {τ ∈ T Σ | h(τ ) ∈ L} (the in- verse homomorphic image, or invhom, of L) and terms(a) = {t ∈ T ∆ | t A = a}, i.</formula><p>e. the set of all terms that evaluate to a. Now assume that the algebra A is regularly decomposable, which means that every a ∈ A has a decomposition au- tomaton D a , i.e. there is a tree automaton D a such that L(D a ) = terms(a). Because regular tree lan- guages are closed under invhom and intersection, we can then compute a tree automaton Ch a by in- tersecting M with the invhom of D a .</p><p>To illustrate the IRTG parsing algorithm, let us compute a chart for the sentence s = "John walks on Mars" with the example grammar G of  [1, 5] → * ( <ref type="bibr">[1,</ref><ref type="bibr">2]</ref>, <ref type="bibr">[2,</ref><ref type="bibr">5]</ref>) <ref type="bibr">[</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2, 5] → * ([2, 3], [3, 5])</head><p>[3, 5] → * ( <ref type="bibr">[3,</ref><ref type="bibr">4]</ref>, <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>) <ref type="bibr">[</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3, 4] → on</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>[4, 5] → Mars</head><p>(a) Some rules of Ds.</p><p>[1, 5] → r 1 ( <ref type="bibr">[1,</ref><ref type="bibr">2]</ref>, <ref type="bibr">[2,</ref><ref type="bibr">5]</ref>) <ref type="bibr">[2,</ref><ref type="bibr">5]</ref> → r 4 ( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>) <ref type="bibr">[2,</ref><ref type="bibr">4]</ref> → r 1 ( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[3,</ref><ref type="bibr">4]</ref>)</p><formula xml:id="formula_6">[1, 2] → r 2 [2, 3] → r 3 (b) Some rules of I = h −1 (Ds). S[1, 5] → r 1 (NP[1, 2], VP[2, 5])</formula><p>VP <ref type="bibr">[2,</ref><ref type="bibr">5]</ref> → r 4 (VP <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, NP <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>)</p><formula xml:id="formula_7">NP[1, 2] → r 2 VP[2, 3] → r 3 NP[4, 5] → r 5</formula><p>(c) The parse chart Chs. T X ← pop(agenda) <ref type="bibr">5:</ref> add T X to P</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6:</head><p>for T X ∈ P do 7:</p><formula xml:id="formula_8">for {T 1 X 1 , T 2 X 2 } = {T X , T X } do 8: for T → r(T 1 , T 2 ) in M L do 9: for X → r(X 1 , X 2 ) in M R do 10: store T X → r(T 1 X 1 , T 2 X 2 ) 11:</formula><p>add T X to agenda if new We can then compute the invhom automaton I,</p><formula xml:id="formula_9">such that L(I) = h −1 (L(D s ))</formula><p>. I uses the same states as D s , but uses terminal symbols from Σ in- stead of ∆. Some rules of the invhom automaton I in the example are shown in <ref type="figure" target="#fig_2">Fig. 3b</ref>. Notice that I also contains rules that are not consistent with M , i.e. that would not occur in a grammatical parse of the sentence, such as <ref type="bibr">[2,</ref><ref type="bibr">4]</ref> → r 1 ( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[3,</ref><ref type="bibr">4]</ref>). Finally, the chart Ch s is computed by intersecting M with I (see <ref type="figure" target="#fig_2">Fig. 3c</ref>). The states of Ch s are pairs of states from M and states from I. It accepts τ 1 , because τ 1 ∈ parses(s). Observe the similarity to a traditional context-free parse chart.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Bottom-up intersection</head><p>Both the practical efficiency of this algorithm and its asymptotic complexity depend crucially on how we compute intersection and invhom. We il- lustrate this using an overly naive intersection al- gorithm as a strawman, and then analyze the prob- lem to lay the foundations for the improved algo- rithms in Sections 4 and 5.</p><p>Let's say that we want to compute a tree au- tomaton C for the intersection of a "left" automa- ton M L and a "right" automaton M R both over the same signature Σ. In the application to IRTG parsing, M L is typically the derivation tree au- tomaton (called M above) and M R is the inv- hom of a decomposition automaton. As in the product construction for finite string automata, the states of C will be pairs T X of states T of M L and states X of M R , and the rules of C will all have the form T X → r(T 1 X 1 , . . . , T n X n ), where T → r(T 1 , . . . , T n ) is a rule in M L , and X → r(X 1 , . . . , X n ) is a rule in M R .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Naive intersection</head><p>A naive bottom-up algorithm is shown in Alg. 1. <ref type="bibr">1</ref> This algorithm maintains an agenda of state pairs that have been discovered, but not explored as children of bottom-up rule applications; and a chart-like set P of all state pairs that have ever been popped off the agenda. The algorithm main- tains the invariant that if T X is on the agenda or in P , then T and X are partners (written T ≈ X), i.e. there is a tree t ∈ T Σ such that</p><formula xml:id="formula_10">T → * t in M L and X → * t in M R .</formula><p>The agenda is initialized with all state pairs T X, for which M L has a rule T → r and M R has a rule X → r for some nullary symbol r ∈ Σ. Then, while there are state pairs left on the agenda, Alg. 1 pops a state pair T X off the agenda and adds it to P ; iterates over all state pairs T X in P ; and queries M L and M R bottom-up for rules in which these states appear as children. <ref type="bibr">2</ref> The itera- tion in line 7 allows T and X to be either left or right children in these rules. For each pair of left and right rules, the rules are combined into a rule of C, and the pair of the parent states T and X is added to the agenda.</p><p>This naive intersection algorithm yields an asymptotic complexity for IRTG parsing that is higher than expected. Assume, for example, 1: initialize agenda with state pairs for constants <ref type="bibr">2:</ref> generate new S r = S(M R , r) for every r ∈ Σ 3: while agenda is not empty do 4:</p><formula xml:id="formula_11">T X ← pop(agenda) 5: for T → r(T 1 , T 2 ) in M L s.t. T i = T do 6:</formula><p>for X → r(X 1 , X 2 ) ∈ BU(S r , i, X ) do</p><formula xml:id="formula_12">7: store rule T X → r(T 1 X 1 , T 2 X 2 ) 8:</formula><p>add T X to agenda if new that we are parsing with an IRTG encoding of a context-free grammar, i.e. with a string algebra (as in <ref type="figure" target="#fig_0">Fig. 1)</ref>. Then the states of M R are spans <ref type="bibr">[i, k]</ref>, i.e. M R has O(n 2 ) states. Once line 4 has picked a span X = [i, j], line 6 iterates over all spans X = [k, l] that have been discovered so far -including ones in which j = k and i = l. Thus the bottom-up lookup in line 9 is executed O(n 4 ) times, most of which will yield no rules. The overall runtime of Alg. 1 is therefore higher than the asymptotic runtime of O(n 3 ) expected for context-free parsing. Similar problems arise for other algebras; for instance, the runtime of Alg. 1 for TAG parsing is O(n 8 ) rather than O(n 6 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Indexing</head><p>In context-free parsing algorithms, such as CKY or Earley, this issue is addressed through appro- priate index datastructures, which organize P such that the lookup in line 5 only returns state pairs where X is of the form <ref type="bibr">[j, k]</ref> or <ref type="bibr">[k, i]</ref>. This re- duces the runtime to cubic.</p><p>The idea of obtaining optimal asymptotic com- plexities in IRTG parsing through appropriate in- dexing was already mentioned from a theoreti- cal perspective by <ref type="bibr" target="#b15">Koller and Kuhlmann (2011)</ref>. However, they assumed an optimal indexing data structure as given. In practice, indexing requires algebra-specific knowledge about X : A CKY- style index only works if we assume that the states of the decomposition automaton are spans (this is not the case in other algebras), and that the only binary operation in the string algebra is * , which composes spans in a certain way. Furthermore, in IRTG parsing the rules of the invhom automaton do not directly correspond to algebra operations, but to terms of operations, which further compli- cates indexing.</p><p>In this paper, we incorporate indexing into the intersection algorithm through sibling-finders. A sibling-finder S = S(M, r) for an automaton M and a label r in M 's signature is a data structure that supports a single operation, BU(S, i, X ). We require that a call to BU(S, i, X ) returns the set of rules X → r(X 1 , . . . , X n ) of M such that X is the i-th child state, and for every j = i, X j must be a state for which we previously called BU(S, j, X j ). Thus a sibling-finder performs a bottom-up rule lookup, changing its state after each call by caching the state and position.</p><p>Assume that we have sibling-finders for M R . Then we can modify the naive Alg. 1 to the closely related algorithm shown as Alg. 2. This algorithm maintains the same agenda as Alg. 1, but instead of iterating over all explored partner states T X , it first iterates over all rules in M L that have T as a child (line 5). In line 6, Alg. 2 then queries M R sibling-finders -we maintain one for each rule la- bel -for right rules with matching rule label and child positions. Note that because there is only one rule with label r in M L , the sibling-finders implic- itly keep track of the partners of T 2 we have seen so far. Thus they play the role of a more structured variant of P .</p><p>There are a number of ways in which sibling- finders can be implemented. First, they could simply maintain sets chi(S r , i) where a call to BU(S r , i, X ) first adds X to chi(S r , i). The query can then iterate over the set chi(S r , 3−i), to check for each state X in that set whether M R ac- tually contains a rule with terminal symbol r and children X and X (in the right order). This es- sentially reimplements the behavior of Alg. 1, and comes with the same complexity issues.</p><p>Second, we could theoretically iterate over all rules of M R to implement the sibling finders via a bottom-up index (e.g., a trie) that supports effi- cient BU queries. However, in IRTG parsing M R is the invhom of a decomposition automaton. Be- cause the decomposition automaton represents all the ways in which the input object can be built re- cursively out of smaller structures, including ones which will later be rejected by the grammar, such automata can be very large in practice. Thus we would like to work with a lazy representation of M R and avoid iterating over all rules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Efficient bottom-up lookup</head><p>Finally, we can exploit the fact that in IRTG parsing, M R is the invhom of a decomposition automaton. Below, we first show how to de- fine algebra-specific sibling-finders for decompo-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 3 passUpwards(Y, π, i, r)</head><p>1: rules ← BU(S r,π , i, Y ) 2: if π = π k = then <ref type="bibr">3:</ref> for X → f (X 1 , . . . , X n ) ∈ rules do <ref type="bibr">4:</ref> passUpwards(X, π , k, r) sition automata. Then we develop an algebra- independent way to generate invhom sibling- finders out of those for the decomposition au- tomata. These can be plugged into Alg. 2 to achieve the expected parsing complexity. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Sibling-finders for decomposition automata</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Sibling-finders for invhom</head><p>We can build upon the D-sibling-finders to con- struct sibling-finders for the invhom I of D. The basic idea is as follows. Consider the term h (r 1 ) = * (x 1 , x 2 ) from <ref type="figure" target="#fig_0">Fig. 1</ref>. It contains a sin- gle operation symbol * (plus variables); the homo- morphism only replaces one symbol with another. Thus a sibling-finder S(D, * ) from the decompo- sition automaton can directly serve as a sibling- finder S(I, r 1 ). We only need to replace the * label on the returned rules with r 1 .</p><p>In general, the situation is more complicated, because t = h(r) may be a complex term con- sisting of many algebra operations. In such a case, we construct a separate sibling-finder S r,π = new S(D, t(π)) for each node π with at least two children. For instance, consider the term t = h (r 4 ) in <ref type="figure" target="#fig_0">Fig. 1</ref>. It contains three nodes which are labeled by algebra operations, two of which are the concatenation. We decorate these with the sibling-finders S r 4 ,, and S r 4 ,1 . Each of these is a sibling-finder for the algebra's concatenation op- eration; but they may have different state because they received different queries.</p><p>We can then construct an invhom sibling- finder S r = S(I, r), which answers a query BU(S r , i, X ) in two steps. First, we substitute the variable x i by the state X and percolate it upward through t using the D-sibling-finders on the path from x i to the root. If π = π k is the path to x i , we do this by calling passUpwards(X , π , k, r), as defined in Alg. 3. If the local sibling-finder re- turns rules and we are not at the root yet, we recur- sively call passUpwards at the parent node π with each parent state of these rules.</p><p>As we do this, we let each sibling-finder main- tain the set of rules it found, indexed by their parent state. This allows us to perform the sec- ond step: we traverse t top-down from the root to extract the rules of the invhom automaton that answer the BU query. Recall that BU(S r , i, X ) should return only rules X → r(X 1 , X 2 ) where BU(S r , 3 − i, X 3−i ) was called before. Here, this is guaranteed by having distinct D-sibling-finders S π,r for every node π at every tree h(r). A final detail is that before the first query to r, we initial- ize the sibling-finders by calling passUpwards for all the leaves that are labeled by constants. * ∅ ∅</p><formula xml:id="formula_13">x 1 * 4 : [3, 4] ∅ 7 : [6, 7] on x 2 (a) After initialization. * ∅ 3 : [3, 6]</formula><p>x 1 * 4 : <ref type="bibr">[3,</ref><ref type="bibr">4]</ref> 4 : <ref type="bibr">[4,</ref><ref type="bibr">6]</ref> 7 : <ref type="bibr">[6,</ref><ref type="bibr">7]</ref> on x 2 (b) After BU <ref type="figure" target="#fig_4">(S, 2, [4, 6]</ref>). * 3 : [2, 3] 3 : <ref type="bibr">[3,</ref><ref type="bibr">6]</ref> x 1 * 4 : <ref type="bibr">[3,</ref><ref type="bibr">4]</ref> 4 : <ref type="bibr">[4,</ref><ref type="bibr">6]</ref> 7 : <ref type="bibr">[6,</ref><ref type="bibr">7]</ref> on x 2 (c) After BU(S, 1, <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>). </p><formula xml:id="formula_14">for X → r(X 1 , X 2 ) in M R do 5:</formula><p>call expand(X i ) for i = 1, 2</p><p>6:</p><formula xml:id="formula_15">for T →r(T 1 , T 2 ) s.t. T i ∈ prt(X i ) do 7:</formula><p>store rule T X→r(</p><formula xml:id="formula_16">T 1 X 1 , T 2 X 2 ) 8:</formula><p>add T to prt(X)</p><p>"walks on a hill". The top-down traversal of the sibling-finders reveals that this state is reached by combining x 1 = <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, for which this BU query asked, with x 2 = [4, 6], and thus the BU query yields the rule [2, 6] → r 4 ( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[4,</ref><ref type="bibr">6]</ref>). A sub- sequent query for BU(S, 2, <ref type="bibr">[4,</ref><ref type="bibr">8]</ref>) would yield the rule [2, 8] → r 4 ( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[4,</ref><ref type="bibr">8]</ref>), and so on. The overall construction allows us to answer BU queries on invhom automata while making use of algebra-specific index structures. Given suit- able index structures, the asymptotic complexity drops down to the expected levels, e.g. O(n 3 ) for IRTGs using the string algebra, O(n 6 ) for the TAG string algebra, and so on. This yields a practical algorithm that can be flexibly adapted to new al- gebras by implementing their sibling-finders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Top-down intersection</head><p>Instead of investing into efficient bottom-up queries, we can also explore the use of top-down queries instead. These ask for all rules with parent state X and terminal symbol r. Such queries com- pletely avoid the problem of finding siblings in M R . An invhom automaton can answer top-down queries for r efficiently by running the decomposi- tion automaton top-down on h(r), collecting child states at the variable nodes. For instance, if we query I from Section 2 top-down for rules with the parent <ref type="bibr">[1,</ref><ref type="bibr">5]</ref> and symbol r 1 , it will enumer- ate the rules <ref type="bibr">[1,</ref><ref type="bibr">5]</ref> → r 1 ( <ref type="bibr">[1,</ref><ref type="bibr">2]</ref>, <ref type="bibr">[2,</ref><ref type="bibr">5]</ref>), <ref type="bibr">[1,</ref><ref type="bibr">5]</ref> → r 1 ( <ref type="bibr">[1,</ref><ref type="bibr">3]</ref>, <ref type="bibr">[3,</ref><ref type="bibr">5]</ref>), and <ref type="bibr">[1,</ref><ref type="bibr">5]</ref> → r 1 ( <ref type="bibr">[1,</ref><ref type="bibr">4]</ref>, <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>), without ever considering any other combination of child states. This is the idea underlying the intersection al- gorithm in Alg. 4. It recursively visits states X of M R , collecting for each X a set prt(X) of states T of M L such that T ≈ X. Line 5 ensures that the prt sets have been computed for both child states of the rule X → r(X 1 , X 2 ). Line 6 then does a bottom-up lookup of M L rules with the terminal symbol r and with child states that are partners of X 1 and X 2 . Applied to our running example, Alg. 4 parses "John walks on Mars" by recursive calls on expand( <ref type="bibr">[1,</ref><ref type="bibr">5]</ref>) and expand( <ref type="bibr">[2,</ref><ref type="bibr">5]</ref>), fol- lowing the rules of I top-down. Recursive calls for <ref type="bibr">[2,</ref><ref type="bibr">3]</ref> and <ref type="bibr">[4,</ref><ref type="bibr">5]</ref> establish VP ∈ prt( <ref type="bibr">[2,</ref><ref type="bibr">3]</ref>) and NP ∈ prt( <ref type="bibr">[4,</ref><ref type="bibr">5]</ref>), which enables the recursive call for <ref type="bibr">[2,</ref><ref type="bibr">5]</ref> to apply r 4 in line 6 and consequently add VP to prt( <ref type="bibr">[2,</ref><ref type="bibr">5]</ref>) in line 8.</p><p>The algorithm mixes top-down queries to M R with bottom-up queries to M L . Line 6 implements the core idea of the CKY parser, in that it performs bottom-up queries on sets of nonterminals that are partners of adjacent spans -but generalized to ar- bitrary IRTGs instead of just the string algebra. The top-down query to M R in line 4 is bounded by the number of rules that actually exist in M R , which is O(n 3 ) for the string algebra, O(n 6 ) in the TAG string algebra, and O n s · 3 ds ds for graphs of degree d and treewidth s − 1 in the graph al- gebra. Thus Alg. 4 achieves the same asymptotic complexity as native parsing algorithms. Condensed top-down intersection. One weak- ness of Alg. 4 is that it iterates over all rules X → r(X 1 , X 2 ) of M R individually. This can be extremely wasteful when M R is the invhom of a decomposition automaton, because it may contain bottom-up top-down top-down cond. sibling-finder a great number of rules that have the same states and only differ in the terminal symbol r. For in- stance, when we encode a context-free grammar as an IRTG, for every rule r of the form A → B C we have h(r) = * (x 1 , x 2 ). The rules of the invhom automaton are the same for all terminal symbols r with the same term h(r). But Alg. 4 iterates over rules r and not over different terms h(r), repeating the exact same computation for every binary rule of the context-free grammar.</p><p>To solve this, we define condensed tree au- tomata, which have rules of the form X → ρ(X 1 , . . . , X n ), where ρ ⊆ Σ is a nonempty set of symbols with arity n. A condensed automaton represents the tree automaton which for all con- densed rules X → ρ(X 1 , . . . , X n ) and all r ∈ ρ has the rule X → r(X 1 , . . . , X n ). It is straight- forward to represent an invhom automaton as a condensed condensed automaton, by determining for each distinct homomorphic image t the set ρ t = {r 1 , . . . , r k } of symbols with h(r i ) = t.</p><p>We can modify Alg. 4 to iterate over condensed rules in line 4, and to iterate in line 6 over the rules T → r(T 1 , T 2 ) for which T i ∈ prt(X i ) and r ∈ ρ. This bottom-up query to M L can be answered ef- ficiently from an appropriate index on the rules of M L . Altogether, this condensed intersection algo- rithm can be dramatically faster than the original version, if the grammar contains many symbols with the same homomorphic image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We compare the runtime performance of the pro- posed algorithms on practical grammars and in- puts, from three very different grammar for- malisms: context-free grammars, TAG, and HRG graph grammars. In each setting, we measure the bottom-up top-down top-down cond. sibling-finder <ref type="figure">Figure 6</ref>: Runtimes for TAG parsing. bottom-up top-down top-down cond. sibling-finder GKT 15 . We measure the runtimes for computing the complete chart, and plot the geometric mean of runtimes for each input size on a log scale. We measured all runtimes on an Intel Xeon E7- 8857 CPU at 3 GHz using Java 8. The JVM was warmed up before the measurements. The parser filtered each grammar automatically, removing all rules whose homomorphic image contained a con- stant that could not be used for a given input (e.g., a word that did not occur in the sentence).</p><p>PCFG. We extracted a binarized context-free grammar with 6929 rules from Section 00 of the Penn Treebank, and parsed the sentences of Sec- tion 00 with it. The homorphism in the corre- sponding IRTG assigns every terminal symbol a constant or the term * (x 1 , x 2 ), as in <ref type="figure" target="#fig_0">Fig. 1</ref>. As a consequence, the condensed automaton optimiza- tion from Section 5 outperforms all other algo-rithms, achieving a 100x speedup over the naive bottom-up algorithm when it was cancelled.</p><p>TAG. We also extracted a tree-adjoining gram- mar from Section 00 of the PTB as described by <ref type="bibr" target="#b1">Chen and Vijay-Shanker (2000)</ref>, converted it to an IRTG as described by <ref type="bibr" target="#b16">Koller and Kuhlmann (2012)</ref>, and binarized it, yielding an IRTG with 26652 rules. Each term h(r) in this grammar represents an entire TAG elementary tree, which means the terms are much more complex than for the PCFG and there are much fewer terminal symbols with the same homomorphic term. As a consequence, condensing the invhom is much less helpful. However, the sibling-finder algorithm ex- cels at maintaining state information within each elementary tree, yielding a 1000x speedup over the naive bottom-up algorithm when it was cancelled.</p><p>Graphs. Finally, we parsed a corpus of graphs instead of strings, using the 13681-rule graph grammar of <ref type="bibr" target="#b11">Groschwitz et al. (2015)</ref> to parse the 1258 graphs with up to 10 nodes from the "Little Prince" AMR-Bank ( <ref type="bibr" target="#b0">Banarescu et al., 2013</ref>). The top-down algorithms are slow in this experiment, confirming Groschwitz et al.'s findings. Again, the sibling-finder algorithm outperforms all other algorithms. Note that Groschwitz et al.'s parser ("GKT 15" in <ref type="figure" target="#fig_6">Fig. 7</ref>) shares much code with our system. It uses the same decomposition automata, but a less mature version of the sibling-finder method which fully computes the invhom automa- ton. Our new system achieves a 9x speedup for parsing the whole corpus, compared to GKT 15.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Related Work</head><p>Describing parsing algorithms at a high level of abstraction has a long tradition in computational linguistics, e.g. in deductive parsing with parsing schemata ( <ref type="bibr" target="#b21">Shieber et al., 1995)</ref>. A key challenge under this view is to index chart entries so they can be retrieved efficiently, which parallels the situation in automata intersection discussed here. <ref type="bibr" target="#b9">Gómez-Rodríguez et al. (2009)</ref> present an algo- rithm that automatically establishes index struc- tures that guarantee optimal asymptotic runtime, but also requires algebra-specific extensions for grammar formalisms that go beyond context-free string grammars.</p><p>Efficient parsing has also been studied in other generalized grammar formalisms beyond IRTG. Kanazawa (to appear) shows how the parsing problem of Abstract Categorial Grammars (de <ref type="bibr" target="#b7">Groote, 2001</ref>) can be translated into Datalog, which enables the use of generic indexing strate- gies for Datalog to achieve optimal asymptotic complexity. <ref type="bibr" target="#b19">Ranta (2004)</ref> discusses parsing for his Grammatical Framework formalism in terms of partial evaluation techniques from functional pro- gramming, which are related to the step-by-step evaluation of sibling-finders in <ref type="figure" target="#fig_4">Figure 4</ref>. Like the approach of Gomez-Rodriguez et al., these meth- ods have not been evaluated for large-scale gram- mars and realistic evaluation data, which makes it hard to judge their relative practical merits.</p><p>Most work in the tree automata community has a theoretical slant, and there is less research on the efficient implementation of algorithms for tree au- tomata than one would expect; <ref type="bibr" target="#b5">Cleophas (2009)</ref> and <ref type="bibr" target="#b17">Lengal et al. (2012)</ref> are notable exceptions. Even these tend to be motivated by applications such as specification and verification, where the tree automata are much smaller and much less am- biguous than in computational linguistics. This makes these systems hard to apply directly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We have presented novel algorithms for comput- ing the intersection and the inverse homomorphic image of finite tree automata. These can be used to implement a generic algorithm for IRTG pars- ing, and apply directly to any grammar formalism that can be represented as an IRTG. An evaluation on practical data from three different grammar for- malisms shows consistent speed improvements of several orders of magnitude, and our graph parser has the fastest published runtimes.</p><p>A Java implementation of our algorithms is available as part of the Alto parser, http:// bitbucket.org/tclup/alto.</p><p>We focused here purely on symbolic parsing, and on computing complete parse charts. In the presence of a probability model (e.g. for IRTG en- codings of PCFGs), our algorithms could be made faster through the use of appropriate pruning tech- niques. It would also be interesting to combine the strengths of the condensed and sibling-finder algorithms for further efficiency gains.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 1 .</head><label>1</label><figDesc>The states of the decomposition automaton D s are spans [i, k] of s; the final state is X F = [1, 5]. The automaton contains fourteen rules, including the ones shown in Fig. 3a</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>.</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: Example rules for the sentence s = "John walks on Mars"</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>First</head><label></label><figDesc>, consider the special case of sibling-finders for a decomposition automaton D. The terminal symbols f of D are the operation symbols of an algebra. If we have information about the opera- tions of this algebra, and how they operate on the states of D, a sibling-finder S = S(D, f ) can use indexing specific to the operation f to look up po- tential siblings, and only for them query D to an- swer BU(S, i, X) For instance, a sibling-finder for the ' * ' op- eration of the string algebra may store all states [k, l] for i = 1 under the index l. Thus a lookup BU(S, 2, [l, m]) can directly retrieve siblings from the l-bin, just as a traditional parse chart would. Spans which do not end at l are never consid- ered. Different algebras require different index structures. For instance, sibling-finders for the string-wrapping operation in the TAG string alge- bra might retrieve all pairs of substrings [k, l, m, o] that wrap around [l, m] instead. Analogous data structures can be defined for the s-graph algebra.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Three stages of BU on S(I, r 4 ) for the sentence "John walks on a hill on Mars".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Runtimes for context-free parsing.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Runtimes for graph parsing.</figDesc></figure>

			<note place="foot" n="1"> We assume binary symbols for simplicity; all algorithms generalize to arbitrary arities. 2 For the invhom automaton this can be done by substituting the variables in the homomorphic image h(r) with the corresponding states X and X , and running the decomposition automaton on the resulting tree.</note>
		</body>
		<back>

			<div type="acknowledgement">
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Abstract meaning representation for sembanking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Banarescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Bonial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madalina</forename><surname>Georgescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kira</forename><surname>Griffitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martha</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Linguistic Annotation Workshop (LAW VII-ID)</title>
		<meeting>the Linguistic Annotation Workshop (LAW VII-ID)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Automated extraction of TAGs from the Penn Treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vijay-Shanker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IWPT</title>
		<meeting>IWPT</meeting>
		<imprint>
			<date type="published" when="2000" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parsing graphs with hyperedge replacement grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Moritz</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bevan</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics (ACL)</title>
		<meeting>the 51st Annual Meeting of the Association for Computational Linguistics (ACL)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchical phrase-based translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="201" to="228" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Widecoverage efficient statistical parsing with CCG and log-linear models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephen</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Curran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="493" to="552" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Forest FIRE and FIRE Wood: Tools for tree automata and tree algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loek</forename><surname>Cleophas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Finite-State Methods and Natural Language Processing (FSMNLP)</title>
		<meeting>the Conference on Finite-State Methods and Natural Language Processing (FSMNLP)</meeting>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hubert</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rémi</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florent</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sophie</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr/" />
		<title level="m">Tree automata techniques and applications</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Towards abstract categorial grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philippe</forename><surname>De Groote</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 39th ACL/10th EACL</title>
		<meeting>the 39th ACL/10th EACL</meeting>
		<imprint>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">What&apos;s in a translation rule</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michel</forename><surname>Galley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Hopkins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Marcu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of HLT/NAACL</title>
		<meeting>HLT/NAACL</meeting>
		<imprint>
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">A compiler for parsing schemata. Software: Practice and Experience</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlos</forename><surname>Gómez-Rodríguez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jesús</forename><surname>Vilares</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Miguel</forename><forename type="middle">A</forename><surname>Alonso</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="page" from="441" to="470" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Training tree transducers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Graehl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2008-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Graph parsing with s-graph grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Groschwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Teichmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd ACL and 7th IJCNLP</title>
		<meeting>the 53rd ACL and 7th IJCNLP</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">TreeAdjoining Grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Aravind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Schabes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Formal Languages</title>
		<editor>G. Rozenberg and A. Salomaa</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="69" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Datadriven parsing using probabilistic linear contextfree rewriting systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Kallmeyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Maier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">39</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="87" to="119" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Makoto Kanazawa. to appear. Parsing and generation as datalog query evaluation</title>
	</analytic>
	<monogr>
		<title level="j">IfCoLog Journal of Logics and Their Applications</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A generalized view on parsing and translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Parsing Technologies (IWPT)</title>
		<meeting>the 12th International Conference on Parsing Technologies (IWPT)</meeting>
		<imprint>
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Decomposing TAG algorithms using simple algebraizations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th TAG+ Workshop</title>
		<meeting>the 11th TAG+ Workshop</meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Vata: A library for efficient manipulation of nondeterministic tree automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ondrej</forename><surname>Lengal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiri</forename><surname>Simacek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tomas</forename><surname>Vojnar</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Tools and Algorithms for the Construction and Analysis of Systems: 18th International Conference, TACAS 2012</title>
		<editor>C. Flanagan and B. König</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A* CCG parsing with a supertag-factored model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mike</forename><surname>Lewis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP</title>
		<meeting>EMNLP</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Grammatical framework: A typetheoretical grammar formalism</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aarne</forename><surname>Ranta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Functional Programming</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="145" to="189" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">String-to-tree multi bottom-up tree transducers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nina</forename><surname>Seemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabienne</forename><surname>Braune</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Maletti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd ACL and 7th IJCNLP</title>
		<meeting>the 53rd ACL and 7th IJCNLP</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Principles and implementation of deductive parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><surname>Shieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando Cn</forename><surname>Schabes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Journal of logic programming</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="3" to="36" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
		<title level="m">The Syntactic Process</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<publisher>MIT Press</publisher>
			<date type="published" when="2001" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Learning for semantic parsing with statistical machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuk</forename><forename type="middle">Wah</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics (HLT/NAACL-2006)</title>
		<meeting>the Human Language Technology Conference of the North American Chapter of the Association for Computational Linguistics (HLT/NAACL-2006)</meeting>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
