<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T11:46+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Graph parsing with s-graph grammars</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>July 26-31, 2015. 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Groschwitz</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Linguistics</orgName>
								<orgName type="institution">University of Potsdam</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Linguistics</orgName>
								<orgName type="institution">University of Potsdam</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christoph</forename><surname>Teichmann</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Linguistics</orgName>
								<orgName type="institution">University of Potsdam</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Graph parsing with s-graph grammars</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing</title>
						<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing <address><addrLine>Beijing, China</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="1481" to="1490"/>
							<date type="published">July 26-31, 2015. 2015</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>A key problem in semantic parsing with graph-based semantic representations is graph parsing, i.e. computing all possible analyses of a given graph according to a grammar. This problem arises in training synchronous string-to-graph grammars, and when generating strings from them. We present two algorithms for graph parsing (bottom-up and top-down) with s-graph grammars. On the related problem of graph parsing with hyperedge replacement grammars, our implementations outperform the best previous system by several orders of magnitude.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The recent years have seen an increased interest in semantic parsing, the problem of deriving a se- mantic representation for natural-language expres- sions with data-driven methods. With the recent availability of graph-based meaning banks ( <ref type="bibr" target="#b2">Banarescu et al., 2013;</ref><ref type="bibr" target="#b15">Oepen et al., 2014</ref>), much work has focused on computing graph-based se- mantic representations from strings ( <ref type="bibr" target="#b9">Jones et al., 2012;</ref><ref type="bibr" target="#b8">Flanigan et al., 2014;</ref><ref type="bibr" target="#b14">Martins and Almeida, 2014)</ref>.</p><p>One major approach to graph-based semantic parsing is to learn an explicit synchronous gram- mar which relates strings with graphs. One can then apply methods from statistical parsing to parse the string and read off the graph.  and <ref type="bibr" target="#b16">Quernheim and Knight (2012)</ref> rep- resent this mapping of a (latent) syntactic struc- ture to a graph with a grammar formalism called hyperedge replacement grammar (HRG; ( <ref type="bibr" target="#b7">Drewes et al., 1997)</ref>). As an alternative to <ref type="bibr">HRG, Koller (2015)</ref> introduced s-graph grammars and showed that they support linguistically reasonable gram- mars for graph-based semantics construction.</p><p>One problem that is only partially understood in the context of semantic parsing with explicit grammars is graph parsing, i.e. the computation of the possible analyses the grammar assigns to an input graph (as opposed to string). This prob- lem arises whenever one tries to generate a string from a graph (e.g., on the generation side of an MT system), but also in the context of extracting and training a synchronous grammar, e.g. in EM train- ing. The state of the art is defined by the bottom- up graph parsing algorithm for HRG by , implemented in the Bolinas tool .</p><p>We present two graph parsing algorithms (top- down and bottom-up) for s-graph grammars. S- graph grammars are equivalent to HRGs, but em- ploy a more fine-grained perspective on graph- combining operations. This simplifies the parsing algorithms, and facilitates reasoning about them. Our bottom-up algorithm is similar to Chiang et al.'s, and derives the same asymptotic number of rule instances. The top-down algorithm is novel, and achieves the same asymptotic runtime as the bottom-up algorithm by reasoning about the bi- connected components of the graph. Our eval- uation on the "Little Prince" graph-bank shows that our implementations of both algorithms out- perform Bolinas by several orders of magnitude. Furthermore, the top-down algorithm can be more memory-efficient in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related work</head><p>The AMR-Bank ( <ref type="bibr" target="#b2">Banarescu et al., 2013)</ref> annotates sentences with abstract meaning representations (AMRs), like the one shown in <ref type="figure">Fig. 1(a)</ref>. These are graphs that represent the predicate-argument structure of a sentence; notably, phenomena such as control are represented by reentrancies in the graph. Another major graph-bank is the SemEval- 2014 shared task on semantic dependency parsing dataset <ref type="bibr" target="#b15">(Oepen et al., 2014</ref>).  <ref type="table">arg1   arg2  arg1   arg1   arg2  arg1  arg1  arg1  arg2  arg1   arg1   want   sleep  boy   want   sleep  boy   want   boy   sleep</ref> sleep want sleep boy <ref type="figure">Figure 1</ref>: AMR (a) for 'The boy wants to sleep', and s-graphs. We call (b) SG want and (c) SG sleep .</p><p>The primary grammar formalism currently in use for synchronous graph grammars is hyper- edge replacement grammar (HRG) ( <ref type="bibr" target="#b7">Drewes et al., 1997</ref>), which we sketch in Section 4.3. An alterna- tive is offered by <ref type="bibr" target="#b11">Koller (2015)</ref>, who introduced s- graph grammars and showed that they lend them- selves to manually written grammars for semantic construction. In this paper, we show the equiv- alence of HRG and s-graph grammars and work out graph parsing for s-graph grammars.</p><p>The first polynomial graph parsing algorithm for HRGs on graphs with limited connectivity was presented by <ref type="bibr" target="#b12">Lautemann (1988)</ref>. Lautemann's original algorithm is a top-down parser, which is presented at a rather abstract level that does not directly support implementation or detailed com- plexity analysis. We extend Lautemann's work by showing how new parse items can be repre- sented and constructed efficiently. Finally,  presented a bottom-up graph parser for HRGs, in which the representation and con- struction of items was worked out for the first time. It produces O((n · 3 d ) k+1 ) instances of the rules in a parsing schema, where n is the number of nodes of the graph, d is the maximum degree of any node, and k is a quantity called the tree-width of the grammar.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">An algebra of graphs</head><p>We start by introducing the exact type of graphs that our grammars and parsers manipulate, and by developing some theory.</p><p>Throughout this paper, we define a graph G = (V, E) as a directed graph with edge labels from some label alphabet L. The graph consists of a finite set V of nodes and a finite set E ⊆ V ×V ×L of edges e = (u, v, l), where u and v are the nodes connected by e, and l ∈ L is the edge label. We say that e is incident to both u and v, and call the number of edges incident to a node its degree. We write u e ↔ v if either e = (u, v, l) or e = (v, u, l) for some l; we drop the e if the identity of the edge is irrelevant. Edges with u = v are called loops; we use them here to encode node labels. Given a graph G, we write n = |V |, m = |E|, and d for the maximum degree of any node in V .</p><p>If f : A B and g : A B are partial func- tions, we let the partial function f ∪ g be defined if for all a ∈ A with both f (a) and g(a) defined, we have f (a) = g(a). We then let (f ∪ g)(a) be f (a) if f (a) is defined; g(a) if g(a) is defined; and undefined otherwise.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The HR algebra of graphs with sources</head><p>Our grammars describe how to build graphs from smaller pieces. They do this by accessing nodes (called source nodes) which are assigned "public names". We define an s-graph <ref type="bibr" target="#b6">(Courcelle and Engelfriet, 2012</ref>) as a pair SG = (G, φ) of a graph G and a source assignment, i.e. a partial, injective function φ : S V that maps some source names from a finite set S to the nodes of G. We call the nodes in φ(S) the source nodes or sources of SG; all other nodes are internal nodes. If φ is defined on the source name σ, we call φ(σ) the σ-source of SG. Throughout, we let s = |S|.</p><p>Examples of s-graphs are given in <ref type="figure">Fig. 1</ref>. We use numbers as node names and lowercase strings for edge names (except in the concrete graphs of <ref type="figure">Fig. 1</ref>, where the edges are marked with edge la- bels instead). Source nodes are drawn in black, with source names drawn on the inside. <ref type="figure">Fig. 1(b)</ref> shows an s-graph SG want with three nodes and four edges. The three nodes are marked as the R-, S-, and O-source, respectively. Likewise, the s- graph SG sleep in (c) has two nodes (one of which is an R-source and the other an S-source) and two edges.</p><p>We can now apply operations to these graphs. First, we can rename the R-source of (c) to an O- source. The result, denoted</p><formula xml:id="formula_0">SG d = SG sleep [R → O], is shown in (d). Next, we can merge SG d</formula><p>with SG want . This copies the edges and nodes of SG d and SG want into a new s-graph; but cru- cially, for every source name σ the two s-graphs have in common, the σ-sources of the graphs are fused into a single node (and become a σ-source of the result). We write || for the merge operation; thus we obtain SG e = SG d || SG want , shown in (e). Finally, we can forget source names. The graph SG f = f S (f O (SG e )), in which we forgot S and O, is shown in (f). We refer to <ref type="bibr" target="#b6">Courcelle and Engelfriet (2012)</ref> for technical details. <ref type="bibr">1</ref> We can take the set of all s-graphs, together with these operations, as an algebra of s-graphs. In ad- dition to the binary merge operation and the unary operations for forget and rename, we fix some fi- nite set of atomic s-graphs and take them as con- stants of the algebra which evaluate to themselves. Following Courcelle and Engelfriet, we call this algebra the HR algebra. We can evaluate any term τ consisting of these operation symbols into an s- graph τ as usual. For instance, the following term encodes the merge, forget, and rename oper- ations from the example above, and evaluates to the s-graph in <ref type="figure">Fig. 1(f)</ref>.</p><formula xml:id="formula_1">(1) f S (f O (SG want || SG sleep [R → O]))</formula><p>The set of s-graphs that can be represented as the value τ of some term τ over the HR alge- bra depends on the source set S and on the con- stants. For simplicity, we assume here that we have a constant for each s-graph consisting of a single labeled edge (or loop), and that the values of all other constants can be expressed by combin- ing these using merge, rename, and forget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">S-components</head><p>A central question in graph parsing is how some s-graph that is a subgraph of a larger s-graph SG (a sub-s-graph) can be represented as the merge of two smaller sub-s-graphs of SG. In general, SG 1 || SG 2 is defined for any two s-graphs SG 1 and SG 2 . However, if we see SG 1 and SG 2 as subgraphs of SG, SG 1 || SG 2 may no longer be a subgraph of SG. For instance, we cannot merge the s-graphs (b) and (c) in <ref type="figure" target="#fig_1">Fig. 2</ref> as part of the graph (a): The startpoints of the edges a and d are both A-sources and would thus become the same node (unlike in (a)), and furthermore the edge d would have to be duplicated. In graph parsing, we already know the identity of all nodes and edges in sub-s-graphs (as nodes and edges in SG), and must thus pay attention that merge operations do not accidentally fuse or duplicate them. In partic- 1 Note that the rename operation of Courcelle and En- gelfriet (2012) allows for swapping source assignments and making multiple renames in one step. We simplify the pre- sentation here, but all of our techniques extend easily. ular, two sub-s-graphs cannot be merged if they have edges in common.</p><formula xml:id="formula_2">{d} 2 {a,b,c} 3 {e} {f} {g} {h} (a) (b) (c) (d) (e) A 1 A 2 A 4 B 3 C 6 B 5 A 1 A 2 A 4 B 3 A 2 B 1 A 4 A 1 A 4d A 2 A 4e B 3 A 5f A 5h A 6 A 5g A 4g a d b c d a</formula><p>We call a sub-s-graph SG 1 of SG extensible if there is another sub-s-graph SG 2 of SG such that SG 1 || SG 2 contains the same edges as SG. An example of a sub-s-graph that is not extensible is the sub-s-graph (b) of the s-graph in (a) in <ref type="figure" target="#fig_1">Fig. 2</ref>. Because sources can only be renamed or forgotten by the algebra operations, but never introduced, we can never attach the missing edge a: this can only happen when 1 and 2 are sources. As a gen- eral rule, a sub-s-graph can only be extensible if it contains all edges that are adjacent to all of its internal nodes in SG. Obviously, a graph parser need only concern itself with sub-s-graphs that are extensible.</p><p>We can further clarify the structure of extensible sub-s-graphs by looking at the s-components of a graph. Let U ⊆ V be some set of nodes. This set splits the edges of G into equivalence classes that are separated by U . We say that two edges e, f ∈ E are equivalent with respect to U , It can be shown that for any s-graph SG = (G, φ), a sub-s-graph SH with source nodes U is extensible iff its edge set is the union of a set of s-components of G with respect to U . We let an s-component representation C = (C, φ) in the s-graph SG = (G, φ ) consist of a source assign- ment φ : S V and a set C of s-components of G with respect to the set VS C = φ(S) ⊆ V of source nodes of φ. Then we can represent every extensible sub-s-graph SH = (H, φ) of SG by the s-component representation C = (C, φ) where C is the set of s-components of which SH con- sists. Conversely, we write T (C) for the unique extensible sub-s-graph of SG represented by the s-component representation C. The utility of s-component representations de- rives from the fact that merge can be evaluated on these representations alone, as follows.</p><formula xml:id="formula_3">e ∼ U f , if there is a sequence v 1 e ↔ v 2 ↔ . . . v k−1 f ↔ v k with v 2 , . . . , v k−1 / ∈ U , i.e. if</formula><formula xml:id="formula_4">Lemma 1. Let C = (C, φ), C 1 = (C 1 , φ 1 ), C 2 = (C 2 , φ 2 ) be s-component representations in the s- graph SG. Then T (C) = T (C 1 ) || T (C 2 ) iff C = C 1 C 2 (i.</formula><p>e., disjoint union) and φ 1 ∪φ 2 is defined, injective, and equal to φ.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Boundary representations</head><p>If there is no C such that all conditions of Lemma 1 are satisfied, then T (C 1 ) || T (C 2 ) is not defined. In order to check this efficiently in the bottom-up parser, it will be useful to represent s-components explicitly via their boundary.</p><p>Consider an s-component representation C = (C, φ) in SG and let E be the set of all edges that are adjacent to a source node in VS C and contained in an s-component in C. Then we let the bound- ary representation (BR) β of C in the s-graph SG be the pair β = (E, φ). That is, β represents the s-components through the in-boundary edges, i.e. those edges inside the s-components (and thus the sub-s-graph) which are adjacent to a source. The BR β specifies C uniquely if the base graph SG is connected, so we write T (β) for T (C) and VS β for VS C .</p><p>In <ref type="figure" target="#fig_1">Fig. 2(a)</ref>, the bold sub-s-graph is represented by β = {d, e, f, g}, {A:4, B:5}}, indicating that it contains the A-source 4 and the B-source 5; and further, that the edge set of the sub-s-graph is</p><formula xml:id="formula_5">[d] ∪ [e] ∪ [f ] ∪ [g] = {a, b, c, d, e, f, g}.</formula><p>The edge h (which is also incident to 5) is not specified, and therefore not in the sub-s-graph.</p><p>The following lemma can be shown about com- puting merge on boundary representations. Intu- itively, the conditions (b) and (c) guarantee that the component sets are disjoint; the lemma then follows from Lemma 1.</p><p>Lemma 2. Let SG be an s-graph, and let β 1 = (E 1 , φ 1 ), β 2 = (E 2 , φ 2 ) be two boundary repre- sentations in SG. Then T (β 1 ) || T (β 2 ) is defined within SG iff the following conditions hold:</p><p>(a) φ 1 ∪ φ 2 is defined and injective;</p><p>(b) the two BRs have no in-boundary edges in common, i.e. E 1 ∩ E 2 = ∅;</p><p>(c) for every source node v of β 1 , the last edge on the path in SG from v to the closest source node of β 2 is not an in-boundary edge of β 2 , and vice versa.</p><p>Furthermore, if these conditions hold, we have</p><formula xml:id="formula_6">T (β 1 || β 2 ) = T (β 1 ) || T (β 2 )</formula><p>, where we define</p><formula xml:id="formula_7">β 1 || β 2 = (E 1 ∪ E 2 , φ 1 ∪ φ 2 ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">S-graph grammars</head><p>We are now ready to define s-graph grammars, which describe languages of s-graphs. We also introduce graph parsing and relate s-graph gram- mars to HRGs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Grammars for languages of s-graphs</head><p>We use interpreted regular tree grammars (IRTGs; <ref type="bibr" target="#b10">Koller and Kuhlmann (2011)</ref>) to describe lan- guages of s-graphs. IRTGs are a very general mechanism for describing languages over and re- lations between arbitrary algebras. They sepa- rate conceptually the generation of a grammatical derivation from its interpretation as a string, tree, graph, or some other object.</p><p>Consider, as an example, the tiny grammar in <ref type="figure" target="#fig_3">Fig. 3</ref>; see <ref type="bibr" target="#b11">Koller (2015)</ref> for linguistically mean- ingful grammars. The left column consists of a regular tree grammar G (RTG; see e.g. <ref type="bibr" target="#b5">Comon et al. (2008)</ref>) with two rules. This RTG describes a regular language L(G) of derivation trees (in gen- eral, it may be infinite). In the example, we can derive S ⇒ r 1 (VP) ⇒ r 1 (r 2 ), therefore we have</p><formula xml:id="formula_8">t = r 1 (r 2 ) ∈ L(G).</formula><p>We then use a tree homomorphism h to rewrite the derivation trees into terms over an algebra; in this case the HR algebra. In the example, the val- ues h(r 1 ) and h(r 2 ) are specified in the second col- umn of <ref type="figure" target="#fig_3">Fig. 3</ref>. We compute h(t) by substituting the variable x 1 in h(r 1 ) with h(r 2 ). The term h(t) is thus the one shown in (1). It evaluates to the s-graph SG f in <ref type="figure">Fig. 1(f)</ref>. In general, the IRTG G = (G, h, A) generates the language L(G) = {h(t) | t ∈ L(G)}, where · is evaluation in the algebra A. Thus, in the example, we have L(G) = {SG f }.</p><formula xml:id="formula_9">Rule of RTG G homomorphism h S → r 1 (VP) f S (f O (SG want || x 1 [R → O])) VP → r 2 SG sleep</formula><p>In this paper, we focus on IRTGs that describe languages L(G) ⊆ A of objects in an algebra; specifically, of s-graphs in the HR algebra. How- ever, IRTGs extend naturally to a synchronous grammar formalism by adding more homomor- phisms and algebras. For instance, the grammars in Koller (2015) map each derivation tree simulta- neously to a string and an s-graph, and therefore describe a binary relation between strings and s- graphs. We call IRTGs where at least one algebra is the HR algebra, s-graph grammars.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Parsing with s-graph grammars</head><p>In this paper, we are concerned with the pars- ing problem of s-graph grammars. In the context of IRTGs, parsing means that we are looking for those derivation trees t that are (a) grammatically correct, i.e. t ∈ L(G), and (b) match some given input object a, i.e. h(t) evaluates to a in the al- gebra. Because the set P of such derivation trees may be large or infinite, we aim to compute an RTG G a such that L(G a ) = P . This RTG plays the role of a parse chart, which represents the pos- sible derivation trees compactly.</p><p>In order to compute G a , we need to solve two problems. First, we need to determine all the pos- sible ways in which a can be represented by terms τ over the algebra A. This is familiar from string parsing, where a CKY parse chart spells out all the ways in which larger substrings can be decom- posed into smaller parts by concatenation. Sec- ond, we need to identify all those derivation trees t ∈ L(G) that map to such a decomposition τ , i.e. for which h(t) evaluates to a. In string pars- ing, this corresponds to retaining only such de- compositions into substrings that are justified by the grammar rules.</p><p>While any parsing algorithm must address both of these issues, they are usually conflated, in that parse items combine information about the de- composition of a (such as a string span) with infor- mation about grammaticality (such as nonterminal symbols). In IRTG parsing, we take a different, more generic approach. We assume that the set D of all decompositions τ , i.e. of all terms τ that evaluate to a in the algebra, can be represented as the language D = L(D a ) of a decomposition grammar D a . D a is an RTG over the signature of the algebra. Crucially, D a only depends on the al- gebra and a itself, and not on G or h, because D contains all terms that evaluate to a and not just those that are licensed by the grammar. However, we can compute G a from D a efficiently by exploit- ing the closure of regular tree languages under in- tersection and inverse homomorphism; see <ref type="bibr" target="#b10">Koller and Kuhlmann (2011)</ref> for details.</p><p>In practice, this means that whenever we want to apply IRTGs to a new algebra (as, in this pa- per, to the HR algebra), we can obtain a parsing algorithm by specifying how to compute decom- position grammars over this algebra. This is the topic of Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Relationship to HRG</head><p>We close our exposition of s-graph grammars by relating them to HRGs. It is known that the graph languages that can be described with s-graph grammars are the same as the HRG languages <ref type="bibr">(Courcelle and Engelfriet, 2012, Prop. 4.27)</ref>. Here we establish a more precise equivalence result, so we can compare our asymptotic runtimes directly to those of HRG parsers.</p><p>An HRG rule, such as the one shown in <ref type="figure" target="#fig_4">Fig. 4</ref>, rewrites a nonterminal symbol into a graph. The example rule constructs a graph for the nontermi- nal S by combining the graph G r in the middle (with nodes 1, 2, 3 and edges e, f ) with graphs G X and G Y that are recursively derived from the non- terminals X and Y . The combination happens by merging the external nodes of G X and G Y with nodes of G r : the squiggly lines indicate that the external node I of G X should be 1, and the ex- ternal node II should be 2. Similarly the external nodes of G Y are unified with 1 and 3. Finally, the external nodes I and II of the HRG rule for S itself, shaded gray, are 1 and 3.</p><p>The fundamental idea of the HRG-to-IRTG translation is to encode external nodes as sources, and to use rename and merge to unify the nodes of the different graphs. In the example, we might say that the external nodes of G X and G Y are repre- sented using the source names I and II, and extend G r to an s-graph by saying that the nodes 1, 2, and 3 are its I-source, III-source, and II-source respec- tively. This results in the expression</p><formula xml:id="formula_10">(2) f III (I e → III || x 1 [II → III] || I f → II || x 2 )</formula><p>where we write "I e → III" for the s-graph con- sisting of the edge e, with node 1 as I-source and 2 as III-source.</p><p>However, this requires the use of three source names (I, II, and III). The following encoding of the rule uses the sources more economically:</p><formula xml:id="formula_11">(3) f II (I e → II || x 1 ) || I f → II || x 2</formula><p>This term uses only two source names. It forgets II as soon as we are finished with the node 2, and frees the name up for reuse for 3. The complete encoding of the HRG rule consists of the RTG rule S → r(X, Y) with h(r) = (3).</p><p>In the general case, one can "read off" possible term encodings of a HRG rule from its tree decom- positions; see  or Def. 2.80 of Courcelle and Engelfriet (2012) for details. A tree decomposition is a tree, each of whose nodes π is labeled with a subset V π of the nodes in the HRG rule. We can construct a term encoding from a tree decomposition bottom-up. Leaves map to vari- ables or constants; binary nodes introduce merge operations; and we use rename and forget oper- ations to ensure that the subterm for the node π evaluates to an s-graph in which exactly the nodes in V π are source nodes. <ref type="bibr">2</ref> In the example, we obtain (3) from the tree decomposition in <ref type="figure" target="#fig_4">Fig. 4</ref> like this.</p><p>The tree-width k of an HRG rule is measured by finding the tree decomposition of the rule for which the node sets have the lowest maximum size s and setting k = s − 1. It is a crucial measure be- cause Chiang et al.'s parsing algorithm is exponen- tial in k. The translation we just sketched uses s source names. Thus we see that a HRG with rules of tree-width ≤ k can be encoded into an s-graph grammar with k + 1 source names. (The converse is also true.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Graph parsing with s-graph grammars</head><p>Now we show how to compute decomposition grammars for the s-graph algebra. As we ex- plained in Section 4.2, we can then obtain a com- plete parser for s-graph grammars through generic methods. Given an s-graph SG, the language of the de- composition grammar D SG is the set of all terms over the HR algebra that evaluate to SG. For ex- ample, the decomposition grammar for the graph SG in <ref type="figure">Fig. 1(a)</ref> contains -among many others - the following two rules:</p><formula xml:id="formula_12">(4) SG → f R (SG f ) (5) SG e → || (SG b , SG d ),</formula><p>where SG f , SG e , SG b , and SG d are the graphs from <ref type="figure">Fig. 1</ref> (see Section 3.1). In other words, D SG keeps track of sub-s-graphs in the nonterminals, and the rules spell out how "larger" sub-s-graphs can be constructed from "smaller" sub-s-graphs using the operations of the HR algebra. The al- gorithms below represent sub-s-graphs compactly using s-component and boundary representations.</p><p>Because the decomposition grammars in the s- graph algebra can be very large (see Section 6), we will not usually compute the entire decompo- sition grammar explicitly. Instead, it is sufficient to maintain a lazy representation of D SG , which allows us to answer queries to the decomposition grammar efficiently. During parsing, such queries will be generated by the generic part of the pars- ing algorithm. Specifically, we will show how to answer the following types of query:</p><p>• Top-down: given an s-component represen- tation C of some s-graph and an algebra operation o, enumerate all the rules C → o(C 1 , . . . , C k ) in D SG . This asks how a larger sub-s-graph can be derived from other sub-s- graphs using the operation o. In the example above, a query for SG and f R (·) should yield, among others, the rule in (4).</p><p>• Bottom-up: given boundary representations β 1 , . . . , β k and an algebra operation o, enu- merate all the rules β → o(β 1 , . . . , β k ) in D SG . This asks how smaller sub-s-graphs can be combined into a bigger one using the <ref type="table">Table 1</ref>: Amortized per-rule runtimes T for the different rule types. operation o. In the example above, a merge query for SG b and SG d should yield the rule in (5). Unlike in the top-down case, every bottom-up query returns at most one rule.</p><formula xml:id="formula_13">forget rename merge bottom-up O(d + s) O(s) O(ds) top-down O(ds) O(s) O(ds) I = # rules O(n s 2 ds ) O(n s 2 ds ) O(n s 3 ds )</formula><p>The runtime of the complete parsing algorithm is bounded by the number I of different queries to D SG that we receive, multiplied by the per- rule runtime T that we need to answer each query. The factor I is analogous to the number of rule instances in schema-based parsing ( <ref type="bibr" target="#b17">Shieber et al., 1995)</ref>. The factor T is often ignored in the anal- ysis of parsing algorithms, because in parsing schemata for strings, we typically have T = O(1). This need not be the case for graph parsers. In the HRG parsing schema of , we have I = O(n k+1 3 d(k+1) ), where k is the tree- width of the HRG. In addition, each of their rule instances takes time T = O(d(k + 1)) to actually calculate the new item.</p><p>Below, we show how we can efficiently answer both bottom-up and top-down queries to D SG . Ev- ery s-graph grammar has an equivalent normal form where every constant describes an s-graph with a single edge. Assuming that the grammar is in this normal form, queries of the form β → g (resp. C → g), where g is a constant of the HR- algebra, are trivial and we will not consider them further. <ref type="table">Table 1</ref> summarizes our results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Bottom-up decomposition</head><p>Forget and rename. Given a boundary repre- sentation β = (E , φ ), answering the bottom-up forget query β → f A (β ) amounts to verifying that all edges incident to φ (A) are in-boundary in β , since otherwise the result would not be extensible. This takes time O(d). We then let β = (E, φ), where φ is like φ but undefined on A, and E is the set of edges in E that are still incident to a source in φ. Computing β thus takes time O(d + s).</p><p>The rename operation works similarly, but since the edge set remains unmodified, the per-rule run- time is O(s).</p><p>A BR is fully determined by specifying the node and in-boundary edges for each source name, so there are at most O n2 d s different BRs. Since the result of a forget or rename rule is determined by the child β , this is an upper bound for the num- ber I of rule instances of forget or rename.</p><p>Merge. Now consider the bottom-up merge query for the boundary representations β 1 and β 2 .</p><p>As we saw in Section 3.3, T (β 1 ) || T (β 2 ) is not always defined. But if it is, we can answer the query with the rule (β 1 || β 2 ) → || (β 1 , β 2 ), with β 1 || β 2 defined as in Section 3.3. Computing this BR takes time O(ds).</p><p>We can check whether T (β 1 ) || T (β 2 ) is de- fined by going through the conditions of Lemma 2. The only nontrivial condition is (c). In order to check it efficiently, we precompute a data struc- ture which contains, for any two nodes u, v ∈ V , the length k of the shortest undirected path u = v 1 ↔ . . . e ↔ v k = v and the last edge e on this path. This can be done in time O(n 3 ) using the Floyd-Warshall algorithm. Checking (c) for every source pair then takes time O(s 2 ) per rule, but be- cause sources that are common to both β 1 and β 2 automatically satisfy (c) due to (a), one can show that the total runtime of checking (c) for all merge rules of D S G is O(n s 3 ds s).</p><p>Observe finally that there are I = O(n s 3 ds ) instances of the merge rule, because each of the O(ds) edges that are incident to a source node can be either in β 1 , in β 2 , or in neither. Therefore the runtime for checking (c) amortizes to O(s) per rule. The Floyd-Warshall step amortizes to O(1) per rule for s ≥ 3; for s ≤ 2 the node table can be computed in amortized O(1) using more spe- cialized algorithms. This yields a total amortized per-rule runtime T for bottom-up merge of O(ds).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Top-down decomposition</head><p>For the top-down queries, we specify sub-s-graphs in terms of their s-component representations. The number I of instances of each rule type is the same as in the bottom-up case because of the one-to- one correspondence of s-component and bound- ary representations. We focus on merge and forget queries; rename is as above.</p><p>Merge. Given an s-component representation C = (C, φ), a top-down merge query asks us to enumerate the rules C → || (C 1 , C 2 ) such that T (C 1 ) || T (C 2 ) = T (C). By Lemma 1, we can do this by using every distribution of the s- components in C over C 1 and C 2 and restricting φ accordingly. This brings the per-rule time of top- down merge to O(ds), the maximum number of s-components in C.</p><p>Block-cutpoint graphs. The challenging query to answer top-down is forget. We will first de- scribe the problem and introduce a data structure that supports efficient top-down forget queries.</p><p>Consider top-down forget queries on the sub-s-graph SG 1 drawn in bold in <ref type="figure" target="#fig_1">Fig. 2(a)</ref> By contrast, the same top-down forget might also promote the node 1 to a C-source, yield- ing a sub-s-graph</p><formula xml:id="formula_14">SG 3 ; f C (SG 3 ) is also SG 1 . However, all edges in [a] are still equiva- lent in SG 3 ; its s-component representation is {[a], [g]}, {A:4, B:5, C:1}}.</formula><p>An algorithm for top-down forget must be able to determine whether promotion of a node splits an s-component or not. To do this, let G be the in- put graph. We create an undirected auxiliary graph G U from G and a set U of (source) nodes. G U contains all nodes in V \U , and for each edge e that is incident to a node u ∈ U , it contains a node (u, e). Furthermore, G U contains undirected ver- sions of all edges in G; if an edge e ∈ E is incident to a node u ∈ U , it becomes incident to (u, e) in G U instead. The auxiliary graph G {4,5} for our example graph is shown in <ref type="figure" target="#fig_1">Fig. 2(d)</ref>.</p><p>Two edges are connected in G U if and only if they are equivalent with respect to U in G. There- fore, promotion of u splits s-components iff u is a cutpoint in G U , i.e. a node whose removal discon- nects the graph. Cutpoints can be characterized as those nodes that belong to multiple biconnected components (BCCs) of G U , i.e. the maximal sub- graphs such that any node can be removed without disconnecting a graph segment. In <ref type="figure" target="#fig_1">Fig. 2(d)</ref>, the BCCs are indicated by the dotted boxes. Observe that 3 is a cutpoint and 1 is not.</p><p>For any given U , we can represent the structure of the BCCs of G U in its block-cutpoint graph. This is a bipartite graph whose nodes are the cut- points and BCCs of G U , and a BCC is connected to all of its cutpoints; see <ref type="figure" target="#fig_1">Fig. 2(e)</ref> for the block- cutpoint graph of the example. Block-cutpoint graphs are always forests, with the individual trees representing the s-components of G. Promoting a cutpoint u splits the s-component into smaller parts, each corresponding to an incident edge of u. We annotate each edge with that part.</p><p>Forget. We can now answer a top-down forget query C → f A (C ) efficiently from the block- cutpoint graph for the sources of C = (C, φ). We iterate over all components c ∈ C, and then over all internal nodes u of c. If u is not a cutpoint, we simply let C = (C , φ ) by making u an A- source and letting C = C. Otherwise, we also remove c from C and add the new s-components on the edges adjacent to u in the block-cutpoint graph. The query returns rules for all C that can be constructed like this.</p><p>The per-rule runtime of top-down forget is O(ds), the time needed to compute C in the cut- point case. We furthermore precompute the block- cutpoint graphs for the input graph with respect to all sets U ⊆ V of nodes with |U | ≤ s − 1. For each U , we can compute the block-cutpoint graph and annotate its edges in time O(nd 2 s). Thus the total time for the precomputation is O(n s · d 2 s), which amortizes to O(1) per rule.</p><p>Top-down versus bottom-up. <ref type="figure">Fig. 5</ref> compares the performance of the top-down and the bottom- up algorithm, on a grammar with three source names sampled from all 1261 graphs with up to 10 nodes. Each point in the figure is the geometric mean of runtimes for all graphs with a given num- ber of nodes; note the log-scale. We aborted the top-down parser after its runtimes grew too large.</p><p>We observe that the bottom-up algorithm out- performs the top-down algorithm, and yields prac- tical runtimes even for nontrivial graphs. One pos- sible explanation for the difference is that the top- down algorithm spends more time analyzing un- grammatical s-graphs, particularly subgraphs that are not connected.</p><p>Comparison to Bolinas. We also compare our implementations to Bolinas. Because Bolinas is much slower than Alto, we restrict ourselves to two source names (= treewidth 1) and sampled the grammar from 30 randomly chosen AMRs each of size 2 to 8, plus the 21 AMRs of size one. <ref type="figure">Fig. 6</ref> shows the runtimes. Our parsers are generally much faster than in <ref type="figure">Fig. 5</ref>, due to the decreased number of sources and grammar size. They are also both much faster than Bolinas. Mea- suring the total time for parsing all 231 AMRs, our bottom-up algorithm outperforms Bolinas by a factor of 6722. The top-down algorithm is slower, but still outperforms Bolinas by a factor of 340.</p><p>Further analysis. In practice, memory use can be a serious issue. For example, the decomposi- tion grammar for s=3 for AMR #194 in the corpus has over 300 million rules. However, many uses of decomposition grammars, such as sampling for grammar induction, can be phrased purely in terms of top-down queries. The top-down algorithm can answer these without computing the entire gram- mar, alleviating the memory problem.</p><p>Finally, we analyzed the asymptotic runtimes in <ref type="table">Table 1</ref> in terms of the maximum number d · s of in-boundary edges. However, the top-down parser does not manipulate individual edges, but entire s-components. The maximum number D s of s- components into which a set of s sources can split a graph is called the s-separability of G by <ref type="bibr" target="#b13">Lautemann (1990)</ref>. We can analyze the runtime of the top-down parser more carefully as O(n s 3 Ds ds); as the dotted line in <ref type="figure">Fig. 5</ref> shows, this predicts the runtime well. Interestingly, D s is much lower in practice than its theoretical maximum. In the   "Little Prince" AMR-Bank, the mean of D 3 is 6.0, whereas the mean of 3 · d is 12.7. Thus exploit- ing the s-component structure of the graph can im- prove parsing times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We presented two new graph parsing algorithms for s-graph grammars. These were framed in terms of top-down and bottom-up queries to a de- composition grammar for the HR algebra. Our implementations outperform Bolinas, the previ- ously best system, by several orders of magnitude. We have made them available as part of the Alto parser. A challenge for grammar-based semantic pars- ing is grammar induction from data. We will ex- plore this problem in future work. Furthermore, we will investigate methods for speeding up graph parsing further, e.g. with different heuristics.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: (a) An s-graph with (b,c) some sub-sgraphs, (d) its BCCs, and (e) its block-cutpoint graph.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>we can reach f from an endpoint of e without visiting a node in U . We call the equivalence classes of E with respect to ∼ U the s-components of G and denote the s- component that contains an edge e with [e]. In Fig. 2(a), the edges a and f are equivalent with respect to U = {4, 5}, but a and h are not. The s- components are [a] = {a, b, c, d, e, f }, [g] = {g}, and [h] = {h}.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: An example s-graph grammar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: An HRG rule (left) with one of its tree decompositions (right).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>; its s-component representation is {[a], [g]}, {A:4, B:5}}. A top-down forget might promote the node 3 to a C-source, yielding a sub-s-graph SG 2 (that is, f C (SG 2 ) is the orig- inal s-graph SG 1 ). In SG 2 , a, e, and f are no longer equivalent; its s-component repre- sentation is {[a], [e], [f ], [g]}, {A:4, B:5, C:3}}. Thus promoting 3 to a source splits the original s-component into smaller parts.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :Figure 6 :</head><label>56</label><figDesc>Figure 5: Runtimes of our parsers with s = 3.</figDesc></figure>

			<note place="foot" n="2"> This uses the swap operations mentioned in Footnote 1.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Evaluation</head><p>We evaluate the performance of our algorithms on the "Little Prince" AMR-Bank version 1.4, avail-able from amr.isi.edu. This graph-bank con-sists of 1562 sentences manually annotated with AMRs. We implemented our algorithms in Java as part of the Alto parser for IRTGs <ref type="bibr">(Alto Developers, 2015)</ref>, and compared them to the Bolinas HRG parser ( ). We measured runtimes using Java 8 (for Alto) and Pypy 2.5.0 (for Bolinas) on an Intel Xeon E7-8857 CPU at 3 GHz, after warming up the JIT compilers.</p><p>As there are no freely available grammars for this dataset, we created our own for the evalua-tion, using Bayesian grammar induction roughly along the lines of <ref type="bibr" target="#b4">Cohn et al. (2010)</ref>. We pro-vide the grammars as supplementary material. Around 64% of the AMRs in the graph-bank have treewidth 1 and can thus be parsed using s = 2 source names. 98% have treewidth 1 or 2, corre-sponding to s = 3 source names. All experiments evaluated parser times on the same AMRs from which the grammar was sampled. Acknowledgments. We thank the anonymous reviewers for their comments, and Daniel Bauer for his help with Bolinas. We received valuable feedback at the 2015 Dagstuhl seminar on graph grammars and the 2014 Johns Hopkins workshop in Prague. This work was supported by the DFG grant KO 2916/2-1.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Alto: algebraic language toolkit for parsing and decoding with IRTGs</title>
		<ptr target="https://bitbucket.org/tclup/alto" />
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
	<note>Alto Developers</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Bolinas graph processing package</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Moritz</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bevan</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
		<ptr target="http://www.isi.edu/publications/licensed-sw/bolinas/.Downloadedin" />
		<imprint>
			<date type="published" when="2013-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Abstract meaning representation for sembanking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Banarescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Bonial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madalina</forename><surname>Georgescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kira</forename><surname>Griffitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martha</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Linguistic Annotation Workshop &amp; Interoperability with Discourse</title>
		<meeting>the 7th Linguistic Annotation Workshop &amp; Interoperability with Discourse</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="178" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parsing graphs with hyperedge replacement grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Chiang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Moritz</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bevan</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 51st Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 51st Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="924" to="932" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Inducing tree-substitution grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Trevor</forename><surname>Cohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Phil</forename><surname>Blunsom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharon</forename><surname>Goldwater</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Machine Learning Research (JMLR)</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="3053" to="3096" />
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hubert</forename><surname>Comon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><surname>Dauchet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rémi</forename><surname>Gilleron</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florent</forename><surname>Jacquemard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Denis</forename><surname>Lugiez</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christof</forename><surname>Löding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sophie</forename><surname>Tison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Tommasi</surname></persName>
		</author>
		<ptr target="http://tata.gforge.inria.fr/" />
		<title level="m">Tree automata techniques and applications</title>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruno</forename><surname>Courcelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joost</forename><surname>Engelfriet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ume 138 of Encyclopedia of Mathematics and its Applications</title>
		<imprint>
			<publisher>Cambridge University Press</publisher>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Handbook of Graph Grammars and Computing by Graph Transformation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frank</forename><surname>Drewes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hans-Jörg</forename><surname>Kreowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Annegret</forename><surname>Habel</surname></persName>
		</author>
		<editor>Grzegorz Rozenberg</editor>
		<imprint>
			<date type="published" when="1997" />
			<publisher>World Scientific Publishing Co., Inc</publisher>
			<biblScope unit="page" from="95" to="162" />
		</imprint>
	</monogr>
	<note>Hyperedge replacement graph grammars</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A discriminative graph-based parser for the abstract meaning representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Flanigan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Thomson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jamie</forename><surname>Carbonell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 52nd Annual Meeting of the Association for Computational Linguistics<address><addrLine>Baltimore, Maryland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1426" to="1436" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Semantics-Based machine translation with hyperedge replacement grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bevan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Andreas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Moritz</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Hermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of COLING 2012: Technical Papers</title>
		<meeting>COLING 2012: Technical Papers</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1359" to="1376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A generalized view on parsing and translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th International Conference on Parsing Technologies</title>
		<meeting>the 12th International Conference on Parsing Technologies</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="2" to="13" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Semantics construction with graph grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Koller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 11th International Conference on Computational Semantics (IWCS)</title>
		<meeting>the 11th International Conference on Computational Semantics (IWCS)</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="228" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Decomposition trees: Structured graph representation and efficient algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clemens</forename><surname>Lautemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">13th Colloquium on Trees in Algebra and Programming</title>
		<editor>Max Dauchet and Maurice Nivat</editor>
		<meeting><address><addrLine>Berlin Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1988" />
			<biblScope unit="volume">299</biblScope>
			<biblScope unit="page" from="28" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The complexity of graph languages generated by hyperedge replacement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clemens</forename><surname>Lautemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Acta Informatica</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="page" from="399" to="421" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Priberam: A turbo semantic parser with second order features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">T</forename><surname>André</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mariana</forename><forename type="middle">S C</forename><surname>Martins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Almeida</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Semantic Evaluation</title>
		<meeting>the 8th International Workshop on Semantic Evaluation</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="471" to="476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Broad-coverage semantic dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Oepen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Miyao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Zeman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Flickinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Hajic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Angelina</forename><surname>Ivanova</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Semantic Evaluation</title>
		<meeting>the 8th International Workshop on Semantic Evaluation</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="63" to="72" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">DAGGER: A toolkit for automata on directed acyclic graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Quernheim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 10th International Workshop on Finite State Methods and Natural Language Processing</title>
		<meeting>the 10th International Workshop on Finite State Methods and Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="40" to="44" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Principles and implementation of deductive parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stuart</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><surname>Shieber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><forename type="middle">C N</forename><surname>Schabes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Logic Programming</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">1-2</biblScope>
			<biblScope unit="page" from="3" to="36" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
