<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T10:27+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Dependency Parsing with Bounded Block Degree and Well-nestedness via Lagrangian Relaxation and Branch-and-Bound</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>August 7-12, 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caio</forename><surname>Corro</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique de Paris Nord</orgName>
								<orgName type="laboratory" key="lab2">UMR 7030</orgName>
								<orgName type="institution" key="instit1">Université Paris 13 -SPC</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-93430</postCode>
									<settlement>Villetaneuse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><surname>Le Roux</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique de Paris Nord</orgName>
								<orgName type="laboratory" key="lab2">UMR 7030</orgName>
								<orgName type="institution" key="instit1">Université Paris 13 -SPC</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-93430</postCode>
									<settlement>Villetaneuse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathieu</forename><surname>Lacroix</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique de Paris Nord</orgName>
								<orgName type="laboratory" key="lab2">UMR 7030</orgName>
								<orgName type="institution" key="instit1">Université Paris 13 -SPC</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-93430</postCode>
									<settlement>Villetaneuse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Antoine</forename><surname>Rozenknop</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique de Paris Nord</orgName>
								<orgName type="laboratory" key="lab2">UMR 7030</orgName>
								<orgName type="institution" key="instit1">Université Paris 13 -SPC</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-93430</postCode>
									<settlement>Villetaneuse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roberto</forename><forename type="middle">Wolfler</forename><surname>Calvo</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory" key="lab1">Laboratoire d&apos;Informatique de Paris Nord</orgName>
								<orgName type="laboratory" key="lab2">UMR 7030</orgName>
								<orgName type="institution" key="instit1">Université Paris 13 -SPC</orgName>
								<orgName type="institution" key="instit2">CNRS</orgName>
								<address>
									<postCode>F-93430</postCode>
									<settlement>Villetaneuse</settlement>
									<country key="FR">France</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Dependency Parsing with Bounded Block Degree and Well-nestedness via Lagrangian Relaxation and Branch-and-Bound</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
						<meeting>the 54th Annual Meeting of the Association for Computational Linguistics <address><addrLine>Berlin, Germany</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page" from="355" to="366"/>
							<date type="published">August 7-12, 2016</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We present a novel dependency parsing method which enforces two structural properties on dependency trees: bounded block degree and well-nestedness. These properties are useful to better represent the set of admissible dependency structures in treebanks and connect dependency parsing to context-sensitive grammatical formalisms. We cast this problem as an Integer Linear Program that we solve with La-grangian Relaxation from which we derive a heuristic and an exact method based on a Branch-and-Bound search. Experimentally , we see that these methods are efficient and competitive compared to a base-line unconstrained parser, while enforcing structural properties in all cases.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>We address the problem of enforcing two struc- tural properties on dependency trees, namely bounded block degree and well-nestedness, with- out sacrificing algorithmic efficiency. Intuitively, bounded block degree constraints force each sub- tree to have a yield decomposable into a lim- ited number of blocks of contiguous words, while well-nestedness asserts that every two distinct sub- trees must not interleave: either the yield of one subtree is entirely inside some gap of the other or they are completely separated. These two types of constraints generalize the notion of projectiv- ity: projective trees actually have a block degree bounded to one and are well-nested.</p><p>Our first motivation is the fact that most de- pendency trees in NLP treebanks are well-nested and have a low block degree which depends on the language and the linguistic representation, as shown in <ref type="bibr" target="#b28">(Pitler et al., 2012</ref>). Unfortunately, al- though polynomial algorithms exist for this class of trees ( <ref type="bibr" target="#b9">Gómez-Rodríguez et al., 2009</ref>), they are not efficient enough to be of practical use in ap- plications requiring syntactic structures. In ad- dition, if either property is dropped, but not the other, then the underlying decision problem be- comes harder. That is why practical parsing algo- rithms are either completely unconstrained <ref type="bibr" target="#b23">(McDonald et al., 2005</ref>) or enforce strict projectivity ( . This work is, to the best of our knowledge, the first attempt to build a discriminative dependency parser that enforces well-nestedness and/or bounded block degree and to use it on treebank data.</p><p>We base our method on the following obser- vation: a non-projective dependency parser, thus not requiring neither well-nestedness nor bounded block degree, returns dependency trees satisfying these constraints in the vast majority of sentences. This would tend to indicate that the heavy machin- ery involved to parse with these constraints is only needed in very few cases.</p><p>We consider arc-factored dependency parsing with well-nestedness and bounded block degree constraints. We formulate this problem as an In- teger Linear Program (ILP) and apply Lagrangian Relaxation where the dualized constraints are those associated with bounded block degree and well-nestedness. The Lagrangian dual objective then reduces to a maximum spanning arbores- cence and can be solved very efficiently. This pro- vides an efficient heuristic for our problem. An ex- act method can be derived by embedding this La- grangian Relaxation in a Branch-and-Bound pro- cedure to solve the problem with an optimality cer- tificate. Despite the exponential worst-time com- plexity of the Branch-and-Bound procedure, it is tractable in practice. Our formulation can enforce both types of constraints or only one of them with- out changing the resolution method.</p><p>As stated in ( <ref type="bibr">Bodirsky et al., 2009)</ref>, well-nested dependency trees with 2-bounded block degree are structurally equivalent to derivations in Lexical- ized Tree Adjoining Grammars (LTAGs) <ref type="bibr" target="#b13">(Joshi and Schabes, 1997)</ref>. <ref type="bibr">12</ref> While LTAGs can be parsed in polynomial time, developing an efficient parser for these grammars remains an open prob- lem <ref type="bibr" target="#b4">(Eisner and Satta, 2000</ref>) and we believe that this work could be a useful step in that direction.</p><p>Related work is reviewed in Section 2. We de- fine arc-factored dependency parsing with block degree and well-nestedness constraints in Sec- tion 3. We derive an ILP formulation of this prob- lem in Section 4 and then present our method based on Lagrangian Relaxation in Section 5 and Branch-and-Bound in Section 6. Section 7 con- tains experimental results on several languages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>A dynamic programming algorithm has been pro- posed for parsing well-nested and k-bounded block degree dependency trees in ( <ref type="bibr" target="#b9">GómezRodríguez et al., 2009;</ref><ref type="bibr" target="#b10">Gómez-Rodríguez et al., 2011</ref>). Unfortunately, it has a prohibitive O(n 3+2k ) time complexity, equivalent to Lexi- calized TAG parsing when k = 2. Variants of this algorithm have also been proposed for further restricted classes of dependency trees: 1-inherit (O(n 6 )) <ref type="bibr" target="#b28">(Pitler et al., 2012</ref>), head-split (O(n 6 )) (Satta and <ref type="bibr" target="#b32">Kuhlmann, 2014</ref>) and both 1-inherit and head-split (O(n 5 )) (Satta and <ref type="bibr" target="#b32">Kuhlmann, 2014)</ref>. Although those restricted classes have good empirical coverage, they do not cover the exact search space of Lexicalized TAG deriva- tion and their time complexity is still prohibitive. Spinal TAGs, described as a dependency parsing task in <ref type="bibr">(Carreras et al., 2008)</ref>, weaken even more the empirical coverage in practice, restricted to projective trees, but still remain hardly tractable with a complexity of O(n 4 ). On the contrary, the present work does not restrict the search space.</p><p>Parsing mildly context-sensitive languages with dependencies has been explored in <ref type="bibr">(FernándezGonzález and Martins, 2015</ref>) but the resulting parser cannot guarantee compliance with strict structural properties. On the other hand, the 1 It is possible to express a wider class of dependencies with LTAG if we allow dependencies direction to be different from the derivation tree <ref type="bibr" target="#b13">(Kallmeyer and Kuhlmann, 2012)</ref>. <ref type="bibr">2</ref> In order to be fully compatible with LTAGs, we must ensure that the root has only one child. For algorithmic issues see <ref type="bibr" target="#b7">(Fischetti and Toth, 1992)</ref> or ( <ref type="bibr" target="#b8">Gabow and Tarjan, 1984)</ref>. present method enforces the well-nestedness and bounded block degree of solutions.</p><p>The methods mentioned above all use the graph-based approach and rely on dynamic pro- gramming to achieve tractability. There is also a line of of work in transition-based parsing for various dependency classes. Systems have been proposed for projective dependency trees <ref type="bibr" target="#b26">(Nivre, 2003)</ref>, non-projective, or even unknown classes <ref type="bibr" target="#b1">(Attardi, 2006</ref>). <ref type="bibr" target="#b27">Pitler and McDonald (2015)</ref> pro- pose a transition system for crossing interval trees, a more general class than well-nested trees with bounded block degree. In the case of spinal TAGs, we can mention the work of <ref type="bibr" target="#b2">Ballesteros and Carreras (2015)</ref> and <ref type="bibr" target="#b35">Shen and Joshi (2007)</ref>. Transition-based algorithms offer low space and time complexity, typically linear in the length of sentences usually by relying on local predictors and beam strategies and thus do not provide any optimality guarantee on the produced structures. The present work follows the graph-based ap- proach, but replaces dynamic programming with a greedy algorithm and Lagrangian Relaxation.</p><p>The use of Lagrangian Relaxation to elaborate sophisticated parsing models based on plain max- imum spanning arborescence solutions originated in (  where this method was used to parse with higher-order features. This technique has been explored to parse CCG dependencies in ( <ref type="bibr" target="#b3">Du et al., 2015</ref>) without a precise definition of the class of trees. We can also draw connections between our problem reduction procedure and the use of Lagrangian Relaxation to speed up dynamic programming and beam search with exact pruning in ( <ref type="bibr" target="#b32">Rush et al., 2013)</ref>.</p><p>In this work we rely on Non-Delayed Relax- and-Cut for lazy constraint generation <ref type="bibr" target="#b19">(Lucena, 2006</ref>). This can be linked to <ref type="bibr" target="#b31">(Riedel, 2009)</ref> which uses a cutting plane algorithm to solve MAP in- ference in Markov Logic and (  which uses column and row generation for higher- order dependency parsing.</p><p>In NLP, the Branch-and-Bound framework <ref type="bibr" target="#b16">(Land and Doig, 1960</ref>) has previously been used for dependency parsing with high order features in <ref type="bibr" target="#b29">(Qian and Liu, 2013)</ref>, and <ref type="bibr" target="#b2">Das et al. (2012)</ref> combined Branch-and-Bound to Lagrangian Re- laxation in order to retrieve integral solutions for shallow semantic parsing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>356</head><p>We model the dependency parsing problem using a graph-based approach. Given a sentence s = s 0 , . . . , s n where s 0 is a dummy root symbol, we consider the directed graph D = (V, A) with V = {0, . . . n} and A ⊆ V × V . Vertex i ∈ V corresponds to word s i and arc (i, j) ∈ A models a dependency from word s i to word s j . In the rest of the paper, we denote V \ {0} by V + .</p><p>An arborescence is a set of arcs T inducing a connected graph with no circuit such that every vertex has at most one entering arc. The set of vertices incident with any arc of T is denoted by</p><formula xml:id="formula_0">V [T ]. If V [T ] = V , then T is a spanning arbores- cence. Among the vertices of V [T ]</formula><p>, the one with no entering arc is called the root of T . A vertex t is reachable from a vertex s with respect to T if there exists a path from s to t using only arcs of T . The yield of a vertex v ∈ V corresponds to the set of vertices reachable from v with respect to T .</p><p>It is well-known that there is a bijection be- tween dependency trees for s and spanning ar- borescences with root 0 ( <ref type="bibr" target="#b23">McDonald et al., 2005</ref>). In what follows, the term dependency tree will re- fer to both the dependency tree of s and its associ- ated spanning arborescence of D with root 0.</p><p>In the dependency parsing problem, one has to find a dependency tree with maximal score. Sev- eral scores can be associated with each depen- dency tree and different conditions can restrict the set of valid dependency trees.</p><p>In this paper, we consider an arc-factored model: each arc (i, j) ∈ A is assigned a score w ij ; the score of a dependency tree is defined as the sum of the scores of the arcs it con- tains. This model can be computed in O(n 2 ) with Chu-Liu-Edmonds' algorithm for Maximum Spanning Arborescence (MSA) <ref type="bibr" target="#b23">(McDonald et al., 2005</ref>). Unfortunately, this algorithm forbids any modification of the score function, for example adding score contribution for combinations of arcs (i.e. grand-parent or sibling models). Moreover, adding score contribution for combinations of cou- ple of arcs makes the problem NP-hard <ref type="bibr" target="#b22">(McDonald and Pereira, 2006</ref>), although several methods have been developed to tackle this problem, for instance dual decomposition ( .</p><p>Likewise, restrictions on the tree structure such as the well-nestedness and bounded block degree conditions are not permitted in the MSA algo- rithm. We first give a precise definition of these structural properties, equivalent to ( <ref type="bibr">Bodirsky et al., 2009)</ref>, before we present a method to take them into account. From now on, we suppose that in- stances are equipped with a positive integer k and we call valid dependency trees those satisfying the k-bounded block degree and well-nestedness con- ditions. A graph-theoretic definition of these two conditions can be given as follows.</p><p>Block degree The block degree of a vertex set W ⊆ V is the number of vertices of W without a predecessor 3 inside W . Given an arborescence T , the block degree of a vertex is the block degree of its yield and the block degree of T is the maximum block degree of its incident vertices. An arbores- cence satisfies the k-bounded block degree condi- tion if its block degree is less than or equal to k.</p><p>We then say it is k-BBD for short. <ref type="figure" target="#fig_0">Figure 1</ref> (left) gives an example of a 2-BBD arborescence.</p><p>Well-nestedness Two disjoint subsets I 1 , I 2 ⊂ V + interleave if there exist i, j ∈ I 1 and k, l ∈ I 2 such that i &lt; k &lt; j &lt; l. An arborescence is well-nested if it is not incident to two vertices whose yields interleave. <ref type="figure" target="#fig_0">Figure 1</ref> (right) shows an arborescence which is not well-nested.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">ILP Formulation</head><p>In this section we formulate the dependency pars- ing problem described in Section 3 as an ILP. We start with some notation and two theorems charac- terizing k-BBD and well-nested dependency trees. Given a subset W ⊆ V , the set of arcs en- tering W is denoted by δ in (W ) and the set of arcs leaving W is denoted by δ out (W ). The set δ(W ) = δ in (W )∪δ out (W ) is called the cut of W . Given a positive integer l, let W ≥l be the family of vertex subsets of V + with block degree greater than or equal to l. For instance, given any sen- tence with more than 6 words, {1, 3, 5, 6} ∈ W ≥3 , while {1, 2, 5, 6} ∈ W ≥3 . We also denote by I the family of couples of disjoint interleaving ver- tex subsets of V + . For instance, ({1, 4}, {2, 3, 5}) belongs to I. Finally, given a vector x ∈ R A and a subset B ⊆ A, x(B) corresponds to a∈B x a . Theorem 1. A dependency tree T is not k-BBD iff there exists a vertex subset W ∈ W ≥k+1 whose cut δ(W ) contains a unique arc of T .</p><p>Proof. By definition of block degree, a depen- dency tree is not k-BBD iff it is incident with a vertex whose yield W belongs to W ≥k+1 . It is equivalent to say that T contains a subarbores- cence T such that V [T ] equals W . This holds iff W has one entering arc (since 0 / ∈ W ) and no leaving arc belonging to T . Theorem 2. A dependency tree T is not well- nested iff there exists (I 1 , I 2 ) ∈ I such that δ(I 1 ) ∩ T and δ(I 2 ) ∩ T are singletons.</p><p>Proof. δ(I 1 ) and δ(I 2 ) both intersect T only once iff T contains two arborescences T 1 and T 2 such that V [T 1 ] = I 1 and V [T 2 ] = I 2 . This means that T is incident with two vertices whose yields are I 1 and I 2 , respectively. Result follows from the definition of I and well-nested arborescences.</p><p>The dependency parsing problem can be formu- lated as follows. A dependency tree will be repre- sented by its incidence vector. Hence, we use vari- ables z ∈ R A such that z a = 1 if arc a belongs to the dependency tree and 0 otherwise.</p><formula xml:id="formula_1">max z a∈A w a z a (1) z(δ in (v)) = 1 ∀v ∈ V + (2) z(δ in (W )) ≥ 1 ∀W ⊆ V + (3) z(δ(W )) ≥ 2 ∀ W ∈ W ≥k+1 (4) z(δ(I 1 )) + z(δ(I 2 )) ≥ 3 ∀(I 1 , I 2 ) ∈ I (5) z ∈ {0, 1} A<label>(6)</label></formula><p>The objective function (1) maximizes the score of the dependency tree. Inequalities (2) ensure that all vertices but the root have one entering arc. In- equalities (3) force the set of arcs associated with z to induce a connected graph. Inequalities (2) and (3), together with z ≥ 0, give a linear descrip- tion of the convex hull of the incidence vectors of the spanning arborescences with root 0 -see e.g., <ref type="bibr" target="#b33">(Schrijver, 2003)</ref>. Inequalities (4) ensure that the dependency tree is k-BBD and inequalities (5) im- pose well-nestedness. The validity of <ref type="formula">(4)</ref> and <ref type="formula">(5)</ref> follows from Theorems 1 and 2, respectively. Remark that (3) could be replaced by a polyno- mial number of additional flow variables and con- straints, see <ref type="bibr" target="#b20">(Martins et al., 2009</ref>). <ref type="bibr">4</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Lagrangian Relaxation</head><p>Solving this ILP using an off-the-shelf solver is ineffective due to the huge number of constraints. We tackle this problem with Lagrangian Relax- ation, which has become popular in the NLP com- munity, see for instance <ref type="bibr" target="#b31">(Rush and Collins, 2012)</ref>. Note that contrary to most previous work on La- grangian Relaxation for NLP, we do not use it to derive a decomposition method.</p><p>We note that optimizing objective (1) subject to constraints (2), (3) and (6) amounts to finding a MSA and can be solved combinatorially <ref type="bibr" target="#b23">(McDonald et al., 2005</ref>). Thus, since formulation (1)- <ref type="formula" target="#formula_1">(6)</ref> is based only on arc variables, by relaxing con- straints (4) and <ref type="formula">(5)</ref>, one obtains a Lagrangian dual objective which is nothing but a MSA problem with reparameterized arc scores. Our Lagrangian approach relies on a subgradient descent where a MSA problem is solved at each iteration. We give more details in the rest of the section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Dual Problem</head><p>Let Z be the set of the incidence vectors of depen- dency trees. Keeping tree shape constraints (2), (3) and (6) while dualizing k-bounded block degree constraints (4) and well-nestedness constraints (5), we build the following Lagrangian <ref type="bibr" target="#b17">(Lemaréchal, 2001)</ref>:</p><formula xml:id="formula_2">L(z, u) = a∈A w a z a + W ∈W ≥k u W 1 × (z(δ(W )) − 2) + (I 1 ,I 2 )∈I u I 1 ,I 2 2 × (z(δ(I 1 )) + z(δ(I 2 )) − 3)<label>(7)</label></formula><p>4 Based on this remark, we also developed a formulation of this problem with a polynomial number of variables and constraints. However it requires adding many more variables than ( <ref type="bibr" target="#b20">Martins et al., 2009)</ref>. This leads to a formulation which is not tractable, see Section 7.2. Moreover, it cannot be tack- led by our Lagrangian Relaxation approach.</p><note type="other">with z ∈ Z and u = (u 1 , u 2 ) ≥ 0 is a vector of Lagrangian multipliers. We refactor to:</note><formula xml:id="formula_3">L(z, u) = a∈A θ a z a + c<label>(8)</label></formula><p>where θ are modified scores and c a constant term. The dual objective is L * (u) = max z L(z, u) with z ∈ Z. Note that computing L * (u) amounts to solving the MSA problem with modified scores θ and can be efficiently computed. The dual prob- lem is min u≥0 L * (u). L * is a non-differentiable convex piece-wise linear function and one can find its minimum via subgradient descent. For any vec- tor u, we use the following subgradient. Denote M z ≤ b the set of constraints given by (4) and <ref type="formula">(5)</ref> and z * = arg max z L(z, u). Let g = b − M z * be a subgradient at u, see <ref type="bibr" target="#b17">(Lemaréchal, 2001</ref>) for more details. From this subgradient, we compute the descent direction following <ref type="bibr">(Camerini et al., 1975)</ref>, which aggregates information during the it- eration of the subgradient descent algorithm. Un- fortunately, optimizing the dual is expensive with so many relaxed constraints. We handle this prob- lem in the next subsection.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Efficient Optimization with Many Constraints</head><p>The Non Delayed Relax-and-Cut (NDRC) method <ref type="bibr" target="#b18">(Lucena, 2005</ref>) tackles the problem of optimiz- ing a Lagrangian dual problem with exponentially many relaxed constraints. In standard subgradient descent, at each iteration p of the descent, the La- grangian update can be formulated as:</p><formula xml:id="formula_4">u p+1 = (u p − s p × g p ) +<label>(9)</label></formula><p>where s p &gt; 0 is the stepsize 5 and () + denotes the projection onto R + , which replaces each nega- tive component by 0. If all Lagrangian multipliers are initialized to 0, the compononent correspond- ing to a constraint will not be changed until this constraint is violated for the first time. Indeed, by definition of g, we have [g p ] i ≥ 0 if constraint i is satisfied at iteration p: the projection on R + en- sure that [u p+1 ] i stays at 0. 6 Thus we do not need to know constraints that have not been violated yet in order to correctly update the Lagrangian multi- pliers: this is the main intuition behind the NDRC method. However, s p may depend on the full sub- gradient information. A common step size <ref type="bibr" target="#b8">(Fisher, 1981)</ref> is:</p><formula xml:id="formula_5">s p = α p × L * (u p ) − LB p g p 2<label>(10)</label></formula><p>with α p a scalar and LB p the best known lower bound. This is also the case with more recent ap- proaches like AdaGrad (Duchi et al., 2011) and AdaDelta <ref type="bibr" target="#b38">(Zeiler, 2012)</ref>. As reported in <ref type="bibr">(Beasley, 1993;</ref><ref type="bibr" target="#b19">Lucena, 2006</ref>), when dealing with many re- laxed constraints, the g p 2 term can result in each Lagrangian update being almost equal to 0. There- fore, a good practice is to modify the subgradient such that if</p><formula xml:id="formula_6">[g p ] i &gt; 0 and [u p ] i = 0, then we set [g p ] i = 0:</formula><p>this has the same effect on the multipli- ers as the projection on R + in (9), but it prevents the stepsize from becoming too small. Hence, in- stead of generating a full subgradient at each it- eration, which is an expensive operation because we would need to consider all multipliers associ- ated with constraints, we process only a subpart, namely the one associated with constraints that have been violated. Following <ref type="bibr" target="#b18">(Lucena, 2005)</ref>, at each iteration p of the subgradient descent we define two sets: Cur- rently Violated Active Constraints (CA p ) and Pre- viously Violated Active Constraints (PA p ). CA p and PA p are not necessarily disjoint. The subgra- dient is computed only for constraints in CA p ∪ PA p . At each iteration p, we update PA p = PA p−1 ∪ CA p−1 and a violation detection step, similar to the separation step in a cutting plane al- gorithm, generates CA p . Two strategies are pos- sible for the detection: (1) adding to CA p all the constraints violated by the current dual solution; (2) adding only a subset of them. The latter is jus- tified by the fact that many constraints may over- lap thus leading to exageration of modified scores on some arcs. We found that strategy (2) gives bet- ter convergence results.</p><p>Detection for violated block degree con- straints (4) can be done with the algorithm de- scribed in <ref type="bibr">(Möhl, 2006</ref>) in O(n 2 ). If no violated block degree constraint is found, we search for violated well-nestedness constraints (5) using the O(n 2 ) algorithm described in <ref type="bibr" target="#b11">(Havelka, 2007)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Lagrangian Heuristic</head><p>We derive a heuristic from the Lagragian Relax- ation. First, a dependency tree is computed with the MSA algorithm. If it is valid, it then corre- sponds to the optimal solution. Otherwise, we pro- ceed as follows. The computation of the step size in (10) in the subgradient descent needs a lower bound which can be given by the score of any valid dependency tree. In our experiments, we compute the best projective spanning arborescence . Each iteration of the subgradient descent computes a spanning arborescence. Since violat- ing (4) and <ref type="formula">(5)</ref> is penalized in the objective func- tion, it tends to produce valid dependency trees. The heuristic returns the highest scoring one.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Branch and Bound</head><p>Solving the Lagrangian dual problem may not al- ways give an optimal solution to the original prob- lem because of the potential duality gap. Still, we always obtain an upper bound on the optimal so- lution and if a dual solution satisfies constraints (4) and <ref type="formula">(5)</ref>, its score with the original weights pro- vides a lower bound. <ref type="bibr">7</ref> Moreover, the subgradient descent algorithm theoretically converges but we have no guarantee that this will happen in a realistic number of itera- tions. Therefore, in order to retrieve an optimal solution in all cases, we embed the Lagrangian Relaxation of the problem within a Branch-and- Bound procedure <ref type="bibr" target="#b16">(Land and Doig, 1960)</ref>.</p><p>The search space is recursively split according to an arc variable, creating two subspaces, one where it is fixed to 1 and the other to 0 (branching step). The procedure returns a candidate solution when all arc variables are fixed and constraints are satisfied, and the optimal solution is the highest- scoring candidate solution.</p><p>For each subspace, we estimate an upper bound using the Lagrangian Relaxation (bounding step). The recursive exploration of a subspace stops (pruning step) if (1) we can prove that all candi- date solutions it contains have a score lower than the best found so far, or (2) we detect an unsastifi- able constraint.</p><p>The branching strategy is built upon Lagrangian multipliers: we branch on the variable z a with highest value θ a − w a . Intuitively, if the branching step sets z a = 1, it indicates that we add a hard constraint on an arc which has been strongly pro- moted by Lagrangian Relaxation. This strategy, compared to other variants, gave the best parsing <ref type="bibr">7</ref> Because relaxed constraints are inequalities, constraint satisfaction does not guarantee optimality <ref type="bibr">(Beasley, 1993)</ref>. time on development data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Problem Reduction</head><p>The efficiency of the Branch-and-Bound proce- dure crucially depends on the number of free vari- ables. To prune the search space, we rely on prob- lem reduction <ref type="bibr">(Beasley, 1993)</ref>, once again based on duality and Lagrangian Relaxation, which pro- vides certificates on optimal variable settings.</p><p>We fix a variable to 1 (resp. 0), and compute an upper bound on the optimal score with this new constraint. If it is lower than the score of the best solution found so far without this constraint, we can guarantee that this variable cannot (resp. must) be in the optimal solution and safely set it to 0 (resp. 1).</p><p>Problem reduction is performed at each node of the Branch-and-Bound tree after computing the upper bound with subgradient descent.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Fixing Variables to 1</head><p>Since a node in V + must have exactly one parent, fixing z ij = 1 for an arc a = (i, j) greatly reduces the problem size, as it will also fix z hj = 0, ∀h = i. Among all arc variables that can be set to 1, promising candidates are the arcs in a solution of the unconstrained MSA and the arcs obtained in a solution after the subgradient descent.</p><p>There are exactly n such arcs in each set of can- didates, so we test fixation for less than 2n vari- ables. In this case, we are ready to pay the price of a quadratic computation for each of these arcs.</p><p>Hence, for each candidate arc we obtain an up- per bound by seeking the (unconstrained) MSA on the graph where this arc is removed. If this upper bound is lower than the score of the best solution found so far, we can safely say that this arc is in the optimal solution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Fixing Variables to 0</head><p>We could apply the same strategy for fixing vari- ables to 0. However, this reduction is less reward- ing and there are many more variables set to 0 than 1 in a MSA solution. Instead, we solve an easier problem, at the expense of a looser upper bound.</p><p>For each arc a which is not in the MSA, we compute a maximum directed graph that contains this arc and where all nodes but the root have one parent. Remark that if this graph is connected then it corresponds to a dependency tree. Therefore, the score of this directed graph provides an upper bound on a solution containing arc a. If this upper bound is lower than the score of the best solution found so far, we can fix the variable z a to 0.</p><p>Note that this whole fixing procedure can be done in O(n 2 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Experiments</head><p>We ran a series of experiments to test our method in the case of unlabelled dependency parsing. Our prototype has been developped in Python with some parts in Cython and C++. We use the MSA implementation available in the LEMON library. <ref type="bibr">8</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Datasets</head><p>We ran experiments on 5 different corpora:</p><p>English: Dependencies were extracted from the WSJ part of the Penn Treebank (PTB) with addi- tional NP bracketings ( <ref type="bibr" target="#b36">Vadas and Curran, 2007)</ref> with the LTH converter 9 (default options). Sec- tions 02-21 are used for training, 22 for devel- opment and 23 for testing. POS tags were pre- dicted by the Stanford tagger 10 trained with 10- jackkniffing. <ref type="bibr">11</ref> German: We used dependencies from the SPMRL dataset ( <ref type="bibr" target="#b34">Seddah et al., 2014)</ref>, with pre- dicted POS tags and the official split. We removed sentences of length greater than 100 in the test set.</p><p>Dutch, Spanish and Portuguese: We used the Universal Dependency Treebank 1.2 (Van der Beek et al., <ref type="bibr" target="#b24">McDonald et al., 2013;</ref><ref type="bibr" target="#b0">Afonso et al., 2002</ref>) with gold POS tags and the official split. We removed sentences of length greater than 100 in the test sets.</p><p>Those datasets contain different structure dis- tributions as shown in <ref type="table">Table 1</ref>. Fortunately, our method allows us to easily change the bounded de- gree constraint or toggle the well-nestedness one. For each language, we decided to use the most constrained combination of bounded block degree constraints and well-nestedness which covers over 99% of the data. Therefore, we chose to enforce 2-BBD and well-nestedness for English and Span- ish, 3-BBD and well-nestedness for Dutch and Portuguese and 3-BBD only for German.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Decoding</head><p>In order to compare our methods with previous approaches, we tested five decoding strategies.</p><p>(MSA) computes the best unconstrained depen- dency tree. (Eisner) computes the best projec- tive tree. (LR) and (B&amp;B) are the heuristic and the exact method presented in Sections 5.3 and 6 re- spectively. <ref type="bibr">12</ref> Finally (MSA/Eisner) consists in running the MSA algorithm and, if the solution is invalid, returning the (Eisner) solution instead.</p><p>Our attempt to run the dynamic programming algorithm of ( <ref type="bibr" target="#b9">Gómez-Rodríguez et al., 2009</ref>) was unsuccessful. Even with heavy pruning we were not able to run it on sentences above 20 words. We also tried to use CPLEX on a compact ILP formulation based on multi-commodity flows (see footnote 4). Parsing time was also prohibitive: a total of 3473 seconds on English data without the well-nestedness constraint, 7298 for German.</p><p>We discuss the efficiency of our methods on data for English and German. Other languages give similar results. Optimality rate after the sub- gradient descent are reported in <ref type="figure" target="#fig_1">Figure 2</ref>. We see that Lagrangian Relaxation often returns optimal solutions but fails to give a certificate of their op- timality. <ref type="table" target="#tab_1">Table 2</ref> shows parsing times. We see that (LR) and (B&amp;B), while slower than (MSA), are fast in the majority of cases, below the third quartile. Inevitably, there are some rare cases where a large portion of the search space is explored, and thus their parsing time is high. Let us remark that these algorithms are run only when (MSA) returns an in- valid structure, and so total time is very acceptable compared to the baseline.</p><p>Finally, we stress the importance of problem re- duction as a pre-processing step in B&amp;B: after sub- gradient descent is performed, it removes an aver- age of 83.97% (resp. 76.59%) of arc variables in the English test set (resp. German test set).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Training</head><p>Feature weights are trained using the averaged structured perceptron <ref type="bibr">(Collins, 2002</ref>) with 10 iter- ations where the best iteration is selected on the development set. We used the same feature set as in TurboParser ( <ref type="bibr" target="#b21">Martins et al., 2010)</ref>, including features for lemma. For German, we additionally use morpho-syntactic features.</p><p>The decoding algorithm used at training time is the MSA. We experimented with Branch-and- Bound and Lagrangian Relaxation decoding dur-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>English</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>German</head><p>Dutch <ref type="table">Spanish  Portuguese  WN  IL  WN  IL  WN  IL  WN  IL  WN  IL  Block degree 1</ref>    ing training. It did not significantly improve accu- racy and made training and decoding slower. <ref type="table" target="#tab_3">Table 3</ref> shows attachment score (UAS), percent- age of valid dependency trees and relative time to (MSA) for different systems for our five decoding strategies. We can see (B&amp;B) is on a par with (LR) on some corpora and more accurate on the others. The former takes more time, and the improvement is correlated with time difference for all corpora but the PTB. Dividing the five corpora in three cases, we can see that:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Parsing Results</head><p>1. For English and Spanish, where projective dependency trees represent more than 90% of the data, (Eisner) outperforms (MSA). Our methods lie between the two. Here it is better to search for projective trees and (LR) and (B&amp;B) are not interesting in terms of UAS. This is confirmed by the results of (MSA/Eisner).</p><p>2. For German and Dutch, where projective dependency trees represent less than 70% of the data, (MSA) outperforms (Eisner). For German, where well-nestedness is not required, our methods are as accurate as (MSA) <ref type="bibr">13</ref> , while for Dutch our methods seem to be useful, as (B&amp;B) outperforms all sys- 13 For German, we notice a small regression which we at- tribute to the representation of enumerations in the corpus: for enumerations of k elements, k-bounded block-degree subtrees must be generated.</p><p>tems. Moreover, our two methods guarantee validity.</p><p>3. For Portuguese, where projective dependency trees represent around 80% of the data, (MSA) is as accurate as (Eisner). In this case we see that, while our heuristic is below, the ex- act method is more accurate. This seems to be an edge case where neither unconstrained nor projective dependency trees seem to ad- equately capture the solution space. We also see that it is harder for our methods to give solutions (longer computation times, which tend to indicate that LR cannot guarantee op- timality). Our methods are best fitted for this case.</p><p>In order to see how much well-nested and bounded block-degree structures are missed by a state-of-the-art parser, we compare our results with TurboParser. <ref type="bibr">14</ref> We run the parser with three different feature sets: arc-factored, standard (second-order features), and full (third-order fea- tures). The results are shown in <ref type="table" target="#tab_4">Table 4</ref>. Our model, by enforcing strict compliance to structural rules (100% valid dependency trees), is closer to the empirical distribution than TurboParser in arc-factored mode on all languages but German. Higher-order scoring functions manage to get more similar to the treebank data than our strict thresholds for all languages but Portuguese, at the expense of a significative computational burden.    We interpret this fact as an indication that adding higher order features into our system would make the relaxation method converge more often and faster.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>We presented a novel characterization of depen- dency trees complying with two structural rules: bounded block degree and well-nestedness from which we derived two methods for arc-factored dependency parsing. The first one is a heuris- tic which relies on Lagrangian Relaxation and the Chu-Liu-Edmonds efficient maximum span- ning arborescence algorithm. The second one is an exact Branch-and-Bound procedure where bounds are provided by Lagrangian Relaxation. We showed experimentally that these methods give results comparable with state-of-the-art arc- factored parsers, while enforcing constraints in all cases.</p><p>In this paper we focused on arc-factor models, but our method could be extended to higher order models, following the dual decomposition method presented in ( ) in which the maximum-weight spanning arborescence compo- nent would be replaced by our constrained model. Our method opens new perspectives for LTAG parsing, in particular using decomposition tech- niques where dependencies and templates are pre- dicted separately. Moreover, while well-nested dependencies with 2-bounded block degree can represent LTAG derivations, toggling the well- nestedness or setting the block degree bound al- lows to express the whole range of derivations in lexicalized LCFRS, whether well-nested or with a bounded fan-out. Our algorithm can exactly repre- sent these settings with a comparable complexity.</p><p>parsing. In Proceedings of the Nineteenth Confer- ence on Computational Natural Language Learning, pages 289-299, Beijing, China, July. Association for Computational Linguistics.</p><p>[Beasley1993] <ref type="bibr">John E Beasley. 1993</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: (Left) A 2-BBD arborescence: the block degree of vertex 1 is 2 (its yield is {1, 4}) whereas the block degree of all other vertices is 1. (Right) A not well-nested arborescence: the yields of vertices 1 and 2 interleave.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Optimality rate (y-axis) vs number of subgradient iterations (x-axis) for English (thin blue) and German (thick red). Solid line is the optimal rate with certificate, dashed is without.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>MSA</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Timings for strategies (see Section 7.2) on test for solu-
tions which do not satisfy constraints after running MSA. We give 
(in seconds) average time, standard deviation, median time, time 
to parse up to the 3rd quartile and total time. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>UAS, percentage of valid structure and decoding time for test data. Time is relative to MSA decoding. The percentage 
of valid structure is always 100% except for MSA decoding. 

English (99.84) 
German (99.27) 
Dutch (99.87) 
Spanish (99.94) 
Portuguese (99.24) 
Order 
UAS 
VDT 
RT 
UAS 
VDT 
RT 
UAS 
VDT 
RT 
UAS 
VDT 
RT 
UAS 
VDT 
RT 
1st 
89.29 
94.87 
1 
87.97 
98.74 
1 
76.10 
93.26 
1 
83.11 
93.43 
1 
83.53 
94.79 
1 
2nd 
92.04 
99.75 
16 
89.83 
99.28 
16 
79.05 
97.93 
18 
86.61 
98.54 
10 
87.35 
98.96 
15 
3rd 
92.37 
99.75 
34 
90.35 
99.24 
36 
79.68 
97.41 
37 
87.31 
99.64 
18 
88.09 
98.98 
32 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 4 :</head><label>4</label><figDesc></figDesc><table>UAS, percentage of valid dependency trees (VDT) and relative time (RT) obtained by Turboparser for different score 
functions on test sets. For each language we give the percentage of valid dependency structures in the data, according to the 
constraints postulated in Section 7.1. 

</table></figure>

			<note place="foot" n="3"> The predecessor of a vertex v ∈ V is v − 1.</note>

			<note place="foot" n="5"> As stated above, instead of the subgradient we follow an improved descent direction which aggregates information of previous iterations. However, this does not change the proposal of this subsection. 6 [x]i denotes the ith component of vector x.</note>

			<note place="foot" n="8"> https://lemon.cs.elte.hu/trac/lemon 9 http://nlp.cs.lth.se/software/treebank_converter/ 10 http://nlp.stanford.edu/software/tagger.shtml 11 Prediction precision: 97.40%</note>

			<note place="foot" n="12"> In both methods, the subgradient descent is stopped after a fixed maximum number of iterations. We chose 100 for English and 200 for other languages after tuning on the development set.</note>

			<note place="foot" n="14"> We used 2.1.0 and all defaults but the feature set.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We thank the anonymous reviewers for their in-sightful comments which let us significantly im-prove the submitted paper. This work is supported by a public grant overseen by the French National Research Agency (ANR) as part of the Investisse-ments d'Avenir program (ANR-10-LABX-0083).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Floresta sintá (c) tica: A treebank for portuguese</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>References [afonso</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">LREC</title>
		<imprint>
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Experiments with a multilanguage non-projective dependency parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giuseppe</forename><surname>Attardi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Conference on Computational Natural Language Learning</title>
		<meeting>the Tenth Conference on Computational Natural Language Learning</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="166" to="170" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An exact dual decomposition algorithm for shallow semantic parsing with constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carreras2015] Miguel</forename><surname>Ballesteros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Ballesteros</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><surname>Carreras</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Das</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Joint Conference on Lexical and Computational Semantics</title>
		<meeting>the First Joint Conference on Lexical and Computational Semantics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2012" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="209" to="217" />
		</imprint>
	</monogr>
	<note>Proceedings of the Sixth International Workshop on Semantic Evaluation</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A data-driven, factorization parser for CCG dependency structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Du</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference of Natural Language Processing of the Asian Federation of Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference of Natural Language Processing of the Asian Federation of Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1545" to="1555" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Adaptive subgradient methods for online learning and stochastic optimization. The Journal of</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Duchi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 5th Workshop on Tree-Adjoining Grammars and Related Formalisms (TAG+ 5)</title>
		<meeting>the 5th Workshop on Tree-Adjoining Grammars and Related Formalisms (TAG+ 5)</meeting>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="14" to="19" />
		</imprint>
	</monogr>
	<note>A faster parsing algorithm for lexicalized tree-adjoining grammars</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Bilexical grammars and their cubic-time parsing algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><surname>Eisner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Advances in probabilistic and other parsing technologies</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="29" to="61" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Parsing as Reduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-González And Martins2015] Daniel Fernández-González</forename><surname>Fernández</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">T</forename><surname>André</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics (ACL&apos;15)</title>
		<meeting><address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">An additive bounding procedure for the asymmetric travelling salesman problem</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Fischetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matteo</forename><surname>Fischetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Toth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<publisher>Mathematical Programming</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The lagrangian relaxation method for solving integer programming problems. Management science, 27</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Marshall L Fisher ; Harold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">E</forename><surname>Gabow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tarjan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Algorithms</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="80" to="131" />
			<date type="published" when="1981" />
		</imprint>
	</monogr>
	<note>Efficient algorithms for a family of matroid intersection problems</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parsing mildly non-projective dependency structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gómez-Rodríguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th Conference of the European Chapter of the Association for Computational Linguistics</title>
		<meeting>the 12th Conference of the European Chapter of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2009" />
			<biblScope unit="page" from="291" to="299" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Dependency parsing schemata and mildly nonprojective dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Gómez-Rodríguez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational linguistics</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="541" to="586" />
			<date type="published" when="2011" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Relationship between non-projective edges, their level types, and well-nestedness</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiří</forename><surname>Havelka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Human Language Technologies 2007: The Conference of the North American Chapter of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Association for Computational Linguistics</title>
	</analytic>
	<monogr>
		<title level="m">Short Papers</title>
		<imprint>
			<biblScope unit="page" from="61" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A formal model for plausible dependencies in lexicalized tree adjoining grammar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Schabes1997] Aravind</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yves</forename><surname>Joshi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Schabes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kallmeyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kuhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of formal languages</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="1997" />
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="108" to="116" />
		</imprint>
	</monogr>
	<note>Proceedings of TAG</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Efficient third-order dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACL</title>
		<meeting>ACL</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Dual decomposition for parsing with non-projective head automata</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Koo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2010 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1288" to="1298" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">An automatic method of solving discrete programming problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Ailsa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alison</forename><forename type="middle">G</forename><surname>Land</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Doig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Econometrica: Journal of the Econometric Society</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="497" to="520" />
			<date type="published" when="1960" />
		</imprint>
	</monogr>
	<note>Land and Doig1960</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Lagrangian relaxation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claude</forename><surname>Lemaréchal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computational combinatorial optimization</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="page" from="112" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">Non delayed relax-and-cut algorithms. Annals of Operations Research</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abilio</forename><surname>Lucena</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">140</biblScope>
			<biblScope unit="page" from="375" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Lagrangian relaxand-cut algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abilio</forename><surname>Lucena</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Handbook of Optimization in Telecommunications</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="page" from="129" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Concise integer linear programming formulations for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP</title>
		<meeting>the Joint Conference of the 47th Annual Meeting of the ACL and the 4th International Joint Conference on Natural Language Processing of the AFNLP</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2009" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="342" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Turbo parsers: Dependency parsing by approximate variational inference</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Martins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2010 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2010-10" />
			<biblScope unit="volume">2010</biblScope>
			<biblScope unit="page" from="34" to="44" />
		</imprint>
		<respStmt>
			<orgName>MIT Stata Center</orgName>
		</respStmt>
	</monogr>
	<note>Massachusetts, USA, A meeting of SIGDAT, a Special Interest Group of the ACL</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Online learning of approximate dependency parsing algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EACL</title>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Nonprojective dependency parsing using spanning tree algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mcdonald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the conference on Human Language Technology and Empirical Methods in Natural Language Processing</title>
		<meeting>the conference on Human Language Technology and Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2005-01" />
			<biblScope unit="page" from="523" to="530" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Universal dependency annotation for multilingual parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Mcdonald</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2013" />
			<publisher>Citeseer</publisher>
			<biblScope unit="page" from="92" to="97" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">Drawings as models of syntactic structure: Theory and algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mathias</forename><surname>Möhl</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2006" />
		</imprint>
		<respStmt>
			<orgName>Saarland University</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An efficient algorithm for projective dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joakim</forename><surname>Nivre</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Parsing Technologies</title>
		<meeting>the 8th International Workshop on Parsing Technologies</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
	<note>IWPT</note>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">A linear-time transition system for crossing interval trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Pitler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference of the North American Chapter of the Association for Computational Linguistics</title>
		<meeting>the Conference of the North American Chapter of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="662" to="671" />
		</imprint>
	</monogr>
	<note>Pitler and McDonald2015</note>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Dynamic programming for higher order parsing of gap-minding trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Pitler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sampath</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Marcus</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</title>
		<meeting>the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="478" to="488" />
		</imprint>
	</monogr>
	<note>Pitler et al.2012</note>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Branch and bound algorithm for dependency parsing with non-local features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yang</forename><surname>Qian And Liu2013] Xian Qian</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="37" to="48" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Parse, price and cut: delayed column and row generation for graph based parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Riedel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Mccallum</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</title>
		<meeting>the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="732" to="743" />
		</imprint>
	</monogr>
	<note>Riedel et al.2012. Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">A tutorial on dual decomposition and lagrangian relaxation for inference in natural language processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Riedel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Alexander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Rush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SRL 2009</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
	<note>Cutting plane map inference for markov logic</note>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">Efficient parsing for head-split dependency trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">M</forename><surname>Rush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yin-Wen</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">;</forename><surname>Satta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Satta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP</title>
		<meeting>EMNLP</meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="267" to="278" />
		</imprint>
	</monogr>
	<note>Optimal beam search for machine translation</note>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Combinatorial Optimization-Polyhedra and Efficiency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Schrijver</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Springer</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Introducing the spmrl 2014 shared task on parsing morphologically-rich languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Djamé</forename><surname>Seddah</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sandra</forename><surname>Kübler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Reut</forename><surname>Tsarfaty</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages</title>
		<meeting>the First Joint Workshop on Statistical Parsing of Morphologically Rich Languages and Syntactic Analysis of Non-Canonical Languages</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="103" to="109" />
		</imprint>
	</monogr>
	<note>Seddah et al.2014</note>
</biblStruct>

<biblStruct xml:id="b35">
	<monogr>
		<title level="m" type="main">Bidirectional ltag dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joshi2007] Libin</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aravind K Joshi</forename><surname>Shen</surname></persName>
		</author>
		<idno>07-02</idno>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
		<respStmt>
			<orgName>IRCS, University of Pennsylvania</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Adding noun phrase structure to the penn treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Curran2007] David</forename><surname>Vadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">R</forename><surname>Vadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Curran</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th Annual Meeting of the Association for Computational Linguistics (ACL-07)</title>
		<meeting>the 45th Annual Meeting of the Association for Computational Linguistics (ACL-07)</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="240" to="247" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Leonoor Van der Beek, Gosse Bouma, Rob Malouf, and Gertjan Van Noord. 2002. The alpino dependency treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Van Der Beek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Language and Computers</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="8" to="22" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Matthew D Zeiler</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1212.5701</idno>
		<title level="m">Adadelta: An adaptive learning rate method</title>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
