<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:30+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Semantic Parsing of Pre-university Math Problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>July 30-August 4, 2017. July 30-August 4, 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takuya</forename><surname>Matsuzaki</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takumi</forename><surname>Ito</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hidenao</forename><surname>Iwane</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hirokazu</forename><surname>Anai</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noriko</forename><surname>H. Arai</surname></persName>
						</author>
						<title level="a" type="main">Semantic Parsing of Pre-university Math Problems</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers)</title>
						<meeting>the 55th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) <address><addrLine>Vancouver, Canada; Vancouver, Canada</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="2131" to="2141"/>
							<date type="published">July 30-August 4, 2017. July 30-August 4, 2017</date>
						</imprint>
					</monogr>
					<idno type="DOI">10.18653/v1/p17-1195</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We have been developing an end-to-end math problem solving system that accepts natural language input. The current paper focuses on how we analyze the problem sentences to produce logical forms. We chose a hybrid approach combining a shallow syntactic analyzer and a manually-developed lexicalized grammar. A feature of the grammar is that it is extensively typed on the basis of a formal ontology for pre-university math. These types are helpful in semantic disambiguation inside and across sentences. Experimental results show that the hybrid system produces a well-formed logical form with 88% precision and 56% recall.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Frege and Russell, the initiators of the mathemati- cal logic, delved also into the exploration of a the- ory of natural language semantics <ref type="bibr">(Frege, 1892;</ref><ref type="bibr" target="#b22">Russell, 1905)</ref>. Since then, symbolic logic has been a fundamental tool and a source of inspira- tion in the study of language meaning. It suggests that the formalization of the two realms, mathe- matical reasoning and language meaning, is ac- tually the two sides of the same coin -probably, we could not even conceive the idea of formaliz- ing language meaning without grounding it onto mathematical reasoning. This point was first clari- fied by <ref type="bibr" target="#b28">Tarski (1936;</ref><ref type="bibr" target="#b29">1944</ref>) mainly on formal lan- guages and then extended to natural languages by <ref type="bibr" target="#b4">Davidson (1967)</ref>. <ref type="bibr" target="#b17">Montague (1970a;</ref><ref type="bibr" target="#b18">1970b;</ref><ref type="bibr" target="#b19">1973)</ref> further embodied it by putting forward a terrify- ingly arrogant and attractive idea of seeing a natu- ral language as a formal language.</p><p>The automation of end-to-end math problem solving thus has an outstanding status in the re- Define the two straight lines L1 and L2 on the xy-plane as L1: y = 0 (x-axis) and L2: y = √ 3x. Let P be a point on the xy-plane. Let Q be the point symmetric to P about the straight line L1, and let R be the point symmetric to P about the straight line L2. Answer the following questions:</p><p>(1) Let (a, b) be the coordinates of P , then represent the coordinates of R using a and b. (2) Assuming that the distance between the two points Q and R is 2, find the locus C of P . (3) When the point P moves on C, find the maximum area of the triangle P QR and the coordinates of P that gives the maximum area.</p><p>(Hokkaido Univ., 1999-Sci-3) <ref type="figure">Figure 1</ref>: Example problem search themes in natural language processing. The conceptual basis has been laid down, which con- nects text to the truth (= answer) through reason- ing. However, we have not seen a fully automated system that instantiates it end-to-end. We wish to add a piece to the big picture by materializing it. Past studies have mainly targeted at primary school level arithmetic word problems <ref type="bibr" target="#b2">(Bobrow, 1964;</ref><ref type="bibr" target="#b3">Charniak, 1969;</ref><ref type="bibr" target="#b8">Hosseini et al., 2014;</ref><ref type="bibr" target="#b24">Shi et al., 2015;</ref><ref type="bibr" target="#b21">Roy and Roth, 2015;</ref><ref type="bibr" target="#b34">Zhou et al., 2015;</ref><ref type="bibr" target="#b9">Koncel-Kedziorski et al., 2015;</ref><ref type="bibr" target="#b16">Mitra and Baral, 2016;</ref><ref type="bibr" target="#b30">Upadhyay et al., 2016</ref>). In their nature, arithmetic questions are quantifier-free. Moreover they tend to include only ∧ (and) as the logical connective. The main challenge in these works was to extract simple nu- merical relations (most typically equations) from a real-world scenario described in a text. <ref type="bibr" target="#b23">Seo et al. (2015)</ref> took SAT geometry ques- tions as their benchmark. However, the nature of SAT geometry questions restricts the resulting for- mula's complexity. In §3, we will show that none of them includes ∀ (for all), ∨ (or) or → (implies  We take pre-university math problems falling in the theory of real-closed fields (RCF) as our benchmark because of their variety and complex- ity. The subject areas include real and linear al- gebra, complex numbers, calculus, and geometry. Furthermore, many problems involve more than one subject: e.g., algebraic curves and calculus as in <ref type="figure">Fig. 1</ref>. Their logical forms include all the logical connectives, quantifiers, and λ-abstraction. Our goal is to recognize the complex logical struc- tures precisely, including the scopes of the quanti- fiers and other logical operators.</p><p>In the rest of the paper, we first present an overview of an end-to-end problem solving sys- tem ( §2) and analyze the complexity of the pre- university math benchmark in comparison with others ( §3). Among the modules in the end-to-end system, we focus on the sentence-level semantic parsing component and describe an extensively- typed grammar ( §4 and §5), an analyzer for the math expressions in the text ( §6), and two seman- tic parsing techniques to fight against the scarcity of the training data ( §7) and the complexity of the domain ( §8). Experimental results show the effec- tiveness of the presented techniques as well as the complexity of the task through an in-depth analy- sis of the end-to-end problem solving results ( §9).</p><p>2 End-to-end Math Problem Solving <ref type="figure" target="#fig_0">Fig. 2</ref> presents an overview of our end-to-end math problem solving system. A math problem text is firstly analyzed with a dependency parser. Anaphoric and coreferential expressions in the text are then identified and their antecedents are de- termined. We assume the math formulas in the problems are encoded in MathML presentation mark-up. A specialized parser processes each one of them to determine its syntactic category and semantic content. The semantic representa- tion of each sentence is determined by a semantic parser based on Combinatory Categorial Grammar (CCG) <ref type="bibr" target="#b25">(Steedman, 2001</ref><ref type="bibr" target="#b26">(Steedman, , 2012</ref>  <ref type="table">Table 1</ref>: Performance of the reasoning module on manually formalized pre-university problems</p><p>After the sentence-level processing steps, we determine the logical relations among the sentence-level logical forms (discourse parsing) by a simple rule-based system. It produces a tree structure whose leaves are labeled with sentences and internal nodes with logical connectives. Free variables in the logical form are then bound by some quantifiers (or kept free) and their scopes are determined according to the logical structure of the problem. A semantic representation of a problem is obtained as a formula in a higher-order logic through these language analysis steps.</p><p>The logical representation is then rewritten us- ing a set of axioms that define the meanings of the predicate and function symbols in the formula, such as maximum defined as follows:</p><formula xml:id="formula_0">maximum(x, S) ↔ x ∈ S ∧ ∀y(y ∈ S → y ≤ x),</formula><p>as well as several logical rules such as β- reduction. We hope to obtain a representation of the initial problem expressed in a decidable math theory such as RCF through these equivalence- preserving rewriting. Once we find such a for- mula, we invoke a computer algebra system (CAS) or an automatic theorem prover (ATP) to derive the answer.</p><p>The reasoning module (i.e., the formula rewrit- ing and the deduction with CAS and ATP) of the system has been extensively tested on a large collection of manually formalized pre-university math problems that includes more than 1,500 problems. It solves 70% of the them in the time limit of 10 minutes per problem. <ref type="table">Table 1</ref> shows the rate of successfully solved problems in the man- ually formalized version of the benchmark prob- lems used in the current paper.    </p><formula xml:id="formula_1">JOBS GEOQUERY GEOMETRY UNIV (DEV) ∃P 81% ∃P 46% ∃P 94% ∃P 25% P 6% ∃P (λ∃P ) 24% ∃(P ∧¬P ) 3% ∃(P ∧¬P ) 7% ∃(P ∧¬∃P ) 5% P (λ∃P ) 8% ∃(P ∧P (λP )) 2% P (λ∃P ) 5% ∃(P ∧¬P ) 5% ∃(P ∧P (λ∃P )) 7% P (λ∃P ) 1% ∃(P ∧P (λf )) 4% 97% 85% 100% 41%</formula><formula xml:id="formula_2">∀(P → ∃(∀(P → P )∧P )) 2 ∃(∃(¬P ∧P )∧P ∧P (λf ))∧P (λ(P → P ))) 1 ∃(P ∧P (λ(¬P ∧∃(∃P ∧P )))) 1 ∃(P ∧P (λf ))∧P (λ(¬P ∧P ))∧P (λP )) 1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Profile of the Benchmark Data</head><p>Our benchmark problems, UNIV, were collected from the past entrance exams of seven top-ranked universities in Japan. In the exams held in odd numbered years from 1999 to 2013, we exhaus- tively selected the problems which are ultimately expressible in RCF. They occupied 40% of all the problems. We divided the problems into two sets: DEV for development (those from year 1999 to 2005) and TEST for test (those from year 2007 to 2013). DEV was used for the lexicon devel- opment and the tuning of the end-to-end system. The problem texts (both in English and Japanese) with MathML mark-up and manually translated logical forms are publicly available at https: //github.com/torobomath. The manually translated logical forms were for- mulated in a higher-order semantic language intro- duced later in the paper. The translation was done as faithfully as possible to the original wordings of the problems. They thus keep the inherent logical structures expressed in natural language. <ref type="table" target="#tab_3">Table 2</ref> lists several statistics of the UNIV prob- lems in the English version and their manual for- malization. For comparison, the statistics of three other benchmarks are also listed. JOBS and GEO- QUERY are collections of natural language queries against databases. They have been widely used as benchmarks for semantic parsing (e.g., <ref type="bibr" target="#b27">Tang and Mooney, 2001;</ref><ref type="bibr">Collins, 2005, 2007;</ref><ref type="bibr" target="#b13">Kwiatkowski et al., 2010</ref><ref type="bibr" target="#b14">Kwiatkowski et al., , 2011</ref><ref type="bibr" target="#b15">Liang et al., 2011</ref>). The queries are annotated with logical forms in Prolog. We converted them to equiva- lent higher-order formulas to collect comparable statistics. GEOMETRY is a collection of SAT ge- ometry questions compiled by <ref type="bibr" target="#b23">Seo et al. (2015)</ref>. We formalized the GEOMETRY questions 1 in our semantic language in the same way as UNIV.</p><p>In <ref type="table" target="#tab_3">Table 2</ref>, the first column lists the number of problems. The next three provide statistics of the problem texts: average number of words and sentences in a problem ('Avg. tokens' and 'Avg. sents'), and the number of unique words in the whole dataset. <ref type="bibr">2</ref> They reveal that the sentences in UNIV are significantly longer than the others and more than three sentences have to be correctly pro- cessed for a problem.</p><p>The remaining columns provide the statistics about the logical complexities of the problems. 'Atoms' stands for the average number of the oc- currences of predicates per problem. The next three columns list the number of variables bound by ∃, ∀, and λ. We count sequential occurrences of the same binder as one. The columns for ∧, ∨, ¬, and → list the average number of them per prob- lem. <ref type="bibr">3</ref> We can see UNIV includes a wider variety of quantifiers and connectives than the others.</p><p>The final column lists the numbers of unique 'sketches' of the logical forms in the dataset. What we call 'sketch' here is a signature that encodes the overall structure of a logical form. <ref type="table" target="#tab_4">Table 3</ref> shows the top four most frequent sketches observed in the datasets. In a sketch, P stands for a (conjunction of) predicate(s) and f stands for a term. ∃, ∀, and λ stand for (immediately nested sequence of) the binders.</p><p>To obtain the sketch of a formula φ, we first re- place all the predicate symbols in φ to P and func- tion symbols and constants to f . We then elimi- nate all variables in φ and 'flatten' it by applying the following rewriting rules to the sub-formulas in φ in the bottom-up order:</p><formula xml:id="formula_3">f (..., f (α 1 , α 2 , ..., α n ), ...) ⇒ f (..., α 1 , α 2 , ..., α n , ...) P (..., f (α 1 , α 2 , ..., α n ), ...) ⇒ P (..., α 1 , α 2 , ..., α n , ...) α ∨ α ∨ β ⇒ α ∨ β, α ∧ α ⇒ α ∃∃ψ ⇒ ∃ψ, ∀∀ψ ⇒ ∀ψ, λλψ ⇒ λψ</formula><p>Finally, we sort the arguments of P s and f s and remove the duplicates among them. For instance, to obtain the sketch of the following formula:</p><formula xml:id="formula_4">∀k∀m maximum(m, set(λe.(e &lt; k))) → k − 1 ≤ m ∧ m &lt; k ,</formula><p>we replace the predicate/function symbols as in:</p><formula xml:id="formula_5">∀k∀m P (m, f (λe.P (e, k))) → P (f (k, f ), m) ∧ P (m, k) ,</formula><p>and then eliminate the variables to have:</p><formula xml:id="formula_6">∀∀(P (f (λP )) → P (f (f )) ∧ P ),</formula><p>and finally flatten it to: <ref type="table" target="#tab_4">Table 3</ref> shows that a wide variety of structures are found in UNIV while other data sets are dom- inated by a small number of structures. <ref type="table" target="#tab_5">Table 4</ref> presents some of less frequent sketches found in UNIV (DEV). In actuality, 67% of the unique sketches found in UNIV (DEV) occur only once in the dataset. These statistics suggest that the dis- tribution of the logical structures found in UNIV, and math text in general, is very long-tailed.</p><formula xml:id="formula_7">∀(P (λP ) → P ).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Type System for Pre-university Math</head><p>Our semantic language is a higher-order logic (lambda calculus) with parametric polymorphism. <ref type="table">Table 5</ref> presents the types in the language. The atomic types are defined so that they capture the selectional restriction of verbs and other truth values Bool numbers Z (integers), Q (rationals), </p><formula xml:id="formula_8">R (reals), C (complex) polynomials Poly single variable functions R2R (R → R), C2C (C → C) single variable equations EqnR (in R), EqnC (in C) points in 2D/3D space 2d.Point,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>), ListOf(α) polymorphic tuples</head><p>Pair(α, β), Triple(α, β, γ) <ref type="table">Table 5</ref>: Types defined in the semantic language argument-taking phrases as precisely as possible.</p><p>For instance, an equation in real domain, e.g., x 2 − 1 = 0, can be regarded as a set of reals, i.e., {x | x 2 − 1 = 0}. However, we never say 'a so- lution of a set.' We thus discriminate an equation from a set in the type system even though the con- cept of equation is mathematically dispensable. Entities of equation and set are built by con- structor functions that take a higher-order term as the argument as in eqn(λx.x 2 − 1) and set(λx.x 2 − 1). Related concepts such as 'solu- tion' and 'element' are defined by the axioms for corresponding function and predicate symbols:</p><formula xml:id="formula_9">∀f ∀x(solution(x, eqn(f )) ↔ f x) ∀s∀x(element(x, set(s)) ↔ sx).</formula><p>Distinction of cardinal numbers (Card) and ordinal numbers (Ord), and the introduction of 'integer division' type (QuoRem) are also lin- guistically motivated.</p><p>The former is neces- sary to capture the difference between, e.g., 'k- th integer in n 1 , n 2 , . . . , n m ' and 'k integers in n 1 , n 2 , . . . , n m .' An object of type QuoRem is conceptually a pair of integers that represent the quotient and the remainder of integer divi- sion. It is linguistically distinct from the type of Pair(Z,Z) because, e.g., in</p><p>Select a pair of integers (n, m) and divide n by m. If the remainder (of φ) is zero, ... the null (i.e., omitted) pronoun φ has 'the result of division n/m' as its antecedent but not (n, m).</p><p>Polymorphism is a mandatory part of the lan- guage. Especially, the semantics of plural noun</p><formula xml:id="formula_10">&gt; &gt; When S/(S\N P )/Sa : λP.λQ.π2(P ) → Q(π1(P )) any k in K is divided by m, Sa : (quorem(k, m), (∃k; k ∈ K)) S/(S\N P ) : λQ.(∃k; k ∈ K) → Q(quorem(k, m)) &gt; the quotient T\N P/(T\N P ) : λP.λx.P (quo of(x))</formula><p>is 3.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S\N P : λx.(x = 3)</head><p>S\N P : λx.quo of(x) = 3 S : (∃k; k ∈ K) → quo of(quorem(k, m)) = 3</p><p>Figure 3: Sketch of the derivation tree for a sentence including an action verb and quantification phrases is expressed by polymorphic lists and tu- ples: e.g., 'the radii of the circles C 1 , C 2 , and C 3 ' is of type ListOf(R) and 'the function f and its maximum value' is of type Pair(R2R,R).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Lexicon and Grammar</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Combinatory Categorial Grammar</head><p>An instance of CCG grammar consists of a lexi- con and a small number of combinatory rules. A lexicon is a set of lexical items, each of which as- sociates a word surface form with a syntactic cat- egory and a semantic function: e.g., A syntactic category is one of atomic categories, such as NP, PP, and S, or a complex category in the form of X/Y or X\Y, where X and Y are syntactic categories.</p><p>The syntactic categories and the semantic func- tions of constituents are combined by applying combinatory rules. The most fundamental rules are forward (&gt;) and backward (&lt;) application:</p><formula xml:id="formula_11">&gt; X/Y : f Y : x X : f x &lt; Y : x X\Y : f X : f x</formula><p>The atomic categories are further classified by features such as num(ber) and case of noun phrases. In the current paper, the features are writ- ten as in NP <ref type="bibr">[num=pl,case=acc]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">A Japanese CCG Grammar and Lexicon</head><p>We developed a Japanese CCG following the anal- ysis of basic constructions by Bekki (2010) but significantly extending it by covering various phe- nomena related to copula verbs, action verbs, argument-taking nouns, appositions and so forth. The semantic functions are defined in the format of a higher-order version of dynamic predicate logic ( <ref type="bibr" target="#b5">Eijck and Stokhof, 2006</ref>). The dynamic property is necessary to analyze semantic phe- nomena related to quantifications, such as donkey anaphora. In the following examples, we use En- glish instead of Japanese and the standard notation of higher-order logic for the sake of readability.</p><p>We added two atomic categories, Sn and Sa, to the commonly used S, NP, and N. Category Sn is assigned to a proposition expressed as a math for- mula, such as 'x &gt; 0'. Semantically it is of type Bool but syntactically it behaves both like a noun phrase and a sentence.</p><p>Category Sa is assigned to a sentence where the main verb is an action verb such as add and ro- tate. Such a sentence introduces the result of the action as a discourse entity (i.e., what can be an antecedent of coreferential expressions). The ac- tion verbs can also mediate quantification as in:</p><p>When any k ∈K is divided by m, the quotient is 3.</p><formula xml:id="formula_12">∀k(k ∈ K → quo of(quorem(k, m)) = 3)</formula><p>where quorem(k, m) represents the result of the division (i.e., the pair of the quotient and the re- mainder) and quo of is a function that extracts the quotient from it. To handle such phenomena, we posit the semantic type of Sa as Pair(α, Bool) where the two components respectively bring the result of an action and the condition on it (including quantification). <ref type="figure">Fig. 3</ref> presents a derivation tree for the above example. <ref type="bibr">4</ref> The atomic category NP, N, and Sa in our gram- mar have type feature. Its value is one of the types defined in the semantic language or a type variable when the entity type is underspecified. The lexical entry for '(an integer) divides (an in- teger)' and '(a set) includes (an element)' would thus have the following categories (other features than type are not shown):</p><formula xml:id="formula_13">divides :: S\NP[type=Z]/NP[type=Z] includes :: S\NP[type=SetOf(α)]/NP[type=α]</formula><p>When defining a lexical item, we don't have to explicitly specify the type features in most cases. They can be usually inferred from the definition of the semantic function. In the above example, di- vides will have λy.λx.(x|y) and includes will have λy.λx.(y ∈ x) as their semantic functions. For both cases, the type feature of the NP arguments can be determined from the type definitions of the operators | and ∈ in the ontology.</p><p>The lexicon currently includes 54,902 lexical items for 8,316 distinct surface forms, in which 5,094 lexical items for 1,287 surface forms are for function words and functional multi-word expres- sions. The number of unique categories in the lex- icon is 10,635. When the type features are ig- nored, there are still 4,026 distinct categories.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Math Expression Analysis</head><p>The meaning of a math expression is composed with the semantic functions of surrounding words to produce a logical form. We dynamically gen- erate lexical items for each math expression in a problem. Consider the following sentence includ- ing two 'equations':</p><p>If a 2 −4 = 0, then x 2 +ax+1 = 0 has a real solution. The latter, x 2 +ax+1 = 0, should receive a lexical item of a noun phrase, NP : eqn(λx.x 2 + a + 1), but the former, a 2 −4 = 0, should receive category S since it denotes a proposition. Such disambigua- tion is not always possible without semantic anal- ysis of the text. We thus generate more than one lexical item for ambiguous expressions and let the semantic parser make a choice.</p><p>To generate the lexical items, we first collect appositions to the math expressions, such as 'in- teger n and m' and 'equation x 2 + a = 0,' and use them as the type constraints on the variables and the compound expressions. Compound ex- pressions are then parsed with an operator prece- dence parser ( <ref type="bibr" target="#b0">Aho et al., 2006</ref>). Overloaded op- erators, such as + for numbers and vectors, are resolved using the type constrains whenever pos- sible. Finally, we generate all possible interpre- tations of the expressions and select appropriate syntactic categories.</p><p>We have seen only three categories of math ex- pressions: NP, Sn, and T/(T\NP). The last one is used for a NP with post-modification, as in:</p><formula xml:id="formula_14">&gt; n &gt; 0 T/(T\N P ) : λP.(n &gt; 0 ∧ P (n))</formula><p>is an even number </p><formula xml:id="formula_15">S\N P : λx.(even(x)) S : n &gt; 0 ∧ even(n) Naomi-NOM garden-LOC walk-PAST</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Two-step Semantic Parsing</head><p>Two central issues in parsing are the cost of the search and the accuracy of disambiguation. Super- vised learning is commonly used to solve both. It is however very costly to create the training data by manually annotating a large number of sen- tences with CCG trees. Past studies have tried to bypass it by so-called weak supervision, where a parser is trained only with the logical form (e.g., <ref type="bibr" target="#b14">Kwiatkowski et al. 2011</ref>) or even only with the answers to the queries (e.g., <ref type="bibr" target="#b15">Liang et al. 2011</ref>).</p><p>Although the adaptation of such methods to the pre-university math data is an interesting future di- rection, we developed yet another approach based on a hybrid of shallow dependency parsing and the detailed CCG grammar. The syntactic structure of Japanese sentences has traditionally been analyzed based on the relations among word chunks called bunsetsus. A bunsetsu consists of one or more content words followed by zero or more function words. The dependencies among bunsetsus mostly correspond to the predicate-argument and inter- clausal dependencies <ref type="figure" target="#fig_2">(Fig. 4)</ref>. The dependency structure hence matches the overall structure of a CCG tree only leaving the details unspecified.</p><p>We derive a full CCG-tree by using a bunsetsu dependency tree as a constraint. We assume: (i) the fringe of each sub-tree in the dependency tree has a corresponding node in the CCG tree. We call such a node in the CCG tree 'a matching node.' We further assume: (ii) a matching node is com- bined with another CCG tree node whose span in- cludes at least one word in the head bunsetsu of the matching node. <ref type="figure">Fig. 5</ref> presents an example of a sentence consisting of four bunsetsus (rounded squares), each of which contains two words. In the figure, the i-th cell in the k-th row from the bottom is the CKY cell for the span from i-th to w 1 w 2 w 3 w 4 w 5 w 6 w 7 w 8 <ref type="figure">Figure 5</ref>: Restricted CKY parsing based on a shal- low dependency structure (i+k-1)-th words. Under the two assumptions, we only need to fill the hatched cells given the depen- dency structure shown below the CKY chart. The hatched cells with a white circle indicate the posi- tions of the matching nodes.</p><p>Even under the constraint of a dependency tree, it is impractical to do exhaustive search. We use beam search based on a simple score function on the chart items that combines several features such as the number of atomic categories in the item. We also use N -best dependency trees to circumvent the dependency errors. The restricted CKY pars- ing is repeated on the N -best dependency trees until a CCG tree is obtained. Our hope is to re- ject a dependency error as violation of the syntac- tic and semantic constraints encoded in the CCG lexicon. In the experiment, we used a Japanese dependency parser developed by <ref type="bibr" target="#b10">Kudo and Matsumoto (2002)</ref>. We modified it to produce N -best outputs and used up to 20-best trees per sentence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Global Type Coherency</head><p>The well-typedness of the logical form is usually guaranteed by the combinatory rules. However, they do not always guarantee the type coherency among the interpretations of the math expressions.</p><p>For instance, consider the following derivation:</p><formula xml:id="formula_16">&gt; if x + y ∈ U, S/S : λP.(add R (x, y) ∈ U → P ) then x + z ∈ V. S : add V (x, y) ∈ V S : add R (x, y) ∈ U → add V (x, z) ∈ V</formula><p>The + symbol is interpreted as the addition of real numbers (add R ) in the first clause but that of vec- tors (add V ) in the second one. The logical form is not typable because the two occurrences of x must have different types. The forward application rule does not reject this derivation since the categories of the two clauses perfectly match the rule schema.</p><p>We can reject such inconsistency by doing type checking on the logical form at every step of the</p><note type="other">Algorithm 1 Global type coherence check procedure PARSEPROBLEM Envs ← ∅; AllDerivs ← [] for each sentence s in the problem do Chart ← INITIALIZECKYCHART(s, Envs) Derivs ← TWOSTEPPARSING(s, Chart) Envs ← UPDATEENVIRONMENTS(Envs, Derivs) AllDerivs ← AllDerivs ⊕ [Derivs] return AllDerivs // s: a sentence; Envs: a set of environments procedure INITIALIZECKYCHART(s, Envs)</note><p>Chart ← empty CKY chart for each token t in s do for each lexical item C : f for t do // C: category, f : semantic function if t is a math expression then for each environment Γ ∈ Envs do if Γ is unifiable with FV(f ) then add (C, Γ FV(f )) to Chart else // t is a normal word add (C, ∅) to Chart return Chart FV(f ): the environment that maps the free variables in a semantic function f to their principal types determined by type inference on f . // Envs: a set of environments; Derivs: derivations trees procedure UPDATEENVIRONMENTS(Envs, Derivs)</p><p>NewEnvs ← ∅ // environments for the next sentence for each derivation d ∈ Derivs do Γ ← the environment at the root of d if Γ = ∅ then // update the environments NewEnvs ← NewEnvs ∪{Γ} else // no update: there was no math expression NewEnvs ← NewEnvs ∪ Envs // eliminate those subsumed by other environments return MOSTGENERALENVIRONMENTS(NewEnvs) derivation. It is however quite time consuming be- cause we cannot use dynamic programming any more and need to do type checking on numerous chart items. Furthermore, such type inconsistency may happen across sentences. Instead, we con- sider the type environment while parsing. A type environment, written as {v 1 : T 1 , v 2 : T 2 , . . . }, is a finite function from variables to type expres- sions. A pair v : T means that the variable v must be of type T or its instance (e.g., SetOf(R) is an instance of SetOf(α)). For example, the logical form of the first clause of the above sentence is ty- pable under {x : R, y : R, z : α, U : SetOf(R), V : β}, but that of the second clause isn't. Please refer, e.g., to <ref type="bibr" target="#b20">(Pierce, 2002</ref>) for the formal definitions. Two environments Γ 1 and Γ 2 are unifiable iff there exists a substitution σ that maps the type variables in Γ 1 and Γ 2 to some type expressions so that Γ 1 σ = Γ 2 σ holds. We write Γ 1 Γ 2 for the re- sult of such substitution (i.e., unification) with the</p><formula xml:id="formula_17">&lt; &lt; n (N P [α], {n : α}) &gt; divides (S\N P [Z]/N P [Z], ∅) 12 (N P [Z], ∅) (S\N P [Z], ∅) (S, {n : Z}) &gt; iff (S\S/Sn, ∅)</formula><p>n ∈ U (Sn, {n : β, U : SetOf(β)}) (S\S, {n : β, U : SetOf(β)}) (S, {n : Z, U : SetOf(Z)})   <ref type="table">Table 7</ref>: Fraction of sentences on which a CCG tree was obtained in top N dependency trees most general σ (most general unifier, mgu).</p><p>We associate a type environment with each chart item and refine it through parsing. The type constraints implied in a discourse are accumu- lated in the environment and block the generation of incoherent derivations (Algorithm 1). <ref type="figure">Fig. 6</ref> presents an example of a parsing result, in which the type constraints implied in the two clauses are unified at the root and the type of U is determined. When we apply a combinatory rule, we first check if the environments of the child chart items are unifiable. If so, we put the unified environment in the parent item and apply the unifier to the type features in the parent category. For instance, the forward application rule is revised as follows:</p><formula xml:id="formula_18">(X/Y, Γ 1 ) + (Y, Γ 2 ) → (Xσ, Γ 1 Γ 2 ),</formula><p>where σ is the mgu of Γ 1 and Γ 2 and Xσ means the application of σ to the type features in X. <ref type="bibr">5</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Experiments and Analysis</head><p>This section presents the overall performance of the current end-to-end system and demonstrates the effectiveness of the proposed parsing tech- niques. We also present an analysis of the failures. <ref type="table" target="#tab_7">Table 6</ref> presents the result of end-to-end prob- lem solving on the UNIV data. It shows the failure in the semantic parsing is a major bottleneck in the current system. Since a problem in UNIV includes more than three sentences on average, parsing a whole problem is quite a high bar for a semantic parser. It is however necessary to solve it by the nature of the task. Once a problem-level logical form was produced, the system yielded a correct solution for 44% of such problems in DEV and 36% in TEST. <ref type="table">Table 7</ref> lists the fraction of the sentences on which the two-step parser produced a CCG tree within top-N dependency trees. We compared the results obtained with the dependency parser trained only on a news corpus (News) ( <ref type="bibr" target="#b11">Kurohashi and Nagao, 2003)</ref>, which is annotated with bun- setsu level dependencies, and that trained addi- tionally with a math problem corpus consisting of 6,000 sentences 6 (News+Math). The math prob- lem corpus was developed according to the same annotation guideline for the news corpus. The at- tachment accuracy of the dependency parser was 84% on math problem text when trained only on the news corpus but improved to 94% by the ad- dition of the math problem corpus. The perfor- mance gain by increasing N is more evident in the results with the News parser than that with the News+Math parser. It suggests the grammar prop- erly rejected wrong dependency trees, which were ranked higher by the News parser. The effect of the additional training is very large at small N s and still significant at N = 20. It means that we successfully boosted both the speed and the suc- cess rate of CCG parsing only with the shallow dependency annotation on in-domain data.   <ref type="table">Table 9</ref>: Reasons for the parse failures <ref type="table" target="#tab_10">Table 8</ref> shows the effect of CCG parsing with type environments. The column headed 'Typing failure' is the fraction of the problems on which no logical form was obtained due to typing fail- ure. Parsing with type environment eliminated al- most all such failures and significantly improved the number of correct answers. The remaining type failure was due to beam thresholding where a necessary derivation fell out of the beam. <ref type="table">Table 9</ref> lists the reasons for the parse failures on 1/4 of the TEST section (the problems taken from exams on 2007). In the table, "unknown usage" means a missing lexical item for a word already in the lexicon. "Unknown word" means no lexi- cal item was defined for the word. Collecting un- known usages (especially that of a function word) is much harder than just compiling a list of words. Our experience in the lexicon development tells us that once we find a usage example, in the large ma- jority of the cases, it is not difficult to write down its syntactic category and semantic function. Ta- ble 9 suggests that we can efficiently detect and collect unknown word usages through parsing fail- ures on a large raw corpus of math problems. <ref type="table" target="#tab_12">Table 10</ref> presents the accuracy of the sentence- and problem-level logical forms produced on the year 1999 subset of DEV and the year 2007 subset of TEST. Although the recall on the unseen test data is not as high as we hope, the high precision of the sentence-level logical forms is encouraging. <ref type="table">Table 11</ref> provides the counts of the error types found in the wrong sentence-level logical forms produced on <ref type="bibr">DEV-1999 and</ref><ref type="bibr">TEST-2007</ref>. It re- veals the majority of the errors are related to the choice of quantifier (∃, ∀, or free) and logical op-   <ref type="table">Table 11</ref>: Types of errors in the logical forms erators (e.g., → vs. ↔) as well as the determina- tion of their scopes. Meanwhile, we did not find an error related to the predicate-argument struc- ture of a logical form. This fact and the results in <ref type="table" target="#tab_7">Table 6</ref> suggest that the selectional restrictions, encoded in the lexicon, properly rejected non- sensical predicate-argument relations. Our next step is to introduce a more sophisticated disam- biguation model on top of the grammar, enjoying the properly confined search space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Conclusion</head><p>We have explained why the task of end-to-end math problem solving matters for a practical the- ory of natural language semantics and introduced the semantic parsing of pre-university math prob- lems as a novel benchmark. The statistics of the benchmark data revealed that it includes far more complex semantic structures than the other bench- marks. We also presented an overview of an end- to-end problem solving system and described two parsing techniques motivated by the scarcity of the annotated data and the need for the type coherency of the analysis. Experimental results demonstrated the effectiveness of the proposed techniques and showed the accuracy of the sentence-level logical form was 88% precision and 56% recall. Our fu- ture work includes the expansion of the lexicon with the aid of the semantic parser and the devel- opment of a disambiguation model for the binding and scoping structures.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Overview of the end-to-end math problem solving system</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>sum ::</head><label></label><figDesc>NP/PP : λx.sum of(x) intersects :: S\NP/PP : λy.λx.intersect(x, y)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Bunsetsu dependency structure (top) and CCG derivation tree (bottom)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head></head><label></label><figDesc>). It suggests that this type of questions require little need to analyze the logical structure of the prob- lems beyond conjunctions of predicates.</figDesc><table>Problem 

shallow 
parsing 

coreference 
resolution 

math expr. 
analysis 

semantic 
parsing 

discourse 
parsing 

formula 
rewriting 
reasoning 
Solution 

Lexicon 
Ontology 
Axioms 
CAS 
ATP 

Type 
constraint 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head></head><label></label><figDesc>). The output from the CCG parser is a ranked list of sentence-level logical forms for each sentence.</figDesc><table>Dataset 
Succeeded 
Failed 

Success% 
Avg. Timeout Other 
Time 
DEV 
75.3% (131/174) 10.5s 
16.7% 
8.1% 
TEST 
78.2% (172/220) 16.2s 
15.0% 
6.8% 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Profile of pre-university math benchmark data and other semantic parsing benchmark data sets 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 : Top four most frequest sketches and their coverage over the dataset</head><label>3</label><figDesc></figDesc><table>Sketch 
Freq. 
</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 4 : Less frequent sketches in UNIV (DEV)</head><label>4</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_7" validated="false"><head>Figure 6 : CCG parsing with type environment</head><label>6</label><figDesc></figDesc><table>Dataset Correct 
Time-Wrong 
No 
Parse 
out 
RCF 
failure 
DEV 
27.6% 
10.9% 12.1% 12.1% 37.4% 
TEST 
11.4% 
1.8% 11.4% 
6.8% 68.6% 

(Correct: correct answer; Timeout: reasoning did not finish 

in 10 min; Wrong: wrong answer; No RCF: no RCF formula 

was obtained by rewriting the logical form; Parse failure: at 

least one sentence in the problem did not receive a CCG tree) 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_8" validated="false"><head>Table 6 :</head><label>6</label><figDesc></figDesc><table>Result of end-to-end problem solving 

Dataset 
Dep. 
Parsed Sentences (%) 
train 
N=1 N=5 N=10 N=20 

DEV 
News 
48.9 69.1 
72.6 
76.6 
News+Math 70.5 81.6 
84.6 
86.4 

TEST 
News 
46.6 58.7 
61.9 
64.7 
News+Math 59.3 65.3 
66.9 
68.3 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_10" validated="true"><head>Table 8 : Effect of parsing with type environment</head><label>8</label><figDesc></figDesc><table>Freq. Reason for the parse failures (on TEST-2007) 
17 Unknown usage of known content words 
9 Unknown content words 
8 Errors in coreference resolution 
4 Missing math expression interpretaions 
3 Unknown usage of known function words 
3 Unknown function words 
2 No correct dependency tree in 20-best 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_12" validated="true"><head>Table 10 : Accuracy of logical forms</head><label>10</label><figDesc></figDesc><table>Error type 
DEV-TEST-
1999 
2007 
Bind a variable or leave it free 
6 
2 
Wrong math expr. interpretaion 
6 
1 
Quantifier choice 
0 
3 
Quantifier scope 
1 
1 
Logical connective choice 
1 
1 
Logical connective scope 
1 
0 
Others 
1 
2 

</table></figure>

			<note place="foot" n="1"> Including all conditions expressed in the diagrams. 2 All the math formulas in the texts were replaced with a special token &quot;MATH&quot; before counting words. 3 ∧ and ∨ was counted as operators with arbitrary arity. E.g., there is only one ∧ in A ∧ B ∧ C.</note>

			<note place="foot" n="4"> In Fig. 3, the semantic part is in the dynamic logic format as in our real grammar where the dynamic binding (∃x; φ) → ψ is interpreted as ∀x(φ → ψ) in the standard predicate logic. Following our analysis of an analogous construction in Japanese, the null pronoun after &apos;the quotient&apos; is filled by analysing the second clause as including a gap rather than filling it by zero-pronoun resolution.</note>

			<note place="foot" n="5"> To be precise, we also consider the type constraints induced through the unification of the categories. It can be seen in the derivation step for &quot;n divides 12&quot; in Fig. 6, where the new constraint n :Z is induced by the unification of NP[α] and NP[Z] and merged into the environment of the parent.</note>

			<note place="foot" n="6"> No overlap with DEV and TEST sections of UNIV.</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Monica</forename><forename type="middle">S</forename><surname>Lam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ravi</forename><surname>Sethi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<title level="m">Compilers: Principles, Techniques, and Tools</title>
		<imprint>
			<publisher>Addison-Wesley Longman Publishing Co., Inc</publisher>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
	<note>2nd Edition</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Nihongo-bunpou no keishikiriron</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daisuke</forename><surname>Bekki</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2010" />
			<publisher>Kuroshio Shuppan</publisher>
		</imprint>
	</monogr>
	<note>in Japanese</note>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Natural language input for a computer problem solving system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bobrow</forename><surname>Daniel Gureasko</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1964" />
		</imprint>
		<respStmt>
			<orgName>Massachusetts Institute of Technology</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Computer solution of calculus word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Charniak</surname></persName>
		</author>
		<ptr target="http://dl.acm.org/citation.cfm?id=1624562.1624593" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1st International Joint Conference on Artificial Intelligence</title>
		<meeting>the 1st International Joint Conference on Artificial Intelligence<address><addrLine>San Francisco, CA, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1969" />
			<biblScope unit="page" from="303" to="316" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Truth and meaning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Donald</forename><surname>Davidson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Synthese</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="304" to="323" />
			<date type="published" when="1967" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">The gamut of dynamic logic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Van Eijck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Stokhof</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic and the Modalities in the Twentieth Century</title>
		<imprint>
			<publisher>Elsevier</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="499" to="600" />
		</imprint>
	</monogr>
	<note>Handbook of the History of Logic</note>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Gottlob Frege. 1892. ¨ Uber Sinn und Bedeutung</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Zeitschrift für Philosophie und philosophische Kritik</title>
		<imprint>
			<biblScope unit="volume">100</biblScope>
			<biblScope unit="page" from="25" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning to solve arithmetic word problems with verb categorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad Javad</forename><surname>Hosseini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannaneh</forename><surname>Hajishirzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="523" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Parsing algebraic word problems into equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rik</forename><surname>Koncel-Kedziorski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannaneh</forename><surname>Hajishirzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Sabharwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siena</forename><surname>Ang</surname></persName>
		</author>
		<ptr target="https://transacl.org/ojs/index.php/tacl/article/view/692" />
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="585" to="597" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Japanese dependency analysis using cascaded chunking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Taku</forename><surname>Kudo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuji</forename><surname>Matsumoto</surname></persName>
		</author>
		<ptr target="http://aclweb.org/anthology/W/W02/W02-2016.pdf" />
	</analytic>
	<monogr>
		<title level="m">CoNLL 2002: Proceedings of the 6th Conference on Natural Language Learning 2002 (COLING 2002 Post-Conference Workshops)</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="63" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Building A Japanese Parsed Corpus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sadao</forename><surname>Kurohashi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Makoto</forename><surname>Nagao</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2003" />
			<publisher>Springer</publisher>
			<biblScope unit="page" from="249" to="260" />
			<pubPlace>Netherlands, Dordrecht</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning to automatically solve algebra word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/P14-1026" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 52nd Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="271" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Inducing probabilistic ccg grammars from logical form with higher-order unification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharon</forename><surname>Goldwater</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2010 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1223" to="1233" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Lexical generalization in ccg grammar induction for semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Kwiatkowski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sharon</forename><surname>Goldwater</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="1512" to="1523" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Learning dependency-based compositional semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Klein</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/P11-1060" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 49th Annual Meeting of the Association for Computational Linguistics: Human Language Technologies</meeting>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="590" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Learning to use formulas to solve simple arithmetic problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arindam</forename><surname>Mitra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chitta</forename><surname>Baral</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/P16-1202" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2016" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="2144" to="2153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">English as a formal language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Montague</surname></persName>
		</author>
		<editor>Bruno Visentini, editor, Linguaggi nella Societa e nella Tecnica, Edizioni di Communità</editor>
		<imprint>
			<date type="published" when="1970" />
			<biblScope unit="page" from="189" to="224" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Universal grammar</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Montague</surname></persName>
		</author>
		<idno type="doi">10.1111/j.1755-2567.1970.tb00434.x</idno>
		<ptr target="https://doi.org/10.1111/j.1755-2567.1970.tb00434.x" />
	</analytic>
	<monogr>
		<title level="j">Theoria</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="373" to="398" />
			<date type="published" when="1970" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">The proper treatment of quantification in ordinary english</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Montague</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Patrick Suppes, Julius Moravcsik, and Jaakko Hintikka</title>
		<meeting><address><addrLine>Dordrecht</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1973" />
			<biblScope unit="page" from="221" to="242" />
		</imprint>
	</monogr>
	<note>Approaches to Natural Language</note>
</biblStruct>

<biblStruct xml:id="b20">
	<monogr>
		<title level="m" type="main">Types and Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Benjamin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pierce</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Solving general arithmetic word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhro</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Roth</surname></persName>
		</author>
		<ptr target="http://aclweb.org/anthology/D15-1202" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1743" to="1752" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">On denoting</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bertrand</forename><surname>Russell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mind</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">56</biblScope>
			<biblScope unit="page" from="479" to="493" />
			<date type="published" when="1905" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Solving geometry problems: Combining text and diagram interpretation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Minjoon</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hannaneh</forename><surname>Hajishirzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ali</forename><surname>Farhadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Clint</forename><surname>Malcolm</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1466" to="1476" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Automatically solving number word problems by semantic parsing and reasoning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuming</forename><surname>Shi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuehui</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chin-Yew</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojiang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yong</forename><surname>Rui</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="1132" to="1142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<monogr>
		<title level="m" type="main">The Syntactic Process. Bradford Books</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Taking Scope-The Natural Semantics of Quantifiers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<publisher>MIT Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Using multiple clause constructors in inductive logic programming for semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lappoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mooney</surname></persName>
		</author>
		<ptr target="http://www.cs.utexas.edu/users/ai-lab/?tang:ecml01" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 12th European Conference on Machine Learning</title>
		<meeting>the 12th European Conference on Machine Learning</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="466" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">The concept of truth in formalized languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><surname>Tarski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Logic, Semantics, Metamathematics</title>
		<editor>A. Tarski</editor>
		<imprint>
			<publisher>Oxford University Press</publisher>
			<date type="published" when="1936" />
			<biblScope unit="page" from="152" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">The semantic conception of truth: and the foundations of semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alfred</forename><surname>Tarski</surname></persName>
		</author>
		<ptr target="http://www.jstor.org/stable/2102968" />
	</analytic>
	<monogr>
		<title level="j">Philosophy and Phenomenological Research</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="341" to="376" />
			<date type="published" when="1944" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Learning from explicit and implicit supervision jointly for algebra word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shyam</forename><surname>Upadhyay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming-Wei</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai-Wei</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wen-Tau</forename><surname>Yih</surname></persName>
		</author>
		<ptr target="https://aclweb.org/anthology/D16-1029" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2016 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="297" to="306" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Online learning of relaxed ccg grammars for parsing to logical form</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the</title>
		<meeting>the</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
				<ptr target="http://www.aclweb.org/anthology/D07-1071" />
		<title level="m">Natural Language Processing and Computational Natural Language Learning</title>
		<imprint>
			<biblScope unit="page" from="678" to="687" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 21st Conference in Uncertainty in Artificial Intelligence</title>
		<meeting>the 21st Conference in Uncertainty in Artificial Intelligence</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="658" to="666" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Learn to solve algebra word problems using quadratic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lipu</forename><surname>Zhou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shuaixiang</forename><surname>Dai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Liwei</forename><surname>Chen</surname></persName>
		</author>
		<ptr target="http://aclweb.org/anthology/D15-1096" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="817" to="822" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
