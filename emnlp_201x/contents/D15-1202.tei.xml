<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T13:13+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Solving General Arithmetic Word Problems</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date type="published" when="2015-09">September 2015. 2015</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhro</forename><surname>Roy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<country>Urbana Champaign</country>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Roth</surname></persName>
							<email>danr@illinois.edu</email>
							<affiliation key="aff1">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<settlement>Urbana Champaign</settlement>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Solving General Arithmetic Word Problems</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
						<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing <address><addrLine>Lisbon, Portugal</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="17" to="21"/>
							<date type="published" when="2015-09">September 2015. 2015</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>This paper presents a novel approach to automatically solving arithmetic word problems. This is the first algorithmic approach that can handle arithmetic problems with multiple steps and operations, without depending on additional annotations or predefined templates. We develop a theory for expression trees that can be used to represent and evaluate the target arithmetic expressions; we use it to uniquely decompose the target arithmetic problem to multiple classification problems; we then compose an expression tree, combining these with world knowledge through a constrained inference framework. Our classifiers gain from the use of quantity schemas that supports better extraction of features. Experimental results show that our method outperforms existing systems, achieving state of the art performance on benchmark datasets of arithmetic word problems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In recent years there is growing interest in understand- ing natural language text for the purpose of answering science related questions from text as well as quanti- tative problems of various kinds. In this context, un- derstanding and solving arithmetic word problems is of specific interest. Word problems arise naturally when reading the financial section of a newspaper, following election coverage, or when studying elementary school arithmetic word problems. These problems pose an in- teresting challenge to the NLP community, due to its concise and relatively straightforward text, and seem- ingly simple semantics. Arithmetic word problems are usually directed towards elementary school students, and can be solved by combining the numbers men- tioned in text with basic operations (addition, subtrac- tion, multiplication, division). They are simpler than algebra word problems which require students to iden- tify variables, and form equations with these variables to solve the problem.</p><p>Initial methods to address arithmetic word problems have mostly focussed on subsets of problems, restrict- ing the number or the type of operations used <ref type="bibr" target="#b13">(Roy et al., 2015;</ref><ref type="bibr" target="#b7">Hosseini et al., 2014</ref>) but could not deal with multi-step arithmetic problems involving all four basic operations. The template based method of ( ), on the other hand, can deal with all types of problems, but implicitly assumes that the solution is generated from a set of predefined equation templates.</p><p>In this paper, we present a novel approach which can solve a general class of arithmetic problems with- out predefined equation templates. In particular, it can handle multiple step arithmetic problems as shown in Example 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 1</head><p>Gwen was organizing her book case making sure each of the shelves had exactly 9 books on it. She has 2 types of books -mystery books and picture books. If she had 3 shelves of mystery books and 5 shelves of picture books, how many books did she have in total?</p><p>The solution involves understanding that the number of shelves needs to be summed up, and that the total number of shelves needs to be multiplied by the num- ber of books each shelf can hold. In addition, one has to understand that the number "2" is not a direct part of the solution of the problem.</p><p>While a solution to these problems eventually re- quires composing multi-step numeric expressions from text, we believe that directly predicting this complex expression from text is not feasible.</p><p>At the heart of our technical approach is the novel notion of an Expression Tree. We show that the arith- metic expressions we are interested in can always be represented using an Expression Tree that has some unique decomposition properties. This allows us to de- compose the problem of mapping the text to the arith- metic expression to a collection of simple prediction problems, each determining the lowest common ances- tor operation between a pair of quantities mentioned in the problem. We then formulate the decision problem of composing the final expression tree as a joint infer- ence problem, via an objective function that consists of all these decomposed prediction problems, along with legitimacy and background knowledge constraints.</p><p>Learning to generate the simpler decomposed ex- pressions allows us to support generalization across problems types. In particular, our system could solve Example 1 even though it has never seen a problem that requires both addition and multiplication operations.</p><p>We also introduce a second concept, that of quantity schema, that allows us to focus on the information rel- evant to each quantity mentioned in the text. We show that features extracted from quantity schemas help rea- soning effectively about the solution. Moreover, quan- tity schemas help identify unnecessary text snippets in the problem text. For instance, in Example 2, the in- formation that "Tom washed cars over the weekend" is irrelevant; he could have performed any activity to earn money. In order to solve the problem, we only need to know that he had $76 last week, and now he has $86.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Example 2</head><p>Last week Tom had $74. He washed cars over the week- end and now has $86. How much money did he make from the job?</p><p>We combine the classifiers' decisions using a con- strained inference framework that allows for incorpo- rating world knowledge as constraints. For example, we deliberatively incorporate the information that, if the problems asks about an "amount", the answer must be positive, and if the question starts with "how many", the answer will most likely be an integer.</p><p>Our system is evaluated on two existing datasets of arithmetic word problems, achieving state of the art performance on both. We also create a new dataset of multistep arithmetic problems, and show that our sys- tem achieves competitive performance in this challeng- ing evaluation setting.</p><p>The next section describes the related work in the area of automated math word problem solving. We then present the theory of expression trees and our decom- position strategy that is based on it. Sec. 4 presents the overall computational approach, including the way we use quantity schemas to learn the mapping from text to expression tree components. Finally, we discuss our experimental study and conclude.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Previous work in automated arithmetic problem solvers has focussed on a restricted subset of problems. The system described in <ref type="bibr" target="#b7">(Hosseini et al., 2014</ref>) handles only addition and subtraction problems, and requires additional annotated data for verb categories. In con- trast, our system does not require any additional an- notations and can handle a more general category of problems. The approach in ( <ref type="bibr" target="#b13">Roy et al., 2015</ref>) sup- ports all four basic operations, and uses a pipeline of classifiers to predict different properties of the prob- lem. However, it makes assumptions on the number of quantities mentioned in the problem text, as well as the number of arithmetic steps required to solve the prob- lem. In contrast, our system does not have any such restrictions, effectively handling problems mentioning multiple quantities and requiring multiple steps. Kush- man's approach to automatically solving algebra word problems ( ) might be the most re- lated to ours. It tries to map numbers from the prob- lem text to predefined equation templates. However, they implicitly assume that similar equation forms have been seen in the training data. In contrast, our system can perform competitively, even when it has never seen similar expressions in training.</p><p>There is a recent interest in understanding text for the purpose of solving scientific and quantitative prob- lems of various kinds. Our approach is related to work in understanding and solving elementary school stan- dardized tests <ref type="bibr" target="#b3">(Clark, 2015)</ref>. The system described in <ref type="bibr" target="#b1">(Berant et al., 2014)</ref> attempts to automatically answer biology questions, by extracting the structure of bio- logical processes from text. There has also been efforts to solve geometry questions by jointly understanding diagrams and associated text ( <ref type="bibr" target="#b15">Seo et al., 2014)</ref>. A re- cent work ( <ref type="bibr" target="#b14">Sadeghi et al., 2015</ref>) tries to answer science questions by visually verifying relations from images.</p><p>Our constrained inference module falls under the general framework of Constrained Conditional Mod- els (CCM) ( <ref type="bibr" target="#b2">Chang et al., 2012</ref>). In particular, we use the L + I scheme of CCMs, which predicts structured output by independently learning several simple com- ponents, combining them at inference time. This has been successfully used to incorporate world knowledge at inference time, as well as getting around the need for large amounts of jointly annotated data for struc- tured prediction <ref type="bibr" target="#b9">Punyakanok et al., 2005;</ref><ref type="bibr" target="#b10">Punyakanok et al., 2008;</ref><ref type="bibr" target="#b4">Clarke and Lapata, 2006</ref>; <ref type="bibr" target="#b0">Barzilay and Lapata, 2006;</ref><ref type="bibr" target="#b13">Roy et al., 2015</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Expression Tree and Problem Decomposition</head><p>We address the problem of automatically solving arith- metic word problems. The input to our system is the problem text P , which mentions n quantities q 1 , q 2 , . . . , q n . Our goal is to map this problem to a read-once arithmetic expression E that, when evalu- ated, provides the problem's solution. We define a read-once arithmetic expression as one that makes use of each quantity at most once. We say that E is a valid expression, if it is such a Read-Once arithmetic expres- sion, and we only consider in this work problems that can be solved using valid expressions (it's possible that they can be solved also with invalid expressions).</p><p>An expression tree T for a valid expression E is a binary tree whose leaves represent quantities, and each internal node represents one of the four basic opera- tions. For a non-leaf node n, we represent the operation associated with it as (n), and its left and right child as lc(n) and rc(n) respectively. The numeric value of the quantity associated with a leaf node n is denoted as Q(n). Each node n also has a value associated with it, represented as VAL(n), which can be computed in a recursive way as follows:</p><formula xml:id="formula_0">VAL(n) = Q(n) if n is a leaf VAL(lc(n)) (n) VAL(rc(n)) otherwise (1)</formula><p>For any expression tree T for expression E with root node n root , the value of VAL(n root ) is exactly equal to the numeric value of the expression E. Therefore, this gives a natural representation of numeric expres- sions, providing a natural parenthesization of the nu- meric expression. <ref type="figure" target="#fig_0">Fig 1 shows</ref> an example of an arith- metic problem with solution expression and an expres- sion tree for the solution expression.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Problem</head><p>Gwen was organizing her book case making sure each of the shelves had exactly 9 books on it. She has 2 types of books -mystery books and picture books. If she had 3 shelves of mystery books and 5 shelves of picture books, how many books did she have total? Solution Expression Tree of Solution Definition An expression tree T for a valid expression E is called monotonic if it satisfies the following con- ditions:</p><p>1. If an addition node is connected to a subtraction node, then the subtraction node is the parent.</p><p>2. If a multiplication node is connected to a division node, then the division node is the parent.  Our decomposition relies on the idea of monotonic expression trees. We try to predict for each pair of quantities q i , q j , the operation at the lowest common ancestor (LCA) node of the monotonic expression tree for the solution expression. We also predict for each quantity, whether it is relevant to the solution. Finally, an inference module combines all these predictions.</p><p>In the rest of the section, we show that for any pair of quantities q i , q j in the solution expression, any mono- tonic tree for the solution expression has the same LCA operation. Therefore, predicting the LCA operation be- comes a multiclass classification problem.</p><p>The reason that we consider the monotonic represen- tation of the expression tree is that different trees could otherwise give different LCA operation for a given pair of quantities. For example, in <ref type="figure" target="#fig_2">Fig 2,</ref> the LCA opera- tion for quantities 5 and 8 can be + or −, depending on which tree is considered.</p><p>Definition We define an addition-subtraction chain of an expression tree to be the maximal connected set of nodes labeled with addition or subtraction.</p><p>The nodes of an addition-subtraction (AS) chain C represent a set of terms being added or subtracted. These terms are sub-expressions created by subtrees rooted at neighboring nodes of the chain. We call these terms the chain terms of C, and the whole expression, after node operations have been applied to the chain terms, the chain expression of C. Proof. The proof is procedural, that is, we provide a method to convert any expression tree to a monotonic expression tree for the same expression. Consider a non-monotonic expression tree E, and without loss of generality, assume that the first condition for mono- tonicity is not valid. Therefore, there exists an addi- tion node n i and a subtraction node n j , and n i is the parent of n j . Consider an addition-subtraction chain C which includes n i , n j . We now replace the nodes of C and its subtrees in the following way. We add a sin- gle subtraction node n − . The left subtree of n − has all the addition chain terms connected by addition nodes, and the right subtree of n − has all the subtraction chain terms connected by addition nodes. Both subtrees of n − only require addition nodes, hence monotonicity condition is satisfied. We can construct the monotonic tree in <ref type="figure">Fig</ref>  The same line of reasoning can be used to handle the second condition with multiplication and division re- placing addition and subtraction, respectively.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Theorem 3.2. Consider two valid expression trees T 1</head><p>and T 2 for the same expression E. Let C 1 , C 2 be the chain containing the root nodes of T 1 and T 2 re- spectively. The chain type (addition-subtraction or multiplication-division) as well as the the set of chain terms of C 1 and C 2 are identical.</p><p>Proof. We first prove that the chains containing the roots are both AS or both MD, and then show that the chain terms are also identical.</p><p>We prove by contradiction that the chain type is same. Let C 1 's type be "addition-subtraction" and C 2 's type be "multiplication-division" (without loss of gen- erality). Since both C 1 and C 2 generate the same ex- pression E, we have that E can be represented as sum (or difference) of two expressions as well as product(or division) of two expressions. Transforming a sum (or difference) of expressions to a product (or division) requires taking common terms from the expressions, which imply that the sum (or difference) had dupli- cate quantities. The opposite transformation adds same term to various expressions leading to multiple uses of the same quantity. Therefore, this will force at least one of C 1 and C 2 to use the same quantity more than once, violating validity.</p><p>We now need to show that individual chain terms are also identical. Without loss of generality, let us assume that both C 1 and C 2 are "addition-subtraction" chains. Suppose the chain terms of C 1 and C 2 are not identi- cal. The chain expression for both the chains will be the same (since they are root chains, the chain expressions has to be the same as E). Let the chain expression for C 1 be i t i − i t i , where t i 's are the addition chain terms and t i are the subtraction chain terms. Similarly, let the chain expression for C 2 be</p><formula xml:id="formula_1">i s i − i s i . We know that i t i − i t i = i s i − i s i</formula><p>, but the set of t i 's and t i 's is not the same as the set of s i and s i 's. However it should be possible to transform one form to the other using mathematical manipulations. This transformation will involve taking common terms, or multiplying two terms, or both. Following previous explanation, this will force one of the expressions to have duplicate quantities, violating validity. Hence, the chain terms of C 1 and C 2 are identical.</p><p>Consider an expression tree T for a valid expres- sion E. For a distinct pair of quantities q i , q j par- ticipating in expression E, we denote by n i , n j the leaves of the expression tree T representing q i , q j , re- spectively. Let n LCA (q i , q j ; T ) to be the lowest com- mon ancestor node of n i and n j . We also define order(q i , q j ; T ) to be true if n i appears in the left subtree of n LCA (q i , q j ; T ) and n j appears in the right subtree of n LCA (q i , q j ; T ) and set order(q i , q j ; T ) to false otherwise. Finally we define LCA (q i , q j ; T ) for a pair of quantities q i , q j as follows :</p><formula xml:id="formula_2">LCA (q i , q j , T ) =                                        + if (n LCA (q i , q j ; T )) = + × if (n LCA (q i , q j ; T )) = × −</formula><p>if (n LCA (q i , q j ; T )) = − and order(q i , q j ; T ) = true − reverse if (n LCA (q i , q j ; T )) = − and order(q i , q j ; T ) = f alse ÷ if (n LCA (q i , q j ; T )) = ÷ and order(q i , q j ; T ) = true ÷ reverse if (n LCA (q i , q j ; T )) = ÷ and order(q i , q j ; T ) = f alse</p><p>Definition Given two expression trees T 1 and T 2 for the same expression E, T 1 is LCA-equivalent to T 2 if for every pair quantities q i , q j in the expression E, we have LCA (q i , q j , T 1 ) = LCA (q i , q j , T 2 ).</p><p>Theorem 3.3. All monotonic expression trees for an expression are LCA-equivalent to each other.</p><p>Proof. We prove by induction on the number of quanti- ties used in an expression. For all expressions E with 2 quantities, there exists only one monotonic expression tree, and hence, the statement is trivially true. This sat- isfies our base case.</p><p>For the inductive case, we assume that for all expres- sions with k &lt; n quantities, the theorem is true. Now, we need to prove that any expression with n nodes will also satisfy the property.</p><p>Consider a valid (as in all cases) expression E, with monotonic expression trees T 1 and T 2 . From theorem 3.2, we know that the chains containing the roots of T 1 and T 2 have identical type and terms. Given two quantities q i , q j of E, the lowest common ancestor of both T 1 and T 2 will either both belong to the chain containing the root, or both belong to one of the chain terms. If the LCA node is part of the chain for both T 1 and T 2 , monotonic property ensures that the LCA operation will be identical. If the LCA node is part of a chain term (which is an expression tree of size less than n), the property is satisfied by induction hypothesis.</p><p>The theory just presented suggests that it is possible to uniquely decompose the overall problem to simpler steps and this will be exploited in the next section.</p><p>Consequently, our overall method proceeds as fol- lows: given the problem text P , we detect quantities q 1 , q 2 , . . . , q n . We then use two classifiers, one for rel- evance and other to predict the LCA operations for a monotonic expression tree of the solution. Our training makes use of the notion of quantity schemas, which we describe in Section 4.2. The distributional output of these classifiers is then used in a joint inference proce- dure that determines the final expression tree.</p><p>Our training data consists of problem text paired with a monotonic expression tree for the solution ex- pression. Both the relevance and LCA operation clas- sifiers are trained on gold annotations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Global Inference for Expression Trees</head><p>In this subsection, we define the scoring functions cor- responding to the decomposed problems, and show how we combine these scores to perform global infer- ence. For a problem P with quantities q 1 , q 2 , . . . , q n , we define the following scoring functions:</p><p>1. PAIR(q i , q j , op) : Scores the likelihood of LCA (q i , q j , T ) = op, where T is a monotone expression tree of the solution expression of P . A multiclass classifier trained to predict LCA opera- tions (Section 4.4) can provide these scores.</p><p>2. IRR(q) : Scores the likelihood of quantity q being an irrelevant quantity in P , that is, q is not used in creating the solution. A binary classifier trained to predict whether a quantity q is relevant or not (Section 4.3), can provide these scores.</p><p>For an expression E, let I(E) be the set of all quanti- ties in P which are not used in expression E. Let T be a monotonic expression tree for E. We define Score(E) of an expression E in terms of the above scoring func- tions and a scaling parameter w IRR as follows:</p><formula xml:id="formula_4">Score(E) =w IRR q∈I(E) IRR(q)+ (3) qi,qj / ∈I(E) PAIR(q i , q j , LCA (q i , q j , T ))</formula><p>Our final expression tree is an outcome of a con- strained optimization process, following <ref type="bibr" target="#b11">(Roth and Yih, 2004;</ref><ref type="bibr" target="#b2">Chang et al., 2012)</ref>. Our objective function makes use of the scores returned by IRR(·) and PAIR(·) to determine the expression tree and is constrained by legitimacy and background knowledge constraints, de- tailed below.</p><p>1. Positive Answer: Most arithmetic problems ask- ing for amounts or number of objects usually have a positive number as an answer. Therefore, while searching for the best scoring expression, we re- ject expressions generating negative answer.</p><p>2. Integral Answer: Problems with questions such as 'how many" usually expect integral solutions.</p><p>We only consider integral solutions as legitimate outputs for such problems.</p><p>Let C be the set of valid expressions that can be formed using the quantities in a problem P , and which satisfy the above constraints. The inference algorithm now becomes the following:</p><formula xml:id="formula_5">arg max E∈C Score(E)<label>(4)</label></formula><p>The space of possible expressions is large, and we employ a beam search strategy to find the highest scoring constraint satisfying expression ( <ref type="bibr" target="#b2">Chang et al., 2012</ref>). We construct an expression tree using a bottom up approach, first enumerating all possible sets of irrel- evant quantities, and next over all possible expressions, keeping the top k at each step. We give details below.</p><p>1. Enumerating Irrelevant Quantities: We gener- ate a state for all possible sets of irrelevant quan- tities, ensuring that there is at least two relevant quantities in each state. We refer to each of the rel- evant quantities in each state as a term. Therefore, each state can be represented as a set of terms.</p><p>2. Enumerating Expressions: For generating a next state S from S, we choose a pair of terms t i and t j in S and one of the four basic operations, and form a new term by combining terms t i and t j with the operation. Since we do not know which of the possible next states will lead to the optimal goal state, we enumerate all possible next states (that is, enumerate all possible pairs of terms and all possible operations); we prune the beam to keep only the top k candidates. We terminate when all the states in the beam have exactly one term.</p><p>Once we have a top k list of candidate expression trees, we choose the highest scoring tree which satisfies the constraints. However, there might not be any tree in the beam which satisfies the constraints, in which case, we choose the top candidate in the beam. We use k = 200 in our experiments.</p><p>In order to choose the value for the w IRR , we search over the set {10 −6 , 10 −4 , 10 −2 , 1, 10 2 , 10 4 , 10 6 }, and choose the parameter setting which gives the highest accuracy on the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Quantity Schema</head><p>In order to generalize across problem types as well as over simple manipulations of the text, it is neces- sary to train our system only with relevant information from the problem text. E.g., for the problem in exam- ple 2, we do not want to take decisions based on how Tom earned money. Therefore, there is a need to ex- tract the relevant information from the problem text. To this end, we introduce the concept of a quantity schema which we extract for each quantity in the prob- lem's text. Along with the question asked, the quantity schemas provides all the information needed to solve most arithmetic problems.</p><p>A quantity schema for a quantity q in problem P consists of the following components.</p><p>1. Associated Verb For each quantity q, we detect the verb associated with it. We traverse up the dependency tree starting from the quantity men- tion, and choose the first verb we reach. We used the easy first dependency parser <ref type="bibr" target="#b5">(Goldberg and Elhadad, 2010</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Subject of Associated Verb</head><p>We detect the noun phrase, which acts as subject of the associated verb (if one exists).</p><p>3. Unit We use a shallow parser to detect the phrase p in which the quantity q is mentioned. All to- kens of the phrase (other than the number itself) are considered as unit tokens. Also, if p is fol- lowed by the prepositional phrase "of" and a noun phrase (according to the shallow parser annota- tions), we also consider tokens from this second noun phrase as unit tokens. Finally, if no unit token can be extracted, we assign the unit of the neighboring quantities as the unit of q (following previous work <ref type="bibr" target="#b7">(Hosseini et al., 2014)</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Related Noun Phrases</head><p>We consider all noun phrases which are connected to the phrase p con- taining quantity q, with NP-PP-NP attachment. If only one quantity is mentioned in a sentence, we consider all noun phrases in it as related.</p><p>5. Rate We determine whether quantity q refers to a rate in the text, as well as extract two unit compo- nents defining the rate. For example, "7 kilome- ters per hour" has two components "kilometers" and "hour". Similarly, for sentences describing unit cost like "Each egg costs 2 dollars", "2" is a rate, with units "dollars" and "egg".</p><p>In addition to extracting the quantity schemas for each quantity, we extract the surface form text which poses the question. For example, in the question sen- tence, "How much will John have to pay if he wants to buy 7 oranges?", our extractor outputs "How much will John have to pay" as the question.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Relevance Classifier</head><p>We train a binary SVM classifier to determine, given problem text P and a quantity q in it, whether q is needed in the numeric expression generating the solu- tion. We train on gold annotations and use the score of the classifier as the scoring function IRR(·).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Features</head><p>The features are extracted from the quantity schemas and can be broadly categorized into three groups:</p><p>1. Unit features: Most questions specifically men- tion the object whose amount needs to be com- puted, and hence questions provide valuable clue as to which quantities can be irrelevant. We add a feature for whether the unit of quantity q is present in the question tokens. Also, we add a feature based on whether the units of other quantities have better matches with question tokens (based on the number of tokens matched), and one based on the number of quantities which have the maximum number of matches with the question tokens.</p><p>2. Related NP features: Often units are not enough to differentiate between relevant and irrelevant quantities. Consider the following: The relevance decision depends on the noun phrase "the pile", which is absent in the second sentence. We add a feature indicating whether a related noun phrase is present in the question. Also, we add a feature based on whether the re- lated noun phrases of other quantities have bet- ter match with the question. Extraction of related noun phrases is described in Section 4.2.</p><p>3. Miscellaneous Features: When a problem men- tions only two quantities, both of them are usually relevant. Hence, we also add a feature based on the number of quantities mentioned in text.</p><p>We include pairwise conjunction of the above fea- tures.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">LCA Operation Classifier</head><p>In order to predict LCA operations, we train a multi- class SVM classifier. Given problem text P and a pair of quantities p i and p j , the classifier predicts one of the six labels described in Eq. 2. We consider the confi- dence scores for each label supplied by the classifier as the scoring function PAIR(·).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4.1">Features</head><p>We use the following categories of features:</p><p>1. Individual Quantity features: Dependent verbs have been shown to play significant role in solv- ing addition and subtraction problems ( <ref type="bibr" target="#b7">Hosseini et al., 2014</ref>). Hence, we add the dependent verb of the quantity as a feature. Multiplication and division problems are largely dependent on rates described in text. To capture that, we add a fea- ture based on whether the quantity is a rate, and whether any component of rate unit is present in the question. In addition to these quantity schema features, we add selected tokens from the neigh- borhood of the quantity mention. Neighborhood of quantities are often highly informative of LCA operations, for example, "He got 80 more mar- bles", the term "more" usually indicates addition. We add as features adverbs and comparative ad- jectives mentioned in a window of size 5 around the quantity mention.</p><p>2. Quantity Pair features: For a pair (q i , q j ) we add features to indicate whether they have the same dependent verbs, to indicate whether both depen- dent verbs refer to the same verb mention, whether the units of q i and q j are the same and, if one of them is a rate, which component of the unit matches with the other quantity's unit. Finally, we add a feature indicating whether the value of q i is greater than the value of q j .</p><p>3. Question Features: Finally, we add a few fea- tures based on the question asked. In particular, for arithmetic problems where only one operation is needed, the question contains signals for the re- quired operation. Specifically, we add indicator features based on whether the question mentions comparison-related tokens (e.g., "more", "less" or "than"), or whether the question asks for a rate (indicated by tokens such as "each" or "one").</p><p>We include pairwise conjunction of the above fea- tures. For both classifiers, we use the Illinois-SL pack- age 1 under default settings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experimental Results</head><p>In this section, we evaluate the proposed method on publicly available datasets of arithmetic word prob- lems. We evaluate separately the relevance and LCA operation classifiers, and show the contribution of var- ious features. Lastly, we evaluate the performance of the full system, and quantify the gains achieved by the constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Datasets</head><p>We evaluate our system on three datasets, each of which comprise a different category of arithmetic word problems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">IL Dataset: This is a collection of arithmetic</head><p>problems released by <ref type="bibr" target="#b13">(Roy et al., 2015)</ref>. Each of these problems can be solved by performing one operation. However, there are multiple problems having the same template. To counter this, we per- form a few modifications to the dataset. First, for each problem, we replace the numbers and nouns with the part of speech tags, and then we cluster the problems based on unigrams and bigrams from this modified problem text. In particular, we clus- ter problems together whose unigram-bigram sim- ilarity is over 90%. We next prune each cluster to keep at most 5 problems in each cluster. Finally we create the folds ensuring all problems in a clus- ter are assigned to the same fold, and each fold has similar distribution of all operations. We have a fi- nal set of 562 problems, and we use a 5-fold cross validation to evaluate on this dataset.</p><p>3. Commoncore Dataset: In order to test our sys- tem's ability to handle multi-step problems, we create a new dataset of multi-step arithmetic problems. The problems were extracted from www.commoncoresheets.com. In total, there were 600 problems, 100 for each of the following types:</p><p>(a) Addition followed by Subtraction This dataset had no irrelevant quantities. There- fore, we did not use the relevance classifier in our evaluations.</p><p>In order to test our system's ability to generalize across problem types, we perform a 6-fold cross validation, with each fold containing all the prob- lems from one of the aforementioned categories. This is a more challenging setting relative to the individual data sets mentioned above, since we are evaluating on multi-step problems, without ever looking at problems which require the same set of operations. <ref type="table" target="#tab_2">Table 2</ref> evaluates the performance of the relevance clas- sifier on the AI2 and IL datasets. We report two accu- racy values: Relax -fraction of quantities which the classifier got correct, and Strict -fraction of math prob- lems, for which all quantities were correctly classified. We report accuracy using all features and then remov- ing each feature group, one at a time.   We see that features related to units of quantities play the most significant role in determining relevance of quantities. Also, the related NP features are not helpful for the AI2 dataset. <ref type="table" target="#tab_1">Table 1</ref> evaluates the performance of the LCA Oper- ation classifier on the AI2, IL and CC datasets. As before, we report two accuracies -Relax -fraction of quantity pairs for which the classifier correctly pre- dicted the LCA operation, and Strict -fraction of math problems, for which all quantity pairs were correctly classified. We report accuracy using all features and then removing each feature group, one at a time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Relevance Classifier</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">LCA Operation Classifier</head><p>The strict and relaxed accuracies for IL dataset are identical, since each problem in IL dataset only re- quires one operation. The features related to individual quantities are most significant; in particular, the accu- racy goes to 0.0 in the CC dataset, without using indi- vidual quantity features. The question features are not helpful for classification in the CC dataset. This can be attributed to the fact that all problems in CC dataset re- quire multiple operations, and questions in multi-step problems usually do not contain information for each of the required operations. <ref type="table" target="#tab_4">Table 3</ref> shows the performance of our system in cor- rectly solving arithmetic word problems. We show the impact of various contraints, and also compare against previously best known results on the AI2 and IL datasets. We also show results using each of the two constraints separately, and using no constraints at all.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Global Inference Module</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AI2</head><p>IL  The previously known best result in the AI2 dataset is reported in ( <ref type="bibr" target="#b7">Hosseini et al., 2014</ref>). Since we follow the exact same evaluation settings, our results are di- rectly comparable. We achieve state of the art results, without having access to any additional annotated data, unlike <ref type="bibr" target="#b7">(Hosseini et al., 2014</ref>), who use labeled data for verb categorization. For the IL dataset, we acquired the system of ( <ref type="bibr" target="#b13">Roy et al., 2015</ref>) from the authors, and ran it with the same fold information. We outperform their system by an absolute gain of over 20%. We believe that the improvement was mainly due to the depen- dence of the system of ( <ref type="bibr" target="#b13">Roy et al., 2015</ref>) on lexical and neighborhood of quantity features. In contrast, features from quantity schemas help us generalize across prob- lem types. Finally, we also compare against the tem- plate based system of ( . <ref type="bibr" target="#b7">(Hosseini et al., 2014</ref>) mentions the result of running the system of ( ) on AI2 dataset, and we report their result here. For IL and CC datasets, we used the system released by ).</p><p>The integrality constraint is particularly helpful when division is involved, since it can lead to fractional answers. It does not help in case of the AI2 dataset, which involves only addition and subtraction problems. The role of the constraints becomes more significant in case of multi-step problems and, in particular, they con- tribute an absolute improvement of over 15% over the system without constraints on the CC dataset. The tem- plate based system of ( ) performs on par with our system on the IL dataset. We believe that it is due to the small number of equation templates in the IL dataset. It performs poorly on the CC dataset, since we evaluate on unseen problem types, which do not ensure that equation templates in the test data will be seen in the training data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.5">Discussion</head><p>The leading source of errors for the classifiers are er- roneous quantity schema extraction and lack of under- standing of unknown or rare verbs. For the relevance classifier on the AI2 dataset, 25% of the errors were due to mistakes in extracting the quantity schemas and 20% could be attributed to rare verbs. For the LCA operation classifier on the same dataset, 16% of the er- rors were due to unknown verbs and 15% were due to mistakes in extracting the schemas. The erroneous ex- traction of accurate quantity schemas is very significant for the IL dataset, contributing 57% of the errors for the relevance classifier and 39% of the errors for the LCA operation classifier. For the operation classifier on the CC dataset, 8% of the errors were due to verbs and 16% were due to faulty quantity schema extraction. Quan- tity Schema extraction is challenging due to parsing is- sues as well as some non-standard rate patterns, and it will be one of the future work targets. For example, in the sentence, "How many 4-dollar toys can he buy?", we fail to extract the rate component of the quantity 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper presents a novel method for understanding and solving a general class of arithmetic word prob- lems. Our approach can solve all problems whose so- lution can be expressed by a read-once arithmetic ex- pression, where each quantity from the problem text appears at most once in the expression. We develop a novel theoretical framework, centered around the no- tion of monotone expression trees, and showed how this representation can be used to get a unique decom- position of the problem. This theory naturally leads to a computational solution that we have shown to uniquely determine the solution -determine the arithmetic oper- ation between any two quantities identified in the text. This theory underlies our algorithmic solution -we de- velop classifiers and a constrained inference approach that exploits redundancy in the information, and show that this yields strong performance on several bench- mark collections. In particular, our approach achieves state of the art performance on two publicly available arithmetic problem datasets and can support natural generalizations. Specifically, our approach performs competitively on multistep problems, even when it has never observed the particular problem type before.</p><p>Although we develop and use the notion of expres- sion trees in the context of numerical expressions, the concept is more general. In particular, if we allow leaves of expression trees to represent variables, we can express algebraic expressions and equations in this framework. Hence a similar approach can be targeted towards algebra word problems, a direction we wish to investigate in the future.</p><p>The datasets used in the paper are available for download at http://cogcomp.cs.illinois.edu/page/resource view/98.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: An arithmetic word problem, solution expression and the corresponding expression tree</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig</head><label></label><figDesc>Fig 2 shows two different expression trees for the same expression. Fig 2b is monotonic whereas fig 2a is not.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Two different expression trees for the numeric expression (3 × 5) + 7 − 8 − 9. The right one is monotonic, whereas the left one is not.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>For example, in fig 2, the shaded nodes form an addition-subtraction chain. The chain expression is (3×5)+7−8−9, and the chain terms are 3 × 5, 7, 8 and 9. We define a multiplication- division (MD) chain in a similar way. Theorem 3.1. Every valid expression can be repre- sented by a monotonic expression tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>2b from the non-monotonic tree of Fig 2a us- ing this procedure. The addition chain terms are 3 × 5 and 7, and the subtraction chain terms are 8 and 9. As as was described above, we introduce the root subtrac- tion node in Fig 2b and attach the addition chain terms to the left and the subtraction chain terms to the right.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>There are 8 apples in a pile on the desk. Each apple comes in a package of 11. 5 apples are added to the pile. How many apples are there in the pile? Solution : (8 + 5) = 13</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>(</head><label></label><figDesc>b) Subtraction followed by Addition (c) Addition and Multiplication (d) Addition and Division (e) Subtraction and Multiplication (f) Subtraction and Division</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="true"><head>Table 1 : Performance of LCA Operation classifier on the datasets AI2, IL and CC.</head><label>1</label><figDesc></figDesc><table>AI2 
IL 
Relax Strict 
Relax Strict 
All features 
94.7 
89.1 
95.4 
93.2 
No Unit features 
88.9 
71.5 
92.8 
91.0 
No NP features 
94.9 
89.6 
95.0 
91.2 
No Misc. features 
92.0 
85.9 
93.7 
89.8 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>Performance of Relevance classifier on the datasets 

AI2 and IL. 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc>Accuracy in correctly solving arithmetic problems. First four rows represent various configurations of our sys- tem. We achieve state of the art results in both AI2 and IL datasets.</figDesc><table></table></figure>

			<note place="foot" n="4"> Mapping Problems to Expression Trees Given the uniqueness properties proved in Sec. 3, it is sufficient to identify the operation between any two relevant quantities in the text, in order to determine the unique valid expression. In fact, identifying the operation between any pair of quantities provides much needed redundancy given the uncertainty in identifying the operation from text, and we exploit it in our final joint inference.</note>

			<note place="foot" n="1">. AI2 Dataset: This is a collection of 395 addition and subtraction problems, released by (Hosseini et al., 2014). They performed a 3-fold cross validation, with every fold containing problems from different sources. This helped them evaluate robustness to domain diversity. We follow the same evaluation setting. 1 http://cogcomp.cs.illinois.edu/page/software view/IllinoisSL</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This research was sponsored by DARPA (under agree-ment number FA8750-13-2-0008), and a grant from AI2. Any opinions, findings, conclusions or recom-mendations are those of the authors and do not nec-essarily reflect the view of the agencies.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Aggregation via Set Partitioning for Natural Language Generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barzilay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Human Language Technologies-North American Chapter of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2006-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Modeling biological processes for reading comprehension</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Srikumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Linden</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Harding</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EMNLP</title>
		<meeting>EMNLP</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Structured learning with constrained conditional models. Machine Learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Ratinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="volume">88</biblScope>
			<biblScope unit="page" from="399" to="431" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Elementary School Science and Math Tests as a Driver for AI: Take the Aristo Challenge! In Proceedings of IAAI</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Clark</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Constraint-based sentence compression: An integer programming approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Clarke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL)</title>
		<meeting>the Annual Meeting of the Association for Computational Linguistics (ACL)<address><addrLine>Sydney, Australia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006-07" />
			<biblScope unit="page" from="144" to="151" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">An efficient algorithm for easy-first non-directional dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Goldberg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Elhadad</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Human Language Technologies: The</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
				<title level="m">Annual Conference of the North American Chapter of the Association for Computational Linguistics</title>
		<meeting><address><addrLine>Los Angeles, California</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="742" to="750" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Learning to solve arithmetic word problems with verb categorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Hosseini</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hajishirzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kushman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2014 Conference on Empirical Methods in Natural Language Processing<address><addrLine>Doha, Qatar</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-10" />
			<biblScope unit="page" from="523" to="533" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Learning to automatically solve algebra word problems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Barzilay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Artzi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="271" to="281" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The necessity of syntactic parsing for semantic role labeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Punyakanok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>of the International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="1117" to="1123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The importance of syntactic parsing and inference in semantic role labeling</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Punyakanok</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page">34</biblScope>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A linear programming formulation for global inference in natural language tasks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conference on Computational Natural Language Learning (CoNLL)</title>
		<editor>Hwee Tou Ng and Ellen Riloff</editor>
		<meeting>of the Conference on Computational Natural Language Learning (CoNLL)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Integer linear programming inference for conditional random fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Yih</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the International Conference on Machine Learning (ICML)</title>
		<meeting>of the International Conference on Machine Learning (ICML)</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="737" to="744" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reasoning about quantities in natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Roy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Vieira</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Roth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="page">3</biblScope>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Viske: Visual knowledge extraction and question answering by visual verification of relation phrases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sadeghi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Divvala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Farhadi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The IEEE Conference on Computer Vision and Pattern Recognition (CVPR)</title>
		<imprint>
			<date type="published" when="2015-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Diagram understanding in geometry questions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Seo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hajishirzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Farhadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Etzioni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Eighth AAAI Conference on Artificial Intelligence</title>
		<meeting>the Twenty-Eighth AAAI Conference on Artificial Intelligence<address><addrLine>Québec City, Québec, Canada</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014-07-27" />
			<biblScope unit="page" from="2831" to="2838" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
