<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:41+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Quasi-Second-Order Parsing for 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>September 7-11, 2017. 2017</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junjie</forename><surname>Cao</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="laboratory">The MOE Key Laboratory of Computational Linguistics</orgName>
								<orgName type="institution" key="instit1">Peking University</orgName>
								<orgName type="institution" key="instit2">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sheng</forename><surname>Huang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="laboratory">The MOE Key Laboratory of Computational Linguistics</orgName>
								<orgName type="institution" key="instit1">Peking University</orgName>
								<orgName type="institution" key="instit2">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Sun</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="laboratory">The MOE Key Laboratory of Computational Linguistics</orgName>
								<orgName type="institution" key="instit1">Peking University</orgName>
								<orgName type="institution" key="instit2">Peking University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Wan</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Institute of Computer Science and Technology</orgName>
								<orgName type="laboratory">The MOE Key Laboratory of Computational Linguistics</orgName>
								<orgName type="institution" key="instit1">Peking University</orgName>
								<orgName type="institution" key="instit2">Peking University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Quasi-Second-Order Parsing for 1-Endpoint-Crossing, Pagenumber-2 Graphs</title>
					</analytic>
					<monogr>
						<title level="m">Natural Language Processing</title>
						<meeting> <address><addrLine>Copenhagen, Denmark</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="24" to="34"/>
							<date type="published">September 7-11, 2017. 2017</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>We propose a new Maximum Subgraph algorithm for first-order parsing to 1-endpoint-crossing, pagenumber-2 graphs. Our algorithm has two characteristics: (1) it separates the construction for noncross-ing edges and crossing edges; (2) in a single construction step, whether to create a new arc is deterministic. These two characteristics make our algorithm relatively easy to be extended to incorpo-riate crossing-sensitive second-order features. We then introduce a new algorithm for quasi-second-order parsing. Experiments demonstrate that second-order features are helpful for Maximum Subgraph parsing.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Previous work showed that treating semantic de- pendency parsing as the search for Maximum Sub- graphs is not only elegant in theory but also ef- fective in practice ( <ref type="bibr" target="#b11">Kuhlmann and Jonsson, 2015;</ref>). In particular, our previous work showed that 1-endpoint-crossing, pagenumber-2 (1EC/P2) graphs are an appropriate graph class for modelling semantic dependency structures ). On the one hand, it is highly expres- sive to cover a majority of semantic analysis. On the other hand, the corresponding Maximum Sub- graph problem with an arc-factored disambigua- tion model can be solved in low-degree polyno- mial time.</p><p>Defining disambiguation models on wider con- texts than individual bi-lexical dependencies im- proves various syntactic parsers in different ar- chitectures. This paper studies exact algorithms for second-order parsing for 1EC/P2 graphs. The existing algorithm, viz. our previous algorithm (GCHSW, hereafter), has two properties that make it hard to incorporate higher-order features in a principled way. First, GCHSW does not explicitly consider the construction of noncrossing arcs. We will show that incorporiating higher-order factors containing crossing arcs without increasing time and space complexity is extremely hard. An effec- tive strategy is to only include higher-order factors containing only noncrossing arcs <ref type="bibr" target="#b15">(Pitler, 2014)</ref>. But this crossing-sensitive strategy is incompat- ible with GCHSW. Second, all existing higher- order parsing algorithms for projective trees, in- cluding ( <ref type="bibr" target="#b12">McDonald and Pereira, 2006;</ref><ref type="bibr" target="#b2">Carreras, 2007;</ref><ref type="bibr" target="#b10">Koo and Collins, 2010)</ref>, require that which arcs are created in a construction step be deter- ministic. This design is also incompatible with <ref type="bibr">GCHSW.</ref> In summary, it is not convenient to ex- tend GCHSW to incorporate higher-order features while keeping the same time complexity.</p><p>In this paper, we introduce an alternative Max- imum Subgraph algorithm for first-order parsing to 1EC/P2 graphs. while keeping the same time and space complexity to GCHSW, our new algo- rithm has two characteristics that make it rela- tively easy to be extended to incorporate crossing- sensitive, second-order features: (1) it separates the construction for noncrossing edges and pos- sible crossing edges; (2) whether an edge is cre- ated is deterministic in each construction rule. We then introduce a new algorithm to perform second- order parsing. When all second-order scores are greater than or equal to 0, it exactly solves the cor- responding optimization problem.</p><p>We implement a practical parser with a sta- tistical disambiguation model and evaluate it on four data sets: those used in <ref type="bibr" target="#b14">SemEval 2014</ref><ref type="bibr">Task 8 (Oepen et al., 2014</ref>, and the dependency graphs extracted from <ref type="bibr">CCGbank (Hockenmaier and Steedman, 2007)</ref>. On all data sets, we find that our second-order parsing models are more ac-curate than the first-order baseline. If we do not use features derived from syntactic trees, we get an absolute unlabeled F-score improvement of 1.3 on average. When syntactic analysis is used, we get an improvement of 0.4 on average.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Preliminaries</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Maximum Subgraph Parsing</head><p>Semantic dependency parsing can be formulated as the search for Maximum Subgraph for graph class G: Given a graph G = (V, A), find a subset A ⊆ A with maximum total score such that the induced subgraph G = (V, A ) belongs to G. For- mally, we have the following optimization prob- lem:</p><p>arg max</p><formula xml:id="formula_0">G * ∈G(s,G) p in G * s part (s, p)</formula><p>G(s, G) denotes the set of all graphs that belong to G and are compatible with s and G. G is usually a complete digraph. s part (s, p) evaluates the event that part p (from a candidate graph G * ) is good. We define the order of p according to the num- ber of arcs it contains, in analogy with tree parsing in terminology. Previous work only discussed the first-order case:</p><p>arg max</p><formula xml:id="formula_1">G * ∈G(G) d∈ARC(G * ) s arc (d)</formula><p>If G is the set of noncrossing or 1EC/P2 graphs, the above optimization problem can be solved in cubic-time ( <ref type="bibr" target="#b11">Kuhlmann and Jonsson, 2015)</ref> and quintic-time (  respectively. Fur- thermore, ignoring one linguistically-rare struc- ture in 1EC/P2 graphs descreases the complexity to O(n 4 ). This paper is concerned with second- order parsing, with a special focus on the follow- ing factorizations:</p><p>And the objective function turns to be: Figure 2: A pagenumber-2 graph. The upper and the lower figures represent two half-planes respec- tively.</p><formula xml:id="formula_2">d∈ARC(G * ) s arc (d) + s∈SIB(G * ) s sib (s)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">1-Endpoint-Crossing, Pagenumber-2 Graphs</head><p>The formal description of the 1-endpoint-crossing property is adopted from <ref type="bibr" target="#b16">(Pitler et al., 2013)</ref>.</p><formula xml:id="formula_3">Definition 1.</formula><p>Edges e 1 and e 2 cross if e 1 and e 2 have distinct endpoints and exactly one of the end- points of e 1 lies between the endpoints of e 2 .</p><p>Definition 2. A dependency graph is 1-Endpoint- Crossing if for any edge e, all edges that cross e share an endpoint p named pencil point.</p><p>Given a sentence s = w 0 w 1 · · · w n−1 of length n, the vertices, i.e. words, are indexed with inte- gers, an arc from w i to w j as a <ref type="bibr">(i,j)</ref> , and the com- mon endpoint, namely pencil point, of all edges crossed with a (i,j) or a (j,i) as pt(i, j). We denote an edge as e (i,j) , if we do not consider its direction. <ref type="figure">Figure 1</ref> is an example. Definition 3. A pagenumber-k graph means it consists at most k half-planes, and arcs on each half-plane are noncrossing.</p><p>These half-planes may be thought of as the pages of a book, with the vertex line correspond- ing to the books spine, and the embedding of a graph into such a structure is known as a book em- bedding. <ref type="figure">Figure 2</ref> is an example.</p><p>( <ref type="bibr" target="#b16">Pitler et al., 2013)</ref> proved that 1-endpoint- crossing trees are a subclass of graphs whose pa- genumber is at most 2. In , we studied graphs that are constrained to be both 1-endpoint-crossing and pagenumber-2. In this paper, we ignored a complex and linguistic-rare  To decompose this structure, GCHSW focuses on e (i,j) and e (l,j) , because these two edges can be optionally created without violation of both 1EC and P2 restrictions. Our algorithm focuses on the existence of e <ref type="bibr">(i,k)</ref> , and makes it the only edge that is constructed by applying a corresponding rule.</p><p>structure and studied a subset of 1EC/P2 graphs. The complex structure is named as C structures in our previous paper, and <ref type="figure" target="#fig_0">Figure 3</ref> is the prototype of C structures. In this paper, we present new algo- rithms for finding optimal 1EC/P2, C-free graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">The GCHSWAlgorithm</head><p>Cao et al. (2017) designed a polynomial time Maximum Subgraph algorithm, viz. GCHSW, for 1EC/P2 graphs by exploring the following prop- erty: Every subgraph of a 1EC/P2 graph is also a 1EC/P2 graph. GCHSW defines a number of proto- type backbones for decomposing a 1EC/P2 graph in a principled way. In each decomposition step, GCHSW focuses on the edges that can be created without violating either the 1EC nor P2 restriction. Sometimes, multiple edges can be created simulta- neously in one single step. <ref type="figure" target="#fig_1">Figure 4</ref> is an example.</p><p>There is an important difference between GCHSW and Eisner-style Maximum Spanning Tree algorithms <ref type="bibr">(MST;</ref><ref type="bibr" target="#b4">Eisner, 1996;</ref><ref type="bibr" target="#b12">McDonald and Pereira, 2006;</ref><ref type="bibr" target="#b10">Koo and Collins, 2010)</ref>. In each construction step, GCHSW allows multiple arcs to be constructed, but whether or not such arcs are added to the target graph depends on their arc-weights. If all arcs are assigned scores that are greater than 0, the output of our algorithm in- cludes the most complicated 1EC/P2 graphs. For the higher-order MST algorithms, in a single con- struction step, it is clear whether adding a new arc, and which one. There is no local search. This de- terministic strategy is also followed by Kuhlmann and Jonsson's Maximum Subgraph algorithm for noncrossing graphs. Higher-order MST models associate higher-order score functions with the construction of individual dependencies. There- fore the deterministic strategy is a prerequisite to incorporate higher-order features. The design of GCHSW is incompatible with this strategy.</p><formula xml:id="formula_4">x i k j r i l j r x</formula><p>Figure 5: A typical structure of crossing arcs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Challenge of Second-Order Decoding</head><p>It is very difficult to enumerate all high-order fea- tures for crossing arcs. <ref type="figure">Figure 5</ref> illustrates the idea. There is a pair of corssing arcs, viz. e <ref type="bibr">(x,k)</ref> and e (i,j) . The key strategy to develop a dynamic programming algorithm to generate such crossing structure is to treat parts of this structures as inter- vals/spans together with an external vertex ( <ref type="bibr" target="#b16">Pitler et al., 2013;</ref>. Without loss of gen- erality, we assume [i, j] makes up such an interval and x is the corresponding external vertex. When we consider e (i,j) , its neighboring edges can be e (i,r i ) and e (l j ,j) , and therefore we need to con- sider searching the best positions of both r i and l j . Because we have already taken into account three vertices, viz. x, i and j, the two new positions increase the time complexity to be at least quintic.</p><p>Now consider e (x,k) . When we decompose the whole graph into inverval [i, j] plus x and remain- ing part, we will factor out e (x,k) in a successive decomposition for resolving [i, j] plus x. We can- not capture the second features associated to e <ref type="bibr">(x,k)</ref> and e (x,rx) , because they are in different intervals, and when these intervals are combined, we have already hidden the position information of k. Ex- plicitly encoding k increases the time complexity to be at least quintic too.</p><p>Pitler (2014) showed that it is still possible to build accurate tree parsers by considering only higher-order features of noncrossing arcs. This is in part because only a tiny fraction of neighbor- ing arcs involve crossing arcs. However, this strat- egy is not easy to by applied to GCHSW, because GCHSW does not explicitly analyze sub-graphs of noncrossing arcs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">A New Maximum Subgraph Algorithm</head><p>Based on the discussion of Section 2.3 and 2.4, we can see that it is not easy to extend the existing algorithm, viz. GCHSW, to handle second-order features. In this paper, we propose an alternative first-order dynamic programming algorithm. Be- cause ignoring one linguistically-rare structure as- sociated with the C problem in GCHSW descreases the complexity, we exclude this structure in our al- gorithm. Formally, we introduce a new algorithm</p><formula xml:id="formula_5">Int O [i, j] i j LR[i, j, x] x i j N O [i, j, x] x i j L O [i, j, x] x i j R O [i, j, x] x i j Int C [i, j] i j N C [i, j, x] x i j L C [i, j, x] x i j R C [i, j, x]</formula><p>x i j <ref type="figure">Figure 6</ref>: Graphical representations of sub-problems. Gray curves mean the corresponding edge in this sub-problem, but should be included in the final generated graph.</p><formula xml:id="formula_6">IntO(i, j) ← max                  IntO(i + 1, j) IntC (i, j) IntC (i, k) + IntO(k, j) RC (i, k, x) + IntO(k, x) + LO(x, j, k) + sarc(i, k) LR(i, k, x) + IntO(k, x) + IntO(x, j, k) + sarc(i, k) IntO[i, x] + LC [x, k, i] + NO[k, j, x] + sarc(i, k) RO[i, x, k] + IntO[x, k] + LO[k, j, x] + sarc(i, k) Int C (i, j) ← s arc (i, j) + max                Int O (i + 1, j) Int C (i, k) + Int O (k, j) R C (i, k, x) + Int O (k, x) + L O (x, j, k) + s arc (i, k) LR(i, k, x) + Int O (k, x) + Int O (x, j, k) + s arc (i, k) Int O [i, x] + L C [x, k, i] + N O [k, j, x] + s arc (i, k) R O [i, x, k] + Int O [x, k] + L O [k, j, x] + s arc (i, k) N O (i, j, x) ← max    Int O (i, j) N C (i, j, x) + s arc (x, j) N C (i, k, x) + Int O (k, j) + s arc (x, k) N C (i, j, x) ← max Int O (i, j) N C (i, k, x) + Int O (k, j) + s arc (x, k) LR(i, j, x) ← max L O (i, k, x) + R O (k, j, x) L O (i, j, x) ← max        Int O (i, j) L C (i, j, x) + s arc (x, j) L C (i, k, x) + N O (k, j) + s arc (x, k) Int O (i, k, x) + L O (k, j) + s arc (x, k) L C (i, j, x) ← max        Int O (i, j) L C (i, j, x) + s arc (x, j) L C (i, k, x) + N O (k, j, i) + s arc (x, k) Int O (i, k) + L O (k, j, i) + s arc (x, k) R O (i, j, x) ← max        Int O (i, j) R C (i, j, x) + s arc (x, j) N C (i, k, j) + R O (k, j, x) + s arc (x, k) R O (i, k, x) + Int O (k, j) + s arc (x, k) R C (i, j, x) ← max N C (i, k, j) + R O (k, j, x) + s arc (x, k) R O (i, k, x) + Int O (k, j) + s arc (x, k)</formula><p>Figure 7: A dynamic program to find optimal 1EC/P2, C-free graphs with arc-factored weights.</p><p>to solve the following optimization problem:</p><p>arg max</p><formula xml:id="formula_7">G * ∈G(G) d∈ARC(G * ) s arc (d)</formula><p>where G means 1EC/P2, C-free graphs. Our algo- rithm has the same time and space complexity to the degenerated version of GCHSW. We represent our algorithm using undirected graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Sub-problems</head><p>Following GCHSW, we consider five sub-problems when we construct a maximum dependency graph on a given interval <ref type="bibr">[i, k]</ref>. Though the sub- problems introduced by <ref type="bibr">GCHSW</ref>   <ref type="bibr">, x]</ref> represents an interval from i to j inclusively as well as an external vertex x.</p><formula xml:id="formula_8">[i, j], pt(x, p) / ∈ [i, j]. N [i, j, x] could con- tain e (i,j) but disallows e (x,i) . We distinguish two sub-types. N O [i, j, x] may or may not contain e (x,j) . N C [i, j, x] implies the exis- tence of but does not contain e (x,j) . When N [i, j, x] is combined with others, e (x,j) is immediately created. L L[i, j</formula><formula xml:id="formula_9">∀p ∈ [i, j], pt(x, p) = i. L[i, j, x] could con- tain e (i,j) but disallows e (x,i) . We distinguish sub-two types for L. L O [i, j, x] may or may not contain e (x,j) . L C [i, j, x]</formula><p>implies the ex- istence of but does not contain e <ref type="bibr">(x,j)</ref> . When it is combined with others, e (x,j) is immedi- ately created.</p><p>R R <ref type="bibr">[i, j, x]</ref> represents an interval from i to j inclusively as well as an external vertex x. ∀p ∈ [i, j], pt(x, p) = j. R[i, j, x] disal- lows e (x,j) and e (x,i) . We distinguish two sub-types for R. R O [i, j, x] may or may not contain e <ref type="bibr">(i,j)</ref> . R C [i, j, x] implies the exis- tence of but does not contain e <ref type="bibr">(i,j)</ref> . When it is combined with others, e (i,j) is immediately created.</p><p>3.2 Decomposing Sub-problems <ref type="figure">Figure 7</ref> gives a sketch of our dynamic program- ming algorithm. We give a detailed illustration for Int, a rough idea for L and LR, and omit other sub-problems. More details about the whole algo- rithm can be found in the supplementary note. c.1 Assume that there exists an edge from k to some node r in <ref type="bibr">(x, j]</ref>, so x can only be k and pencil point of edges from k to (x, j] is x. Thus interval <ref type="bibr">[i, k, x]</ref> is an R. Due to the exis- tence of e (i,k) , its sub-type is R C . The e (i,k) is created in this construction and thus not con- tained by R C <ref type="bibr">[i, k, x]</ref>. An edge from within <ref type="bibr">[k, x]</ref> to outside violates the 1EC restriction, so <ref type="bibr">[k, x]</ref> is an Int. Since x is endpoint of edge from k to <ref type="bibr">[x, r]</ref>, interval <ref type="bibr">[k, j]</ref> is an L O with external vertex k.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.1">Decomposing an Int Sub-problem</head><p>c.2 We assume no edge from k to any node in [x, j], x thus can be i or k. As a result, <ref type="bibr">[x, j]</ref> is an Int and <ref type="bibr">[i, k, x]</ref> is an LR.</p><p>Case d: x ∈ (i, k).</p><p>d.1 Assume that there exist edges from i to (x, k), so the pencil point of edges from x to </p><formula xml:id="formula_10">(k, j] is i. Therefore [k, j] is an N. Because x is pencil point of edges from i to (x, k], [x, k] is an L. Furthmore,</formula><formula xml:id="formula_11">[i, x, k] + Int O [x, k] + L O [k, j, x] + e (i,k) + e (i,j) . For Int O [i, j]</formula><p>, because there may be e (i,j) , we add one more rule:</p><formula xml:id="formula_12">Int O [i, j] = Int C [i, j].</formula><p>And we do not need to create e (i,j) in all cases. c.1 If there is an edge from x to (i, k), <ref type="bibr">[i, k]</ref> and</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2.2">Decomposing an L Sub-problem</head><formula xml:id="formula_13">[k, j] are L C [i, k, x] and N O [k, j, i].</formula><p>c.2 If there is no edge from x to (i, k), <ref type="bibr">[i, k]</ref> and  </p><formula xml:id="formula_14">[k, j] are Int O [i, k] and L O [k, j, i].</formula><formula xml:id="formula_15">i j = i + 1 j (b) i k j = i k + k j Dashed edge exist? i k x j (c.1) i k x j = i k x + k x + k x j (c.2) i k x j = i k x + k x + x j</formula><p>Dashed edge exist? exist.</p><formula xml:id="formula_16">i x k j (d.1) i x k j = i x + i x k + x k j (d.2) i x k j = i x k + x k + x k j</formula><formula xml:id="formula_17">x i b 1 a 1 b 2 a 2 b 3</formula><p>j, a 3 Case a. If there is a vertex k within (i, j), which divides <ref type="bibr">[i, j]</ref> into <ref type="bibr">[i, k]</ref> and <ref type="bibr">[k, j]</ref>. And it guaran- tees no edge from [i, k) to <ref type="bibr">(k, j]</ref>. i is the pencil point of edges from x to (i, k] because no edge from j to (i, k) can cross these edges. Similarly j has to be the pencil point of edges from x to (k, j).</p><p>Obviously, <ref type="bibr">[i, k]</ref> is an L O and <ref type="bibr">[k, j]</ref> is an R O with external x. Thus the problem is decomposed as</p><formula xml:id="formula_18">L O [i, k, x] + R O [k, j, x].</formula><p>Case b. If there is no such vertex k, there must be edges from [i, k ) to (k , j] for every k in (i, j) without considering e (i,j) . For i + 1, we assume e (i,a 1 ) is the farthest edge that goes from i. For a 1 , we assume e (b 1 ,b 2 ) is the farthest edge from b 1 where b 1 is in (i, a 1 ) and b 2 is in (a 1 , j). For b 2 , we assume e (a 1 ,a 3 ) is the farthest edge from a 1 where a 3 is in (b 2 , j) and a 1 is the pencil point. We then get the series {a 1 , a 2 , a 3 ...a n } and</p><formula xml:id="formula_19">{b 1 , b 2 ...b m } which guarantees b i &lt; a i , a i &lt; b i+1</formula><p>and max(a n , b m ) = j. If b m = j, we will get a graph like <ref type="figure">Figure 10</ref>. If e (x,b 1 ) exists, this LR subproblem degenerates to an L subproblem. If e <ref type="bibr">(x,an)</ref> exists, this subprob- lem degenerates to an R subproblem.</p><p>If a m = j, we will get a graph like <ref type="figure" target="#fig_8">Figure 11</ref>. If there exists only e (x,b 1 ) or e (x,bm) , we can solve it like b m = j. If both exist, this is a typical C- structure like <ref type="figure" target="#fig_0">Figure 3</ref> and we cannot get it through other decompostion.</p><p>The above discussion gives the rough idea of the correctness of the following conclusion. Theorem 1. Our new algorithm is sound and complete with respect to 1EC/P2, C-free graphs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Spurious Ambiguity</head><p>An LR, L, R or N sub-problem allows to build crossing arcs, but does not necessarily create crossing arcs. For example, L C [i, j, x] allows e (i,j) to cross with e (x,y) (y ∈ (i, j)). Be- cause every subgraph of a 1EC/P2 graph is also a 1EC/P2 graph, we allow an L C [i, j, x] to be di- rectly degenerated to I O <ref type="bibr">[i, j]</ref>. In this way, we can make sure that all subgraphs can be constructed by our algorithm. <ref type="figure">Figure 12</ref> shows the rough idea. To generate the same graph, we have different derivations. The spurious ambiguity in our algo- rithm does not affect the correctness of first-order parsing, because scores are assigned to individ- ual dependencies, rather than derivation processes. There is no need to distinguish one special deriva- tion here.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Quasi-Second-Order Extension</head><p>We propose a second-order extension of our new algorithm. We focus on factorizations introduced in Section 2.1. Especially, the two arcs in a fac- tor should not cross other arcs. Formally, we in- troduce a new algorithm to solve the optimization problem with the following objective:</p><formula xml:id="formula_20">d∈ARC(G * ) s arc (d) + s∈SIB(G * ) max(s sib (s), 0)</formula><p>In the first-order algorithm, all noncrossing edges can be constructed as the frontier edge of an Int C . c d e <ref type="figure">Figure 12</ref>: Illustration of spurious ambiguity. The two solid curves represent two arcs in the target graph, but not the dashed one. Excluding crossing edges leads to the first derivation: <ref type="figure">,c)</ref> . As- suming that a pair of crossing arcs may exist yields another derivation:</p><formula xml:id="formula_21">Int C [a, e] ⇒ e (a,e) + Int C [a, c] + Int O [c, e] + e (a</formula><formula xml:id="formula_22">Int C [a, e] ⇒ e (a,e) + LR[a, c, d] + Int O [k, d] + L O [d, e, c] + e (a,c) ; Then LR[a, c, d] ⇒ L O [a, b, d] + R O [b, c, d] ⇒ Int O [a, b] + Int O [b, c].</formula><p>So we can develop an exact decoding algorithm by modifying the composition for Int C while keeping intact the decomposition for LR, N, L, R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">New Decomposition for Int C</head><p>In order to capture the second-order features from noncrossing neighbors, we need to find the right- most node adjacent to i, denoted as r i , and the leftmost node adjacent to j, denoted as l j ,while i &lt; r i ≤ l j &lt; j. To do this, we split Int C <ref type="bibr">[i, j]</ref> into at most three parts to capture the sibling fac- tors. Denote the score of adjacent edges e (i,j 1 ) and e (i,j 2 ) as s 2 (i, j 1 , j 2 ). When j is the inner most node adjacent to i, we denote the score as s 2 (i, ∅, j). We give a sketch of the decomposition in <ref type="figure" target="#fig_1">Figure 14</ref> and a graphical representation in <ref type="figure" target="#fig_0">Fig- ure 13</ref>. The following is a rough illustration.</p><p>Case a: r i = ∅. We further distinguish three sub-problems: a.1 If l j = ∅ too, both sides are the inner most second-order factor.</p><p>a.2 There is a crossing arc from j. This case is handled in the same way as the first-order al- gorithm.</p><p>a.3 l j = ∅. We introduce a new decomposition rule.</p><p>Case b: There is a crossing arc from i.</p><formula xml:id="formula_23">b.1 l j = ∅. Similar case to (a.2).</formula><p>b.2 There is a crossing arc from j. Similar case to (a.2).</p><p>b.3 There is a noncrossing arc from j. We intro- duce a new rule to calculate SIB(j, l j , i).</p><p>Case c: There is a noncrossing arc from i.</p><p>c.1 l j = ∅. Similar to (a.3).</p><p>c.2 There is a crossing arc from j. Similar to (b.3).</p><p>c.3 There is a noncrossing arc from j too. We introduce a new rule to calculate SIB(i, r i , j) and SIB(j, l j , i).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Complexity</head><p>The complexity of both first-and second-order al- gorithms can be analyzed in the same way. The sub-problem Int is of size O(n 2 ), with a calculat- ing time of order O(n 2 ) at most. For sub-problems L, R, LR, and N, each has O(n 3 ) elements, with a unit calculating time O(n). Therefore both algo- rithms run in time of O(n 4 ) with a space require- ment of O(n 3 ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Discussion</head><p>A traditional second-order model takes as the objective function s∈SIB(G * ) s sib (s). Our model instead tries to optimize s∈SIB(G * ) max(s sib (s), 0). This model is somehow inadequate given that the second-order score function cannot penalize a bad factor. When a negative score is assigned to a second-order factor, it will be taken as 0 by our algorithm. This inadequacy is due to the spurious am- biguity problem that is illustrated in Section 3.3. Take the two derivations in <ref type="figure">Figure 12</ref> for example. The derivation that starts from</p><formula xml:id="formula_24">Int C [a, e] ⇒ Int C [a, c] + Int O [c, e]</formula><p>incorporates the second-order score s sib (a, c, e). This is dif- ferent when we consider the derivation that starts from</p><formula xml:id="formula_25">Int C [a, e] ⇒ LR[a, c, d] + Int O [k, d] + L O [d, e, c].</formula><p>Because we assume temporarily that e (a,c) crosses others, we do not consider s sib (a, c, e). We can see from this example that second-order scores not only depend on the de- rived graphs but also sensitive to the derivation processes.</p><p>If a second-order score is greater than 0, our al- gorithm selects the derivation that takes it into ac- count since it increases the total score. If a second- order score is negative, our algorithm avoids in- cluding it by selecting other paths. In other words, our algorithm treats this score as 0.  <ref type="figure" target="#fig_0">Figure 13</ref>: Decomposition for Int C <ref type="bibr">[i, j]</ref> in the second-order parsing algorithm. </p><formula xml:id="formula_26">i j = i + 1 j − 1 (a.2) i j = i + 1 j (a.3) i j = i + 1 l j + l j j (b.1) i j = i j − 1 (b.3) i j = i r j + r j j (c.1) i j = i r i + r i j − 1 (c.2) i j = i r i + r i j (c.3) i j = i r i + r i l j + l j j</formula><formula xml:id="formula_27">Int C (i, j) ← s arc (i, j) + max                                              IntO(i + 1, j − 1) + ssib(i, ∅, j) + ssib(j, ∅, i) IntO(i + 1, j) + ssib(i, ∅, j) IntO(i + 1, lj) + IntC (lj, j) + ssib(i, ∅, j)+ ssib(j, lj, i) IntO(i, j − 1) + ssib(j, ∅, i) IntO(i, lj) + IntC (lj, j) + ssib(j, lj, i) IntC (i, ri) + IntO[ri, j − 1] + ssib(i, ri, j)+ ssib(j, ∅, i) IntC (i, ri) + IntO[ri, j] + ssib(i, ri, j) IntC (i, ri) + IntO[ri, lj] + IntC (lj, j)+ ssib(i, ri, j) + ssib(j, lj, i) RC (i, k, x) + IntO(k, x) + LO(x, j, k) + e (i,k) LR(i, k, x) + IntO(k, x) + IntO(x, j, k) + e (i,k) IntO[i, x] + LC [x, k, i] + NO[k, j, x] + e (i,k) RO[i, x, k] + IntO[x, k] + LO[k, j, x] + e (i,k)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Practical Parsing</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Derivation-Sensitive Training</head><p>We extend our quartic-time parsing algorithm into a practical parser. In the context of data-driven parsing, this requires an extra disambiguation model. As with many other parsers, we employ a global linear model. Following <ref type="bibr" target="#b20">Zhang et al. (2016)</ref>'s experience, we define rich features ex- tracted from word, POS-tags and pseudo trees. To estimate parameters, we utilize the averaged per- ceptron algorithm <ref type="bibr" target="#b3">(Collins, 2002</ref>).</p><p>Our training proceudre is sensitive to derivation rather then derived graphs. For each sentence, we first apply our algorithm to find the optimal pre- diction derivation. The we collect all first-and second-order factors from this derivation to update parameters. To train a first-order model, because our algorithm includes all factors, viz. depen- cies, there is no difference between our derivation- based method and a traditional derived structure- based method. For the second-order model, our method increases the second-order scores some- how.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Data and Preprocessing</head><p>We evaluate first-and second-order models on four representative data sets: CCGBank <ref type="bibr" target="#b7">(Hockenmaier and</ref><ref type="bibr">Steedman, 2007), DeepBank (Flickinger et al., 2012</ref>), Enju HPSGBank ( <ref type="bibr" target="#b13">Miyao et al., 2005</ref>) and Prague Dependency TreeBank ( <ref type="bibr" target="#b6">Hajic et al., 2012</ref>). We use "standard" training, validation, and test splits to facilitate comparisons.</p><p>• Following previous experimental setup for</p><p>English CCG parsing, we use section 02-21 as training data, section 00 as the development data, and section 23 for testing.</p><p>• The DeepBank, Enju HPSGBank and Prague Dependency TreeBank are from <ref type="bibr" target="#b14">SemEval 2014</ref><ref type="bibr">Task 8 (Oepen et al., 2014</ref>, and the data splitting policy follows the shared task.</p><p>Experiments for CCG-grounded analysis were per- formed using automatically assigned POS-tags that are generated by a symbol-refined HMM tag- ger ( <ref type="bibr" target="#b8">Huang et al., 2010)</ref>. Experiments for the other three data sets used POS-tags provided by the shared task. We also use features extracted from pseudo trees. We utilize the Mate parser <ref type="bibr" target="#b0">(Bohnet, 2010)</ref> to generate pseudo trees. All experimental results consider directed dependencies in a stan- dard way. We report Unlabeled Precision (UP), Recall (UR) and F-score (UF), which are calcu- lated using the official evaluation tool provided by SDP2014 shared task.  <ref type="table">Table 2</ref>: Parsing accuracy evaluated on the test sets. "SJW" denotes the book embedding parser intro- duced in . improvement is smaller but still significant on the three SemEval data sets. <ref type="table">Table 2</ref> lists the parsing results on the test data together with the result obtained by <ref type="bibr">Sun et al. (SJW;</ref>'s system. The building architectures of both systems are comparable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Accuracy</head><p>1. Both systems have explicit control of the out- put structures. While Sun et al.'s system con- strain the output graph to be P2 only, our sys- tem adds an additional 1EC restriction.</p><p>2. Their system's second-order features also in- cludes both-side neighboring features.</p><p>3. Their system uses beam search and dual decomposition and therefore approximate, while ours perform exact decoding.</p><p>We can see that while our purely Maximum Sub- graph parser obtains better results on DeepBank and CCGBank; while the book embedding parser is better on the other two data sets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Analysis</head><p>Our algorithm is sensitive to the derivation pro- cess and may exclude a couple of negative second- order scores by selecting misleading derivations. Neverthess, our algorithm works in an exact way to include all positive second-order scores. <ref type="table" target="#tab_4">Table  3</ref> shows the coverage of all second-order factors. On average, 99.67% second-order factors are cal- culated by our algorithm. This relatively satisfac- tory coverage suggests that our algorithm is very effective to include second-order features. Only a very small portion is dropped.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>This paper proposed two exact, graph-based al- gorithms for 1EC/P2 parsing with first-order and quasi-second-order scores. The resulting parser has the same asymptotic run time as 's algorithm. An exploration of other factor- izations that facilitate semantic dependency pars- ing may be an interesting avenue for future work. Recent work has investigated faster decoding for higher-order graph-based projective parsing e.g. vine pruning <ref type="bibr" target="#b17">(Rush and Petrov, 2012</ref>) and cube pruning ( <ref type="bibr" target="#b19">Zhang and McDonald, 2012)</ref>. It would be interesting to extend these lines of work to de- crease the complexity of our quartic algorithm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>Figure 3: C structure has two crossing chains.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: A prototype backbone of 1EC/P2 graphs. To decompose this structure, GCHSW focuses on e (i,j) and e (l,j) , because these two edges can be optionally created without violation of both 1EC and P2 restrictions. Our algorithm focuses on the existence of e (i,k) , and makes it the only edge that is constructed by applying a corresponding rule.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>and us handle similar structures, their definitions are quite differ- ent. The sub-problems are explained as follows: Int Int[i, j] represents an interval from i to j in- clusively. And there is no edge e (i ,j ) such that i ∈ [i, j] and j / ∈ [i, j]. We distinguish two sub-types for Int. Int O [i, j] may or may not contain e (i,j) , while Int C [i, j] contains e (i,j) . LR LR[i, j, x] represents an interval from i to j inclusively and an external vertex x. ∀p ∈ [i, j], pt(x, p) = i or j. LR[i, j, x] implies the existence of e (i,j) , but does not contain e (i,j) . When LR[i, j, x] is combined with other DP sub-structures, e (i,j) is immediately created. LR[i, j, x] disallows neither e (x,i) nor e (x,j) . N N [i, j, x] represents an interval from i to j inclusively and an external vertex x. ∀p ∈</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Consider Int O [i, j] and Int C [i, j] sub-problem. Because the decomposition for Int C [i, j] is very similar to Int O [i, j] and needs to be modified by our second-order parsing algorithm, we only show the decomposition of Int C [i, j]. Assume that k(k ∈ (i, j)) is the farthest vertex that is ad- jacent to i, and x = pt(i, k). If there is no such k (i.e. there no arc from i to some other node in this interval), then we denote k as ∅. So it is to x. We illustrate different cases as following and give a graphical representation in Figure 8. Case a: k = ∅. We can directly consider interval [i + 1, j]. Because there is no edge from i to any node in [i + 1, j], [i + 1, j] is an Int O . Case b: x = ∅. x = ∅ means that e (i,k) does not cross other arcs. So [i, k] and [k, j] are Int. Case c: x ∈ (k, j]. e (i,k) is taken as a possible crossing edge. k and x divide the interval [i, j] into three parts: [i, k], [k, x], [x, j]. Because x may be j, interval [x, j] may only contain j and become an empty interval. We define x as the pencil point of all edges from (i, k) to x, and distinguish two sub-problems as follows.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>Without loss of generality, we show the decompo- sition of L O [i, j, x] as follows. For L C [i, j, x], we ignore Case b but follow the others. Case a. If there is no more edge from x to (i, j], then it will degenerate to Int O [i, j]. Case b. If there exists e (x,j) , then it will degen- erate to L C [i, j, x] + e (x,j) . Case c. Assume that there are edges from x to (i, j) and e (x,k) is the farthest one. It divides [i, j] into [i, k] and [k, j].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 is</head><label>8</label><figDesc>Figure 8 is a graphical representation. 3.2.3 Decomposing an LR Sub-problem LR[i, j, x] means i or j is the pencil point of edges from x to (i, j). We show the decomposition of LR[i, j, x] as follows:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 8 :Figure 10 :</head><label>810</label><figDesc>Figure 8: Decomposition for Int C [i, j] in the first-order parsing algorithm. pt(i, k) = x.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 :</head><label>11</label><figDesc>Figure 11: a 3 = j. Both e (x,b 1 ) and e (x,b 3 ) exist.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 14 :</head><label>14</label><figDesc>Figure 14: Decomposition for Int C [i, j, x].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head>Table 1 lists</head><label>1</label><figDesc></figDesc><table>the accuracy of our system. The out-
put of our parser was evaluated against each de-
pendency in the corpus. We can see that the first-
order parser obtains a considerably good accuracy, 
with rich syntactic features. Furthermore, we can 
see that the introduction of higher-order features 
improves parsing substantially for all data sets, as 
expected. When syntactic trees are utilized, the </table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 3 :</head><label>3</label><figDesc></figDesc><table>Coverage of second-order factors on the 
developmenet data. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Top accuracy and fast dependency parsing is not a contradiction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bernd</forename><surname>Bohnet</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/C10-1011" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 23rd International Conference on Computational Linguistics</title>
		<meeting>the 23rd International Conference on Computational Linguistics<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="89" to="97" />
		</imprint>
	</monogr>
	<note>Coling 2010 Organizing Committee</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Parsing to 1-endpoint-crossing, pagenumber-2 graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junjie</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sheng</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Wan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 55th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Experiments with a higherorder projective dependency parser</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xavier</forename><surname>Carreras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EMNLP-CoNLL</title>
		<meeting>EMNLP-CoNLL</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Discriminative training methods for hidden markov models: Theory and experiments with perceptron algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<idno type="doi">10.3115/1118693.1118694</idno>
		<ptr target="https://doi.org/10.3115/1118693.1118694" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2002 Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics</title>
		<meeting>the 2002 Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="1" to="8" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Three new probabilistic models for dependency parsing: an exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jason</forename><forename type="middle">M</forename><surname>Eisner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 16th conference on Computational</title>
		<meeting>the 16th conference on Computational<address><addrLine>Stroudsburg, PA, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="1996" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="340" to="345" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Deepbank: A dynamically annotated treebank of the wall street journal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Flickinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yi</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Valia</forename><surname>Kordoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Eleventh International Workshop on Treebanks and Linguistic Theories</title>
		<meeting>the Eleventh International Workshop on Treebanks and Linguistic Theories</meeting>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="85" to="96" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Announcing prague czech-english dependency treebank 2.0</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Hajic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eva</forename><surname>Hajicová</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jarmila</forename><surname>Panevová</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Sgall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ondej</forename><surname>Bojar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Silvie</forename><surname>Cinková</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eva</forename><surname>Fucíková</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marie</forename><surname>Mikulová</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Petr</forename><surname>Pajas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Popelka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jirí</forename><surname>Semeck´ymeck´y</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jana</forename><surname>Sindlerová</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Stepánek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josef</forename><surname>Toman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdenka</forename><surname>Uresová</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zdenek</forename><surname>Zabokrtsk´yzabokrtsk´y</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Language Resources and Evaluation</title>
		<meeting>the 8th International Conference on Language Resources and Evaluation<address><addrLine>Istanbul, Turkey</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">CCGbank: A corpus of CCG derivations and dependency structures extracted from the penn treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julia</forename><surname>Hockenmaier</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="355" to="396" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Self-training with products of latent variable grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhongqiang</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mary</forename><surname>Harper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slav</forename><surname>Petrov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2010</title>
		<meeting>the 2010</meeting>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
				<ptr target="http://www.aclweb.org/anthology/D10-1002" />
		<title level="m">Conference on Empirical Methods in Natural Language Processing. Association for Computational Linguistics</title>
		<meeting><address><addrLine>Cambridge, MA</addrLine></address></meeting>
		<imprint>
			<biblScope unit="page" from="12" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Efficient thirdorder dependency parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Terry</forename><surname>Koo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/P10-1001" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 48th Annual Meeting of the Association for Computational Linguistics. Association for Computational Linguistics</title>
		<meeting>the 48th Annual Meeting of the Association for Computational Linguistics. Association for Computational Linguistics<address><addrLine>Uppsala, Sweden</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1" to="11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Parsing to noncrossing dependency graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Jonsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="559" to="570" />
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Online learning of approximate dependency parsing algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fernando</forename><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 11th Conference of the European Chapter of the Association for Computational Linguistics</title>
		<meeting>11th Conference of the European Chapter of the Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="81" to="88" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Corpus-oriented grammar development for acquiring a head-driven phrase structure grammar from the penn treebank</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Miyao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takashi</forename><surname>Ninomiya</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jun&amp;apos;ichi</forename><surname>Tsujii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IJCNLP</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="684" to="693" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Semeval 2014 task 8: Broad-coverage semantic dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stephan</forename><surname>Oepen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Kuhlmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yusuke</forename><surname>Miyao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Zeman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Flickinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jan</forename><surname>Hajic</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/S14-2008" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Workshop on Semantic Evaluation</title>
		<meeting>the 8th International Workshop on Semantic Evaluation<address><addrLine>Dublin, Ireland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="63" to="72" />
		</imprint>
		<respStmt>
			<orgName>Computational Linguistics and Dublin City University</orgName>
		</respStmt>
	</monogr>
	<note>Association for</note>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">A crossing-sensitive thirdorder factorization for dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Pitler</surname></persName>
		</author>
		<ptr target="http://www.transacl.org/wp-" />
	</analytic>
	<monogr>
		<title level="j">TACL</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="41" to="54" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Finding optimal 1-endpoint-crossing trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Emily</forename><surname>Pitler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sampath</forename><surname>Kannan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename></persName>
		</author>
		<ptr target="http://www.transacl.org/wp-content/uploads/2013/03/paper13.pdf" />
	</analytic>
	<monogr>
		<title level="j">TACL</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="13" to="24" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Vine pruning for efficient multi-pass dependency parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Rush</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Slav</forename><surname>Petrov</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/N12-1054" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies</title>
		<meeting>the 2012 Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies<address><addrLine>Montréal, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="498" to="507" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Semantic dependency parsing via book embedding</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Junjie</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Wan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 55th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 55th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Generalized higher-order dependency parsing with cube pruning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hao</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ryan</forename><surname>Mcdonald</surname></persName>
		</author>
		<ptr target="http://www.aclweb.org/anthology/D12-1030" />
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</title>
		<meeting>the 2012 Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning<address><addrLine>Jeju Island, Korea</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2012" />
			<biblScope unit="page" from="320" to="331" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Transition-based parsing for deep dependency structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xun</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yantao</forename><surname>Du</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Weiwei</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Wan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="353" to="389" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
