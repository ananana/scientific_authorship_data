<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T10:47+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SyntaxSQLNet: Syntax Tree Networks for Complex and Cross-Domain Text-to-SQL Task</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>October 31-November 4, 2018. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Yu</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michihiro</forename><surname>Yasunaga</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Yang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Zhang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongxu</forename><surname>Wang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zifan</forename><surname>Li</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dragomir</forename><forename type="middle">R</forename><surname>Radev</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">Yale University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SyntaxSQLNet: Syntax Tree Networks for Complex and Cross-Domain Text-to-SQL Task</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing</title>
						<meeting>the 2018 Conference on Empirical Methods in Natural Language Processing <address><addrLine>Brussels, Belgium</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="1653" to="1663"/>
							<date type="published">October 31-November 4, 2018. 2018</date>
						</imprint>
					</monogr>
					<note>1653</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Most existing studies in text-to-SQL tasks do not require generating complex SQL queries with multiple clauses or sub-queries, and generalizing to new, unseen databases. In this paper we propose SyntaxSQLNet, a syntax tree network to address the complex and cross-domain text-to-SQL generation task. Syn-taxSQLNet employs a SQL specific syntax tree-based decoder with SQL generation path history and table-aware column attention en-coders. We evaluate SyntaxSQLNet on a new large-scale text-to-SQL corpus containing databases with multiple tables and complex SQL queries containing multiple SQL clauses and nested queries. We use a database split setting where databases in the test set are unseen during training. Experimental results show that SyntaxSQLNet can handle a significantly greater number of complex SQL examples than prior work, outperforming the previous state-of-the-art model by 9.5% in exact matching accuracy. To our knowledge, we are the first to study this complex text-to-SQL task. Our task and models with the latest updates are available at https://yale-lily. github.io/seq2sql/spider.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Text-to-SQL task is one of the most important sub- task of semantic parsing in natural language pro- cessing (NLP). It maps natural language sentences to corresponding SQL queries.</p><p>In recent years, some state-of-the-art methods with Seq2Seq encoder-decoder architectures are able to obtain more than 80% exact matching ac- curacy on some complex text-to-SQL benchmarks such as ATIS and GeoQuery. These models seem to have already solved most problems in this area.</p><p>However, as <ref type="bibr" target="#b6">(Finegan-Dollak et al., 2018)</ref> show, because of the problematic task definition in the traditional datasets, most of these models just What are the name and lowest instructor salary of the departments with average salary greater than the overall average?</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>SQL Review 150 man-hours</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Question Review &amp; Paraphrase 150 man-hours</head><p>Complex input sentence:</p><p>Database:</p><p>instructor <ref type="table">Table 1</ref> department   <ref type="figure">Figure 1</ref>: To address the complex text-to-SQL gener- ation task, SyntaxSQLNet employs a tree-based SQL generator. For example, our model can systematically generate a nested query as illustrated above.</p><p>learn to match semantic parsing results, rather than truly learn to understand the meanings of inputs and generalize to new programs and databases. More specifically, most existing complex text-to- SQL datasets have less than 500 SQL labels. They are expanded by paraphrasing 4-10 questions for each SQL query. Under the standard train and test split <ref type="bibr" target="#b36">(Zettlemoyer and Collins, 2005</ref>), most queries in the test set also appear in the train set. The WikiSQL dataset recently developed by <ref type="bibr" target="#b37">(Zhong et al., 2017</ref>) is much larger and does use different databases for training and testing, but it only contains very simple SQL queries and database schemas.</p><p>To address those issues in the current semantic parsing datasets, <ref type="bibr" target="#b34">Yu et al. (2018b)</ref> have developed a large-scale human labeled text-to-SQL dataset consisting of about 6,000 complex SQL queries and 200 databases with multiple tables. This dataset defines a new complex and cross-domain text-to-SQL task that requires models to general- ize well to both new SQL queries and databases. The task cannot be solved easily without truly un- derstanding the semantic meanings of the input questions.</p><p>In this paper, we propose SyntaxSQLNet, a SQL specific syntax tree network to address the aforementioned task. Specifically, to generate complex SQL queries with multiple clauses, selec- tions and sub-queries, we develop a syntax tree- based decoder with SQL generation path history. To make our model learn to generalize to new databases with new tables and columns, we also develop a table-aware column encoder. Our con- tributions are as follows:</p><p>• We propose SQL specific syntax tree networks for the complex and cross-domain text-to-SQL task, which is even able to solve nested queries on new, unseen databases. We are the first to develop a methodology for this challenging se- mantic parsing task.</p><p>• We introduce a SQL specific syntax tree-based decoder with SQL path history and table-aware column attention encoders. Even with no hyper- parameter tuning, our model can significantly outperform the previous best models, with 4.8% boost in exact matching accuracy. Error anal- ysis shows that our model is able to general- ize, and solve much more complex (e.g., nested) queries in unseen databases than prior work.</p><p>• We also develop a cross-domain data augmen- tation method to generate more diverse training examples across databases, which further im- proves the exact matching accuracy by 7.5%. As a result, our model achieves 22.0% accuracy, a 12.3% total improvement compared with the previous best models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>Semantic parsing maps natural language to formal meaning representations. There are a range of rep- resentations, such as logic forms and executable programs ( <ref type="bibr" target="#b35">Zelle and Mooney, 1996;</ref><ref type="bibr" target="#b36">Zettlemoyer and Collins, 2005;</ref><ref type="bibr" target="#b27">Wong and Mooney, 2007;</ref><ref type="bibr" target="#b3">Das et al., 2010;</ref><ref type="bibr" target="#b12">Liang et al., 2011;</ref><ref type="bibr" target="#b1">Banarescu et al., 2013;</ref><ref type="bibr" target="#b0">Artzi and Zettlemoyer, 2013;</ref><ref type="bibr" target="#b21">Reddy et al., 2014;</ref><ref type="bibr" target="#b2">Berant and Liang, 2014;</ref><ref type="bibr" target="#b14">Pasupat and Liang, 2015)</ref>.</p><p>As a sub-task of semantic parsing, the text-to- SQL problem has been studied for decades <ref type="bibr" target="#b26">(Warren and Pereira, 1982;</ref><ref type="bibr" target="#b18">Popescu et al., 2003a</ref><ref type="bibr" target="#b17">Popescu et al., , 2004</ref><ref type="bibr" target="#b11">Li et al., 2006;</ref><ref type="bibr" target="#b7">Giordani and Moschitti, 2012;</ref><ref type="bibr" target="#b25">Wang et al., 2017b</ref>). The methods proposed in the database community ( <ref type="bibr" target="#b10">Li and Jagadish, 2014;</ref><ref type="bibr" target="#b30">Yaghmazadeh et al., 2017</ref>) tend to involve hand feature engineering and user interactions with the systems. In this work, we focus on recent neu- ral network-based approaches ( <ref type="bibr" target="#b31">Yin et al., 2016;</ref><ref type="bibr" target="#b37">Zhong et al., 2017;</ref><ref type="bibr" target="#b29">Xu et al., 2017;</ref><ref type="bibr" target="#b24">Wang et al., 2017a;</ref><ref type="bibr" target="#b8">Iyer et al., 2017)</ref>. <ref type="bibr" target="#b4">Dong and Lapata (2016)</ref> introduce a sequence-to-sequence (seq2seq) ap- proach to converting texts to logical forms. Most previous work focuses on a specific table schema. <ref type="bibr" target="#b37">Zhong et al. (2017)</ref> publish the WikiSQL dataset and propose a seq2seq model with reinforcement learning to generate SQL queries. <ref type="bibr" target="#b29">Xu et al. (2017)</ref> further improve the results on the WikiSQL task by using a SQL-sketch based approach employ- ing a sequence-to-set model. <ref type="bibr" target="#b5">Dong and Lapata (2018)</ref> propose a coarse-to-fine model which achieves the new state-of-the-art performances on several datasets including WikiSQL. Their model first generate a sketch of the target program. Then the model fills in missing details in the sketch.</p><p>Our syntax tree-based decoder is related to re- cent work that exploits syntax information for code generation tasks <ref type="bibr" target="#b32">(Yin and Neubig, 2017;</ref><ref type="bibr" target="#b20">Rabinovich et al., 2017)</ref>. <ref type="bibr" target="#b32">Yin and Neubig (2017)</ref> introduce a neural model that transduces a nat- ural language statement into an abstract syntax tree (AST). While they format the generation pro- cess as a seq2seq decoding of rules and tokens, our model uses a module for each grammar com- ponent, and calls them recursively to generate a SQL syntax tree. Similarly, <ref type="bibr" target="#b20">Rabinovich et al. (2017)</ref> propose abstract syntax networks that use a collection of recursive modules for decoding. Our model differs from theirs in the following points. First, we exploit a SQL specific grammar instead of AST. AST-based models have to pre- dict many non-terminal rules before predicting the terminal tokens, involving more steps. Whereas, our SQL-specific grammar enables direct predic- tion of SQL tokens. Second, our model uses dif- ferent sequence-to-set modules to avoid the "or-dering issue" ( <ref type="bibr" target="#b29">Xu et al., 2017</ref>) in many code gen- eration tasks. Third, different from ( <ref type="bibr" target="#b20">Rabinovich et al., 2017)</ref>, we pass a pre-order traverse of SQL decoding history to each module. This provides each module with important dependence informa- tion: e.g., if a SQL query has GROUP BY, it is very likely that the grouped column have appeared in SELECT too.</p><p>In addition to the distinction in model design, our work differs from theirs in the data and task definition. They aim to develop general syn- tax model for code generation via abstract syn- tax trees. Instead, we are interested in solving the complex and cross-domain SQL query generation problem; this motivates us to take advantage of SQL specific syntax for decoding, which guides systematic generation of complex SQL queries.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Problem Formulation</head><p>This work aims to tackle the complex text-to-SQL task that involves multiple tables, SQL clauses and nested queries. Further, we use separate databases for training and testing, aiming to develop models that generalize to new databases.</p><p>Dataset. We use Spider ( <ref type="bibr" target="#b34">Yu et al., 2018b</ref>) as the main dataset, which contains 10,181 ques- tions, 5,693 unique complex SQL queries, and 200 databases with multiple tables.</p><p>Task and Challenges.</p><p>• The dataset contains a large number of complex SQL labels, which involve more tables, SQL clauses, and nested queries than prior datasets such as WikiSQL. Existing models developed for the WikiSQL task cannot handle those com- plex SQL queries in the Spider dataset.</p><p>• The dataset contains 200 databases (∼138 do- mains), and different databases are used for training and testing. Unlike most previous se- mantic parsing tasks (e.g., ATIS), this task re- quires models to generalize to new, unseen databases.</p><p>In sum, we train and test models on different com- plex SQL queries from different databases in this task. This aims to ensure that models can make the correct prediction only when they truly under- stand the meaning of the questions under the given database, rather than by mere memorization. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Token Instances</head><p>Figure 2: Our modules and SQL grammar used in de- coding process. A round symbol represents a SQL to- kens, a table column, etc. A square symbol indicates a module that predicts the next SQL token from its cor- responding token instances with the same color.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Methodology</head><p>Similar to ( <ref type="bibr" target="#b20">Rabinovich et al., 2017)</ref>, our model structures the decoder as a collection of recursive modules. However, as we discussed in the re- lated work section, we make use of a SQL specific grammar to guide the decoding process, which al- lows us to take advantage of SQL queries' well- defined structure. <ref type="bibr">1</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Module Overview</head><p>Our model decomposes the SQL decoding process into 9 modules to handle the prediction of differ- ent SQL components such as keywords, operators, and columns. We provide the overview in this sec- tion and more details in later sections. <ref type="figure">Figure 2</ref> illustrates our modules and SQL gram- mar used in decoding process. A round symbol represents a SQL token, such as SELECT, WHERE, a table column, etc. A square symbol indicates a module that predicts the next SQL token from its corresponding token instances with the same color. Specifically, we have the following mod- ules.</p><p>• IUEN Module, predicting INTERCEPT, 1 Please check out our website for the latest updates on the model at https://yale-lily.github.io/ seq2sql/spider UNION, EXCEPT, and NONE, which deter- mines if we need to call itself again to gen- erate nested queries.</p><p>• KW Module, predicting keywords from WHERE, GROUP BY, and ORDER BY. All queries in our dataset have SELECT.</p><p>• COL Module, predicting table columns.</p><p>• OP Module, for =, &gt;, &lt;, &gt;=, &lt;=, ! =, LIKE, NOT IN, IN, BETWEEN.</p><p>• AGG Module, predicting aggregators from MAX, MIN, SUM, COUNT, AVG, and NONE.</p><p>• Root/Terminal Module, predicting the ROOT of a new subquery or terminal value. It also enables our model to generate nested queries.</p><p>• AND/OR Module, predicting the presence of AND or OR operator between two conditions.</p><p>• DESC/ASC/LIMIT Module, predicting the keywords associated with ORDER BY. It is invoked only when ORDER BY is predicted before.</p><p>• HAVING Module, predicting the presence of HAVING for GROUP BY clause. It is invoked only when GROUP BY is predicted earlier.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">SQL Grammar</head><p>In order to structure our decoder to generate com- plex queries, we consider a SQL grammar. It determines which module to be invoked at each recursive decoding step. <ref type="figure">Figure 2</ref> illustrates our SQL grammar. During decoding process, given the current SQL token and the SQL history (the tokens we have gone over to reach the current to- ken), we determine which module to invoke, and predict the next SQL token to generate.</p><p>To invoke some modules such as HAVING and OP during decoding, we not only check the type of current token instance but also see whether the type of the previously decoded SQL token is GROUP for HAVING module, and WHERE or HAVING for OP module.</p><p>In the grammar, IUEN and Root/Terminal mod- ules are able to generate ROOT, which can activate IUEN module again. In this way, our model can recursively generate nested subqueries, and can also predict two or more subqueries in queries that have EXCEPT, INTERSECT, and UNION.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Input Encoder</head><p>Our inputs of each module consist of three types of information: question, table schema, and current SQL decoding history path. We encode a question sentence by a bi-directional LSTM, BiLSTM Q . We encode table schema and history path in the manners described below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.1">Table-Aware Column Representation</head><p>In order to generalize to new databases in testing, it is important to make our model learn to obtain necessary information from a database schema. While SQLNet ( <ref type="bibr" target="#b29">Xu et al., 2017</ref> Specifically, given a database, we first obtain embedding for each table by taking the average embedding of the words constituting the table name (e.g., for table name student id, we av- erage the word embeddings for student and id). Next, for each column, we obtain the ini- tial column name embedding in the same man- ner, and then concatenate the corresponding ta- ble embedding, and the type information of the column (string, or number, primary/foreign key) in a way similar to ( <ref type="bibr" target="#b33">Yu et al., 2018a</ref>) to pro- duce a column embedding. On top, we apply an- other level of BiLSTM (BiLSTM COL ) that con- nects all columns in the database, to obtain high- level column embeddings. This way, our encoding scheme can effectively capture both the global (ta- ble names) and local (column names and types) information in the database schema to understand the question in the context of the given database.</p><p>Similarly to ( <ref type="bibr" target="#b33">Yu et al., 2018a</ref>), while the the order of column names or table names does not matter in practice, the use of BiLSTM performed better than the direct use of input column embed- dings.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.2">SQL Decoding History</head><p>In addition to question and column information, we also pass the SQL query's current decoding history as an input to each module. This enables us to use the information of previous decoding states to predict the next SQL token. For example, in <ref type="figure">Figure 1</ref>, the COL module would be more likely to predict salary in the subquery by consider- ing the path history which contains salary for HAVING, and SELECT in the main query.</p><p>In contract, each module in SQLNet does not consider the previous decoded SQL history.</p><p>Hence, if directly applied to our recursive SQL de- coding steps, each module would just predict the same output every time it is invoked. By passing the SQL history, each module is able to predict a different output according to the history every time it is called during the recursive SQL genera- tion process. Also, the SQL history can improve the performance of each module on long and com- plex queries because the history helps the model capture the relations between clauses.</p><p>Predicted SQL history is used during test decod- ing. For training, we first traverse each node in the the gold query tree in pre-order to generate gold SQL path history for each training example used in different modules.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3.3">Attention for Input Encoding</head><p>For each module, like SQLNet, we apply the at- tention mechanism to encode question representa- tion. We also employs this technique on SQL path history encoding. The specific formulas used are described in the next section.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Module Details</head><p>Similarly to SQLNet (Xu et al., 2017), we em- ploy a sketch-based approach for each module. We apply a seq2set prediction framework intro- duced by ( <ref type="bibr" target="#b29">Xu et al., 2017)</ref>, to avoid the order is- sue that happens in seq2seq based models for SQL generation. For example, in <ref type="figure">Figure 1</ref>, SELECT salary, dept name is the same as SELECT dept name, salary. The traditional seq2seq decoder generates each of them one by one in or- der; hence the model could get penalized even if the prediction and gold label are the same as sets.</p><p>To avoid this problem, SQLNet predicts them to- gether in one step so that their order does not affect the model's training process. For instance, in <ref type="figure">Fig- ure 1</ref>, our model invokes the COL module to pre- dict salary and dept name and push to stack at the same time. However, SQLNet trains each modules independently, so no information passes through each component.</p><p>We first describe how to compute the condi- tional embedding H 1/2 of an embedding H 1 given another embedding H 2 :</p><formula xml:id="formula_0">H 1/2 = softmax(H 1 WH 2 )H 1 .</formula><p>Here W is a trainable parameter. Moreover, we get a probability distribution from a given score matrix U by</p><formula xml:id="formula_1">P(U) = softmax (Vtanh(U)) ,</formula><p>where V is a trainable parameter.</p><p>We denote the hidden states of LSTM on ques- tion embeddings, path history, and columns em- beddings as H Q , H HS , and H COL respectively. In addition, we denote the hidden states of LSTM on multiple keywords embeddings and keywords embeddings as H MKW and H KW respectively. Fi- nally, we use W to denote trainable parameters that are not shared between modules. The output of each module is computed as follows:</p><p>IUEN Module In the IUEN module, since only one of the multiple keywords from {INTERCEPT, UNION, EXCEPT, NONE} will be used, we compute the probabilities by Root/Terminal Module To predict nested sub- queries, we add a module to predict if there is a new "ROOT" after an operator, which allows the model to decode queries recursively. For each pre- dicted column from the COL module that is in the WHERE clause, we first call OP module, and then predict whether the next decoding step is a "ROOT" node or a value terminal node by</p><formula xml:id="formula_2">P IUEN = P W 1 H Q/MKW + W</formula><formula xml:id="formula_3">P RT = P W 1 H Q/CS + W 2 H HS/CS + W 3 H CS</formula><p>AND/OR Module For each condition column predicted from the COL module with number big- ger than 1, we predict from {AND, OR} by</p><formula xml:id="formula_4">P AO = P W 1 H Q + W 2 H HS</formula><p>DESC/ASC/LIMIT Module In the DAL mod- ule, for each predicted column from the COL mod- ule that is in the ORDER BY clause, we predict from {DESC, ASC, DESC LIMIT, ASC LIMIT} by</p><formula xml:id="formula_5">P DAL = P W 1 H Q/CS + W 2 H HS/CS + W 3 H CS</formula><p>HAVING Module In the HAVING module, for each predicted column from the COL module that is in the GROUP BY clause, we predict whether it is in the HAVING clause by</p><formula xml:id="formula_6">P HAVING = P W 1 H Q/CS + W 2 H HS/CS + W 3 H CS</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Recursive SQL Generation</head><p>The SQL generation process is a process of ac- tivating different modules recursively. As illus- trated in <ref type="figure">Figure 2</ref>, we employ a stack to organize our decoding process. At each decoding step, we pop one SQL token instance from the stack, and invoke a module based on the grammar to predict the next token instance, and then push the pre- dicted instance into the stack. The decoding pro- cess continues until the stack is empty. More specifically, we initialize a stack with only ROOT at the first decoding step. At the next step, the stack pops ROOT. As illustrated in <ref type="figure">Figure 2</ref>, ROOT actives the IUEN module to predict if there is EXCEPT, INTERSECT or UNION. If so, there are two subqueries to be generated in the next step. If the model predicts NONE instead, it will be pushed into the stack. The stack pops NONE at next step. For example, in <ref type="figure">Figure 2</ref>, the current popped token is SELECT, which is a instance of keyword (KW) type. It calls the COL module to predict a column name, which will be pushed to the stack.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Data Augmentation</head><p>Even though Spider already has a significantly larger number of complex queries than existing datasets, the number of training examples for some complex SQL components is still limited. A widely used way is to conduct data augmentation to generate more training examples automatically. Many studies <ref type="bibr" target="#b2">(Berant and Liang, 2014;</ref><ref type="bibr" target="#b8">Iyer et al., 2017;</ref><ref type="bibr" target="#b22">Su and Yan, 2017)</ref> have shown that data augmentation can bring significant improvement in performance. In prior work, data augmentation was typically performed within a single domain dataset. We propose a cross-domain data augmen- tation method to expand our training data for com- plex queries. Cross-domain data augmentation is more difficult than the in-domain setting because question-program pairs tend to have domain spe- cific words and phrases. To tackle this issue, we first create a list of universal patterns for question- SQL pairs, based on the human labeled pairs from all the different training databases in Spider. To do so, we use a script to remove (and later fill in) all the table/column names and value tokens in the la- beled question-SQL pairs, and then group together the same SQL query patterns. Consequently, each SQL query pattern has a list of about 5-20 corre- sponding questions. In our task, we want to gen- erate more complex training examples. Thus, we filter out simple SQL query patterns by measur- ing the length and the number of SQL keywords used. We obtain about 280 different complex SQL query patterns from the 4,000+ SQL labels in the train set of our corpus. We then select the 50 most frequent complex SQL patterns that contain multi- ple SQL components and nested subqueries. After this, we manually edit the selected SQL patterns and their corresponding list of questions to make sure that the table/column/value slots in the ques- tions have one-to-one correspondence to the slots in the corresponding SQL query. For each slot, we also add column type or table information. Thus, for example, columns with string type do not ap- pear in the column slot with integer type during data augmentation (i.e., slot refilling) process. In this way, our question-SQL patterns are generated based on existing human labeled examples, which ensures that the generated training examples are natural.</p><p>Once we have the one-to-one slot mapping be- tween questions and SQL queries, we apply a script that takes a new database schema with type information and generates new question-SQL ex- amples by filling empty slots. Specifically, for each database in WikiSQL, we first randomly sam-ple 10 question-SQL patterns. We randomly sam- ple columns from the database schema based on its type: for example, if the slot type in the pat- tern is "number", and then we only sample from columns with "real" type in the current database. We then refill the slots in both the question and SQL query with the selected column names. Sim- ilarly, we also refill table/value slots.</p><p>By this data augmentation method, we finally obtain about 98,000 question and SQL pairs using about 18,000 WikiSQL databases with one single table. Additionally, we also use the original Wik- iSQL training dataset in experiments.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Experiments</head><p>Dataset In our experiments, we use Spider ( <ref type="bibr" target="#b34">Yu et al., 2018b</ref>), the new large-scale human an- notated text-to-SQL dataset with complex SQL queries and cross-domain databases. In addition to their originally annotated data, their training split includes 752 queries and 1659 questions from six existing datasets: Restaurants ( <ref type="bibr" target="#b23">Tang and Mooney, 2001;</ref><ref type="bibr" target="#b19">Popescu et al., 2003b</ref>), GeoQuery (Zelle and Mooney, 1996), <ref type="bibr">Scholar (Iyer et al., 2017)</ref>, Aca- demic ( <ref type="bibr" target="#b10">Li and Jagadish, 2014</ref>), Yelp and IMDB ( <ref type="bibr" target="#b30">Yaghmazadeh et al., 2017)</ref>. In total, this dataset consists of 11,840 questions, 6,445 unique com- plex SQL queries, and 206 databases with multi- ple tables. We follow ( <ref type="bibr" target="#b34">Yu et al., 2018b)</ref>, and use 130, 36, 40 databases for train, development, test, respectively (randomly split).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Evaluation</head><p>We use evaluation metrics including SQL Compo- nent matching and Exact matching. To compute the component matching scores, we first decom- pose predicted queries on SQL clauses including SELECT, WHERE, GROUP BY, ORDER BY, and KEYWORDS separately. After that, we evaluate each predicted clause and the ground truth as bags of several sub-components, and check whether or not these two sets of components match exactly. F1 scores are reported for each of the above 5 clauses. Exact matching score is 1 if the model predicts all clauses correctly for a given example.</p><p>To better understand model performance on different queries, ( <ref type="bibr" target="#b34">Yu et al., 2018b</ref>) divide SQL queries into 4 levels: easy, medium, hard, extra hard. The definition of difficulty is based on the number of SQL components, selections, and con- ditions. Queries that contain more SQL keywords are considered harder.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Experimental Settings</head><p>Our model is implemented in PyTorch ( <ref type="bibr" target="#b15">Paszke et al., 2017</ref>). We build each module based on the TypeSQL ( <ref type="bibr" target="#b33">Yu et al., 2018a</ref>) implementation. We use pre-trained GloVe ( <ref type="bibr" target="#b16">Pennington et al., 2014</ref>) embeddings for all question, SQL history, and schema tokens. All word embeddings are fixed. For each experiment, the dimension and dropout rate of all hidden layers is set to 120 and 0.3 re- spectively. We use Adam ( <ref type="bibr" target="#b9">Kingma and Ba, 2015)</ref> with the default hyperparameters for optimization, with a batch size of 64. The same loss functions in ( <ref type="bibr" target="#b29">Xu et al., 2017)</ref> are used.</p><p>• Training data: Spider (plus examples from 6 existing datasets) + WikiSQL + data aug- mentation</p><p>• Model architecture: history path + table- aware column encoding</p><p>We will conduct ablation studies to analyze the ef- fect of each of the proposed techniques.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Baseline Models</head><p>To demonstrate the efficacy of our model in ad- dressing the complex, cross-domain text-to-SQL task, we compare the performance of our model with several previous state-of-the-art models in the text-to-SQL task. As the dataset and task defini- tion used in this work are fundamentally different from prior work using datasets such as GeoQuery, WikiSQL, we adapted these models to our task in the same way as ( <ref type="bibr" target="#b34">Yu et al., 2018b)</ref>. Specifically:</p><p>Seq2Seq with Attention or Copying In order to make the models aware of the   <ref type="table">Table 1</ref> presents our test results on the Spider dataset with database splitting. Our model with full history and data augmentation achieves 22.0% exact matching on all SQL queries, which is a 12.3% absolute increase compared to the previous best model, TypeSQL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results and Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Comparison with Baselines</head><p>Even though our individual modules are similar to SQLNet and TypeSQL, our syntax-aware decoder allows the modules to incorporate the SQL decod- ing history, which helps to achieve a significant gain in exact matching for queries of all hardness levels. Specifically, even without our data aug- mentation technique, SyntaxSQLNet outperforms the previous best, TypeSQL, by 5%. This result suggests that the syntax and history information is beneficial for this complex text-to-SQL task. Moreover, the tree-based decoder enables Syn- taxSQLNet to systematically generate nested queries, boosting the performance for Hard/Extra Hard. As <ref type="table">Table 1</ref> shows, SyntaxSQLNet achieves particularly high scores 17.8% and 4.8% for Hard and Extra Hard, which contain nested queries. The Seq2Seq models suffer from generating ungram- matical queries, yielding very low exact matching accuracy on Hard and Extra Hard SQL queries. In contrast, our model generates valid SQL queries by enforcing the syntax.</p><p>For the detailed component matching results in <ref type="table" target="#tab_0">Table 2</ref>, our model consistently outperforms other previous work by significant margins. Specifi- cally, our model improve F1 score for most of the SQL components by more than 10%.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Ablation Study</head><p>In order to understand the techniques that are re- sponsible for the performance of our model, we perform an ablation study where we remove one of the proposed techniques from our model at a time. The exact match scores are shown in the same ta-bles as other baselines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.1">Data Augmentation</head><p>Our model's exact matching performance on all queries drops 4.4% by excluding data augmen- tation technique. This drop is particularly large for GROUP BY and ORDER BY components (Ta- ble 2), for which the original Spider dataset has a relatively small number of training examples. Thus, our cross-domain data augmentation tech- nique significantly benefits the model performance by extending to a much larger training dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.2">SQL Decoding History</head><p>In order to gain more insight into how our SQL decoding history addresses complex SQL, we re- port our model's performance without SQL path history. As shown in the <ref type="table">Table 1</ref>, the model's per- formance drops about 4.8% on exacting matching metric without the SQL history input. More im- portantly, its performance on hard and extra hard SQL queries decreases to 0%. This indicates that our model is able to predict nested queries thanks to the SQL decoding history.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2.3">Column Encoding</head><p>To see how our table-aware column encoding af- fects performance of our model, we also report the model's result without using table information for our column encoding. After excluding the ta- ble embedding from column embeddings, the test performance goes down by about 4%. This drop is especially large for Medium/Hard SQL queries and SELECT component, where the correct col- umn prediction is a key. This result shows that the table-aware encoding is very important to predict the correct columns in unseen, complex dasebases (with many foreign keys).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In this paper, we presented a syntax tree-based model to address complex and cross-domain text- to-SQL task. Utilizing a SQL specific syntax de- coder, as well as SQL path history and table-aware column attention encoders, our model outperforms previous work by a significant margin. The ab- lation study demonstrates that our proposed tech- niques are able to predict nested, complex SQL queries correctly even for unseen databases.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 2 .</head><label>2</label><figDesc>.....</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1" validated="false"><head>Table n</head><label>n</label><figDesc></figDesc><table>Columns 

ID name department_name salary .... 

name 
building 
budget 
....... 

primary key 

foreign key 

Correct SQL 
translation: 

SELECT min(salary), department_name 
FROM instructor 
GROUP BY department_name 
HAVING avg(T1.salary) &gt; 
(SELECT avg(salary) FROM instructor) 

Our tree-based 
SQL generation: 

ROOT 

SELECT 

salary 

avg 

min 
none 

salary 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2" validated="false"><head></head><label></label><figDesc>) only needed the column names as WikiSQL dataset only con- tained one table per question-SQL pair, Spider's databases contain multiple tables. To address this setting, we propose to use both table and column names to construct column embeddings.</figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5" validated="false"><head>Table 2 :</head><label>2</label><figDesc></figDesc><table>F1 scores of Component Matching on all SQL queries. 

to help the model better understand entities and 
numbers in natural language inputs. As they are 
originally designed for WikiSQL, to conduct ex-
periments on Spider, Yu et al. (2018b) extend their 
SELECT and WHERE modules to other SQL com-
ponents. 

</table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgement</head><p>We thank Graham Neubig, Tianze Shi, and three anonymous reviewers for their helpful feedback and discussion on this work.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Weakly supervised learning of semantic parsers for mapping instructions to actions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Transactions of the Association forComputational Linguistics</title>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Abstract meaning representation for sembanking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Laura</forename><surname>Banarescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Claire</forename><surname>Bonial</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shu</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Madalina</forename><surname>Georgescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kira</forename><surname>Griffitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Hermjakob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philipp</forename><surname>Koehn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martha</forename><surname>Palmer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 7th Linguistic Annotation Workshop and Interoperability with Discourse</title>
		<meeting>the 7th Linguistic Annotation Workshop and Interoperability with Discourse</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Semantic parsing via paraphrasing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Berant</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 52nd Annual Meeting of the Association for Computational Linguistics<address><addrLine>Baltimore, Maryland</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2014" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1415" to="1425" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Probabilistic frame-semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dipanjan</forename><surname>Das</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nathan</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Desai</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Noah</forename><forename type="middle">A</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">NAACL</title>
		<imprint>
			<date type="published" when="2010" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Language to logical form with neural attention</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics, ACL 2016</title>
		<meeting>the 54th Annual Meeting of the Association for Computational Linguistics, ACL 2016<address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2016-08-07" />
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Coarse-to-fine decoding for neural semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Dong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 56th Annual Meeting of the Association for Computational Linguistics</title>
		<meeting>the 56th Annual Meeting of the Association for Computational Linguistics</meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2018" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="731" to="742" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improving text-to-sql evaluation methodology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Catherine</forename><surname>Finegan-Dollak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">K</forename><surname>Kummerfeld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Li</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthik</forename><surname>Ramanathan Dhanalakshmi Ramanathan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sesh</forename><surname>Sadasivam</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dragomir</forename><surname>Radev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL 2018</title>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Translating questions to sql queries with generative parsers discriminatively reranked</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alessandra</forename><surname>Giordani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alessandro</forename><surname>Moschitti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">COLING (Posters)</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="401" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Learning a neural semantic parser from user feedback</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Srinivasan</forename><surname>Iyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ioannis</forename><surname>Konstas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayant</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<idno>abs/1704.08760</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Adam: A method for stochastic optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Diederik</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jimmy</forename><surname>Kingma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ba</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The 3rd International Conference for Learning Representations</title>
		<meeting><address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Constructing an interactive natural language interface for relational databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fei</forename><surname>Li</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2014" />
			<publisher>VLDB</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Constructing a generic natural language interface for an xml database</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yunyao</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Huahai</forename><surname>Yang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EDBT</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2006" />
			<biblScope unit="volume">3896</biblScope>
			<biblScope unit="page" from="737" to="754" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Learning dependency-based compositional semantics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Liang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Jordan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Association for Computational Linguistics (ACL)</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="590" to="599" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Effective approaches to attention-based neural machine translation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thang</forename><surname>Luong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hieu</forename><surname>Pham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 2015 Conference on Empirical Methods in Natural Language Processing</title>
		<meeting>the 2015 Conference on Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2015" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Compositional semantic parsing on semi-structured tables</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Panupong</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural Language Processing</title>
		<meeting>the 53rd Annual Meeting of the Association for Computational Linguistics and the 7th International Joint Conference on Natural Language Processing of the Asian Federation of Natural Language Processing<address><addrLine>Beijing, China</addrLine></address></meeting>
		<imprint>
			<publisher>Long Papers</publisher>
			<date type="published" when="2015-07-26" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="1470" to="1480" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Automatic differentiation in pytorch</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Paszke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sam</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Soumith</forename><surname>Chintala</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Chanan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Edward</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zachary</forename><surname>Devito</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zeming</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alban</forename><surname>Desmaison</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Antiga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Adam</forename><surname>Lerer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
	<note>Workshop</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Glove: Global vectors for word representation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Pennington</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">D</forename><surname>Manning</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<publisher>ACL</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="1532" to="1543" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Modern natural language interfaces to databases: Composing statistical parsing with semantic tractability</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ana-Maria</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Armanasu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Ko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Yates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th international conference on Computational Linguistics</title>
		<meeting>the 20th international conference on Computational Linguistics</meeting>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page">141</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Towards a theory of natural language interfaces to databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ana-Maria</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Kautz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th international conference on Intelligent user interfaces</title>
		<meeting>the 8th international conference on Intelligent user interfaces</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003" />
			<biblScope unit="page" from="149" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Towards a theory of natural language interfaces to databases</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ana-Maria</forename><surname>Popescu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oren</forename><surname>Etzioni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Henry</forename><surname>Kautz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference on Intelligent User Interfaces</title>
		<meeting>the 8th International Conference on Intelligent User Interfaces</meeting>
		<imprint>
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Abstract syntax networks for code generation and semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maxim</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL (1)</title>
		<imprint>
			<publisher>Association for Computational Linguistics</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1139" to="1149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Large-scale semantic parsing without questionanswer pairs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Siva</forename><surname>Reddy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mirella</forename><surname>Lapata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Steedman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transactions of the Association for Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="377" to="392" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<monogr>
		<title level="m" type="main">Cross-domain semantic parsing via paraphrasing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yu</forename><surname>Su</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xifeng</forename><surname>Yan</surname></persName>
		</author>
		<idno>abs/1704.05974</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Using multiple clause constructors in inductive logic programming for semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Lappoon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond J</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ECML</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2001" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="466" to="477" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Pointing out sql queries from text</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Synthesizing highly expressive sql queries from input-output examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alvin</forename><surname>Cheung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rastislav</forename><surname>Bodik</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<meeting>the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2017" />
			<biblScope unit="page" from="452" to="466" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">An efficient easily adaptable system for interpreting natural language queries</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">D</forename><surname>David</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Warren</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">N</forename><surname>Fernando</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Pereira</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Linguistics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3-4</biblScope>
			<biblScope unit="page" from="110" to="122" />
			<date type="published" when="1982" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Learning synchronous grammars for semantic parsing with lambda calculus</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuk</forename><forename type="middle">Wah</forename><surname>Wong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 45th</title>
		<meeting>the 45th</meeting>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<monogr>
				<title level="m">Annual Meeting of the Association for Computational Linguistics (ACL-2007)</title>
		<meeting><address><addrLine>Prague, Czech Republic</addrLine></address></meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaojun</forename><surname>Xu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1711.04436</idno>
		<title level="m">Sqlnet: Generating structured queries from natural language without reinforcement learning</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sqlizer: Query synthesis from natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Navid</forename><surname>Yaghmazadeh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yuepeng</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Isil</forename><surname>Dillig</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Dillig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Program. Lang</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">26</biblScope>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Neural enquirer: Learning to query tables in natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhengdong</forename><surname>Lu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hang</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ben</forename><surname>Kao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016</title>
		<meeting>the Twenty-Fifth International Joint Conference on Artificial Intelligence, IJCAI 2016<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2016-07" />
			<biblScope unit="page" from="2308" to="2314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">A syntactic neural model for general-purpose code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACL (1)</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="440" to="450" />
		</imprint>
	</monogr>
	<note>Association for Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Typesql: Knowledgebased type-aware neural text-to-sql generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zifan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zilin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dragomir</forename><surname>Radev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of NAACL. Association for Computational Linguistics</title>
		<meeting>NAACL. Association for Computational Linguistics</meeting>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Spider: A largescale human-labeled dataset for complex and crossdomain semantic parsing and text-to-sql task</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Yu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rui</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michihiro</forename><surname>Yasunaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongxu</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zifan</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Irene</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Qingning</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shanelle</forename><surname>Roman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zilin</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dragomir</forename><surname>Radev</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">EMNLP</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Learning to parse database queries using inductive logic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Raymond</forename><forename type="middle">J</forename><surname>Zelle</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mooney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI/IAAI</title>
		<meeting><address><addrLine>Portland, OR</addrLine></address></meeting>
		<imprint>
			<publisher>AAAI Press/MIT Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="1050" to="1055" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<monogr>
		<title level="m" type="main">Learning to map sentences to logical form: Structured classification with probabilistic categorial grammars</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><forename type="middle">S</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Collins</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<publisher>UAI</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
		<title level="m" type="main">Seq2sql: Generating structured queries from natural language using reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caiming</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<idno>abs/1709.00103</idno>
		<imprint>
			<date type="published" when="2017" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
