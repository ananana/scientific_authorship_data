<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:55+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">SemRegex: A Semantics-Based Approach for Generating Regular Expressions from Natural Language Specifications</title>
			</titleStmt>
			<publicationStmt>
				<publisher>Association for Computational Linguistics</publisher>
				<availability status="unknown"><p>Copyright Association for Computational Linguistics</p>
				</availability>
				<date>October 31-November 4, 2018. 2018</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zexuan</forename><surname>Zhong</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaqi</forename><surname>Guo</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Xi&apos;an Jiaotong University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Yang</surname></persName>
							<affiliation key="aff2">
								<orgName type="institution">University of Texas at Dallas</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian</forename><surname>Peng</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Xie</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois at Urbana-Champaign</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jian-Guang</forename><surname>Lou</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Microsoft Research Asia</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ting</forename><surname>Liu</surname></persName>
							<affiliation key="aff1">
								<orgName type="institution">Xi&apos;an Jiaotong University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongmei</forename><surname>Zhang</surname></persName>
							<affiliation key="aff3">
								<orgName type="institution">Microsoft Research Asia</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">SemRegex: A Semantics-Based Approach for Generating Regular Expressions from Natural Language Specifications</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing</title>
						<meeting>the 2018 Conference on Empirical Methods in Natural Language Processing <address><addrLine>Brussels, Belgium</addrLine></address>
						</meeting>
						<imprint>
							<publisher>Association for Computational Linguistics</publisher>
							<biblScope unit="page" from="1608" to="1618"/>
							<date type="published">October 31-November 4, 2018. 2018</date>
						</imprint>
					</monogr>
					<note>1608</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Recent research proposes syntax-based approaches to address the problem of generating programs from natural language specifications. These approaches typically train a sequence-to-sequence learning model using a syntax-based objective: maximum likelihood estimation (MLE). Such syntax-based approaches do not effectively address the goal of generating semantically correct programs, because these approaches fail to handle Program Aliasing, i.e., semantically equivalent programs may have many syntactically different forms. To address this issue, in this paper , we propose a semantics-based approach named SemRegex. SemRegex provides solutions for a subtask of the program-synthesis problem: generating regular expressions from natural language. Different from the existing syntax-based approaches, SemRegex trains the model by maximizing the expected semantic correctness of the generated regular expressions. The semantic correctness is measured using the DFA-equivalence oracle, random test cases, and distinguishing test cases. The experiments on three public datasets demonstrate the superiority of SemRegex over the existing state-of-the-art approaches.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Translating natural language (NL) descriptions into executable programs is a fundamental prob- lem for computational linguistics. An end user may have difficulty to write programs for a certain task, even when the task is already specified in NL. For some tasks, even for developers, who have ex- perience in writing programs, it can be time con- suming and error prone to write programs based on the NL description of the task. Naturally, au- tomatically synthesizing programs from NL can help alleviate the preceding issues for both end users and developers.</p><p>Recent research proposes syntax-based ap- proaches to address some tasks of this problem in different domains, such as regular expressions (regex) ( <ref type="bibr" target="#b23">Locascio et al., 2016)</ref>, Bash scripts ( <ref type="bibr" target="#b21">Lin et al., 2017)</ref>, and Python programs <ref type="bibr" target="#b36">(Yin and Neubig, 2017</ref>). These approaches typically train a sequence-to-sequence learning model using max- imum likelihood estimation (MLE). Using MLE encourages the model to output programs that are syntactically similar with the ground-truth pro- grams in the training set. However, such syntax- based training objective deviates from the goal of synthesizing semantically equivalent programs. Specifically, these syntax-based approaches fail to handle the problem of Program Aliasing ( <ref type="bibr" target="#b8">Bunel et al., 2018)</ref>, i.e., a semantically equivalent program may have many syntactically different forms. <ref type="table">Table 1</ref> shows some examples of the Pro- gram Aliasing problem. Both Program 1 and Program 2 are desirable outputs for the given NL specification but one of them is penalized by syntax-based approaches if the other one is used as the ground truth, compromising the overall ef- fectiveness of these approaches.</p><p>In this paper, we focus on generating regu- lar expressions from NL, an important task of the program-synthesis problem, and propose Sem- Regex, a semantics-based approach to generate regular expressions from NL specifications. Regu- lar expressions are widely used in various applica- tions, and "regex" is one of the most common tags in Stack Overflow 1 with more than 190, 000 re- lated questions. The huge number of regex-related questions indicates the importance of this task.</p><p>Different from the existing syntax-based ap- proaches, SemRegex alters the syntax-based train- ing objective of the model to a semantics-based objective. To encourage the translation model to generate semantically correct regular expressions, instead of MLE, SemRegex trains the model by maximizing the expected semantic correctness of <ref type="table">Table 1</ref>: Examples of Program Aliasing: for each NL specification, Program 2 is semantically equivalent to Program 1; however, if Program 1 is the ground truth in the training set, Program 2 is penalized by syntax-based approaches although it is a desirable program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Domain NL Specification Program 1 Program 2</head><p>Regex Match lines that start with an uppercase vowel and end with 'X' generated regular expressions. We follow the tech- nique of policy gradient <ref type="bibr" target="#b35">(Williams, 1992)</ref> to esti- mate the gradients of the semantics-based objec- tive and perform optimization. The measurement of semantic correctness serves as a key part in the semantics-based objec- tive, which should represent the semantics of pro- grams. In this paper, we convert a regular expres- sion to a minimal Deterministic Finite Automaton (DFA). Such conversion is based on the insight that semantically equivalent regular expressions have the same minimal DFAs. We define the se- mantic correctness of a generated regular expres- sion as whether its corresponding minimal DFA is the same as the ground truth's minimal DFA.</p><formula xml:id="formula_0">([AEIOUaeiou]&amp;[A-Z]). * X ([AEIOU]. * )&amp;(. * X) Bash Rename file 'f1' to 'f1.txt' mv 'f1' 'f1.txt' cp 'f1' '</formula><p>When our approach is applied on domains other than regular expressions such as Python programs and Bash scripts, a perfect equivalence oracle such as minimal DFAs may not be feasibly available. To handle a more general case, we propose cor- rectness assessment based on test cases for regu- lar expression; such correctness assessment can be easily generalized for other tasks of program syn- thesis. Concretely, we generate test cases to rep- resent semantics of the ground truth. For a gen- erated regular expression, we assess its semantic correctness by checking whether it can pass all the test cases. However, a regular expression may have infinite positive (i.e., matched) or negative (i.e., unmatched) string examples; thus, we can- not perfectly represent the semantics. To use lim- ited string examples to differentiate whether a gen- erated regular expression is semantically correct or not, we propose an intelligent strategy for test generation to generate distinguishing test cases in- stead of just using random test cases.</p><p>We evaluate SemRegex on three public datasets: NL-RX-Synth, NL-RX-Turk ( <ref type="bibr" target="#b23">Locascio et al., 2016)</ref>, and KB13 ( <ref type="bibr" target="#b19">Kushman and Barzilay, 2013)</ref>. We compare SemRegex with the existing state-of- the-art approaches on the task of generating regu- lar expressions from NL specifications. Our evalu- ation results show that SemRegex outperforms the start-of-the-art approaches on all of three datasets. The evaluation results confirm that by maximizing semantic correctness, the model can output more correct regular expressions even when the regu- lar expressions are syntactically different from the ground truth.</p><p>In summary, this paper makes the follow- ing three main contributions.</p><p>(1) We pro- pose a semantics-based approach to optimize the semantics-based objective for the task of gener- ating regular expressions from NL specifications. (2) We introduce the measurement of semantic correctness based on test cases, and propose a strategy to generate distinguishing test cases, in order to better measure the semantic correctness than using random test cases. (3) We evaluate our approach on three public datasets. The evaluation results show that our approach outperforms the ex- isting state-of-the-art on all of the three datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Problem Formulation</head><p>Consider the problem of automatically generating a regular expression R given an NL specification S as an input. Let S = s 1 , s 2 , . . . , s m denote the NL specification, where s i represents a word in the vocabulary; let R = r 1 , r 2 , . . . , r n denote the regular expression, where r i is a valid character in the regular expression.</p><p>We assume that we have a training set consist- ing of K NL and regular expression pairs:</p><formula xml:id="formula_1">D = (S (i) , R (i) ) i=1..K</formula><p>Given an NL specification, it is possible to have multiple regular expressions fitting the specifica- tion. In the training set, only one regular expres- sion is provided for each NL specification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">SemRegex Approach</head><p>In this section, we illustrate our SemRegex ap- proach in detail. First, we introduce our model, which is a sequence-to-sequence learning model.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Next, we alter the standard Maximum Likelihood</head><p>Estimation (MLE) objective to maximize semantic correctness. We leverage policy gradient to train the model with the semantics-based objective. Fi- nally, we discuss how to measure semantic cor- rectness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Model</head><p>It is natural to apply a machine-translation model on the program-synthesis problem. We follow a previous attempt ( <ref type="bibr" target="#b23">Locascio et al., 2016</ref>) to use a sequence-to-sequence learning model <ref type="bibr" target="#b30">(Sutskever et al., 2014</ref>) augmented with the attention mech- anism ( <ref type="bibr" target="#b2">Bahdanau et al., 2014</ref>). The model con- sists of an encoder network and a decoder net- work. In both the encoder network and decoder network, we use LSTM (Hochreiter and Schmid- huber, 1997) units that can be summarized as fol- low:</p><formula xml:id="formula_2">i t = σ(W i x t + U i h t−1 + b i ) f t = σ(W f x t + U f h t−1 + b f ) o t = σ(W o x t + U o h t−1 + b o ) ˜ c t = φ(W c x t + U c h t−1 + b c ) c t = f t • c t−1 + i t • ˜ c t h t = o t • φ(c t )</formula><p>where σ is the sigmoid function, φ is the hy- perbolic tangent function, and • is the element- wise multiplication; weight matrices W and U along with biases b are learnable parameters of the model. In the encoder network, the input x t is an embedding vector of the word s t in the NL input sequence. In the decoder network, the input x t is an embedding vector of the previous character r t−1 in the output regular expression. The hid- den vectors h t of the encoder network are fed into an attention layer ( <ref type="bibr" target="#b2">Bahdanau et al., 2014</ref>) to out- put an overall representation of the input sentence considering the output position. The hidden vec- tors h t of the decoder network are fed into a dense layer z t = W z h t , where z t holds the dimension of the vocabulary size of the regular expression. z t is the output of the decoder network to predict the output character r t = arg max j z t,j .</p><p>A softmax function is applied on z t to obtain a probability distribution on output character can- didates. The probability of character j at output position t is as follow:</p><formula xml:id="formula_3">p(r t = j|r &lt;t , S) = e z t,j j e z t,j</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Training</head><p>Let θ represent all learnable parameters in the model. We discuss two objective functions of θ to train the model. Maximum Likelihood Estimation (MLE). A sequence-to-sequence learning model learns the distribution of regular expressions R given an in- put NL sentence S:</p><formula xml:id="formula_4">p θ (R|S) = T t=1 p θ (r t |r &lt;t , S)</formula><p>By default, the sequence-to-sequence learn- ing model uses maximum likelihood estimation (MLE) for training, i.e., maximizing the likelihood of mapping the input sequence to the output se- quence for each pair in the training set. Specif- ically, the optimal parameters θ * are obtained as follow:</p><formula xml:id="formula_5">θ * = arg max θ (S (i) ,R (i) )∈D p θ (R (i) |S (i) ) = arg max θ (S (i) ,R (i) )∈D log p θ (R (i) |S (i) )</formula><p>Gradient descent is used to search out optimal pa- rameters θ * . However, MLE fails to consider the fact that semantically equivalent regular expressions might be syntactically different. The MLE objective function forces the model to generate syntactically similar regular expressions, but penalizes semanti- cally equivalent and syntactically different regular expressions. Such a syntax-based training objec- tive does not fit our task's objective (i.e., generat- ing any semantically correct regular expression). Maximizing Semantic Correctness. To encour- age the model to generate any semantically correct regular expression, we alter the MLE training ob- jective function to maximize semantic correctness.</p><p>For an NL specification, we define a reward of a predicted regular expression r(R) as its semantic correctness (we discuss how to measure the cor- rectness later in this section). We encourage the model to generate regular expressions to maximize expected rewards instead of MLE. Concretely, we train the model parameters θ to maximize the fol- lowing objective function:</p><formula xml:id="formula_6">J(θ) = (S (i) ,R (i) )∈D E R∼p θ (·|S (i) ) r(R) = (S (i) ,R (i) )∈D R p θ (R|S (i) )r(R)</formula><p>However, to compute the expected reward, we need to go over all possible regular expressions, and the number of all possible regular expressions is infinite. To address this problem, we use the Monte Carlo estimate as the approximation of the expected value. Specifically, M regular expres- sions R 1 , . . . , R M are sampled following the out- put probability of the model. We average the re- ward of each sample to estimate the expected re- ward:</p><formula xml:id="formula_7">J(θ) ≈ (S (i) ,R (i) )∈D M j=1 1 M r(R j ),</formula><p>where</p><formula xml:id="formula_8">R j ∼ p θ (·|S (i) )</formula><p>In order to compute the gradient of the expected reward and to maximize the objective using gra- dient descent, we employ the REINFORCE tech- nique of policy gradient <ref type="bibr" target="#b35">(Williams, 1992)</ref>, which is based on the following estimation:</p><formula xml:id="formula_9">θ J(θ) ≈ (S (i) ,R (i) )∈D M j=1 1 M r(R j ) θ log p θ (R j |S (i) ),</formula><p>where</p><formula xml:id="formula_10">R j ∼ p θ (·|S (i) )</formula><p>In practice, we subtract the mean reward of all samples to reduce the variance of estimated gradi- ent <ref type="bibr" target="#b35">(Williams, 1992)</ref>. The final gradient estimate is as follow:</p><formula xml:id="formula_11">θ J(θ) ≈ (S (i) ,R (i) )∈D M j=1 1 M ˜ r(R j ) θ log p θ (R j |S (i) ),</formula><p>where˜rwhere˜ where˜r</p><formula xml:id="formula_12">(R j ) = r(R j ) − M j =1 1 M r(R j )</formula><p>The overall training algorithm is summarized in Algorithm 1. We initialize θ by pre-training the model using MLE on the training set. For each pair in training set, we sample M regular expres- sions to estimate the gradient.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Measurement of Semantic Correctness</head><p>In this paper, we propose two types of measuring semantic correctness based on minimal DFAs and test cases, respectively. Minimal DFAs. We convert a regular expres- sion to a minimal DFA and utilize the fact that equivalent regular expressions have the same Algorithm 1: Policy-gradient method to maximize semantic correctness Input: Training set:</p><formula xml:id="formula_13">D = (S (i) , R (i) ) 1 Initilize θ from pretrained model using MLE on D ; 2 for each epoch do 3 for (S (i) , R (i) ) ∈ D do 4</formula><p>Sample R 1 , . . . , R M using current model ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head><p>Get rewards r(R 1 ), . . . , r(R M ) ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6</head><p>Estimate θ J(θ) using (3.2) ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>7</head><p>Update θ using θ J(θ) by gradient descent ;</p><formula xml:id="formula_14">8 end 9 end s 0 s 1 s 2 A,B =X X (a)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Path</head><p>String example</p><formula xml:id="formula_15">s 0 A − → s 1 X − → s 2 AX s 0 B − → s 1 K − → s 1 X − → s 2 BKX s 0 B − → s 1 X − → s 2 BX (b) Figure 1: Minimal DFA converted from "([ABab]&amp;[A-Z]). * X"</formula><p>and generated string examples, where s 0 represents the start state and s 2 is the only accept state.</p><p>minimal DFAs even when they are syntacti- cally different <ref type="bibr" target="#b16">(Hopcroft et al., 1979)</ref>. For example, the minimal DFA of regular expres- <ref type="figure">Fig- ure 1(a)</ref>. A syntactically different regular expres- sion "((A|B). * )&amp;(. * X)" can be converted to the same minimal DFA as shown in <ref type="figure">Figure 1(a)</ref>, indicating that these two regular expressions are semantically equivalent.</p><formula xml:id="formula_16">sion "([ABab]&amp;[A-Z]). * X" is shown in</formula><p>We check whether two regular expressions are equivalent by checking whether their correspond- ing minimal DFAs are the same. When the policy- gradient method is performed, if a sampled regu- lar expression R is equivalent to the ground truth, then r(R) = 1; otherwise r(R) = 0. Test Cases. A perfect equivalence oracle such as using the minimal DFA may not be feasibly available for some tasks, e.g., when our approach is applied on other domains such as generating Bash scripts and Python programs. To handle a more general case, we propose correctness mea- surement based on test cases. We generate test cases (i.e., inputs and expected outputs) and check whether a program can pass the test cases that are generated from the ground truth to approximately check whether the program and the ground truth are equivalent.</p><p>Given</p><note type="other">a regular expression R, we generate test cases that contain positive (acceptable/matched) and negative (unacceptable/unmatched) string ex- amples. Here we consider only positive exam- ples because negative examples can be obtained by generating positive examples of its complement regular expression ∼R. To generate positive string examples from regular expression R, we convert R to its corresponding minimal DFA. Each posi- tive string example</note><p>corresponds to a path from the start state of the minimal DFA to any accept state 2 , and vice versa. Thus, we generate paths randomly from the start state to any accept state, and convert the paths to their corresponding strings as shown in <ref type="figure">Figure 1(b)</ref>. To generate distinct string exam- ples, we aim to generate paths to cover as many transitions as possible. In particular, we mask all transitions that have been covered by previously generated paths. When we generate a new path, the not-covered transitions have higher priority to be explored than covered ones.</p><p>Because complex regular expressions may ac- cept/match or reject/unmatch infinite string ex- amples, we augment random generation with a new strategy to generate distinguishing test cases to better represent the semantics. Considering that the generated test cases are used to check whether a Monte-Carlo sampled regular expres- sion is equivalent to the ground truth in the policy- gradient method, only test cases that can differen- tiate an incorrect sample and the ground truth are useful. Based on such insight, we give preference to test cases that differentiate Monte-Carlo sam- ples and the ground truth. A challenge here is that we do not know the samples before performing the policy-gradient method. However, we find that there is a high chance to get the same samples re- peatedly when the model is pre-trained using MLE on the training set, because sampling is following the distribution learned by the pre-trained model. Based on the observation, we use the Beam Search 2 A DFA has one start state and a set of accept states. algorithm on the pre-trained model to obtain B most likely samplesˆRsamplesˆ samplesˆR 1 , . . . , ˆ R B . We generate string examples that can differentiate these sam- ples and the ground truth, named as distinguishing string examples. For eachˆReachˆ eachˆR and ground truth R, we construct a new regular expression R&amp;(∼ ˆ R), and generate its string examples that can differen- tiate R andˆRandˆ andˆR.</p><p>The overall idea of our strategy for generating string examples is shown in Algorithm 2. Once we have a set of positive and negative string exam- ples, we define the reward of a regular expression as r(R) = 1 if it can pass all the test cases, and r(R) = 0 otherwise.</p><p>When extending SemRegex on other languages where a perfect equivalence oracle is not available, it is desirable to use a technique to generate test cases for a program. There exist techniques (dis- cussed in Section 5) to generate test cases for a general executable program.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm 2: Generating distinguishing test cases for regular expressions</head><p>Input: Training set: D = (S (i) , R (i) ) , the number of examples to generate: T , and a pre-trained model Output: Positive and negative example sets P (i) and</p><formula xml:id="formula_17">N (i) 1 for (S (i) , R (i) ) ∈ D do 2 P (i) ← ∅ ; 3 N (i) ← ∅ ; 4</formula><p>Beam search on pre-trained model to obtainˆRobtainˆ obtainˆR 1 , . . . , ˆ R B ;</p><formula xml:id="formula_18">5 repeat 6</formula><p>Randomly pick a j in <ref type="bibr">[1, B]</ref> ;</p><formula xml:id="formula_19">7 R p ← R (i) &amp;(∼ ˆ R j ) ; 8 R n ← (∼R (i) )&amp; ˆ R j ; 9</formula><p>Generate an example p from R p ;</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>10</head><p>Generate an example n from R n ;</p><p>11</p><formula xml:id="formula_20">P (i) ← P (i) ∪ {p} ; 12 N (i) ← N (i) ∪ {n} ; 13 until |P (i) | ≥ T &amp;&amp; |N (i) | ≥ T ;</formula><p>14 end</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We evaluate the effectiveness of SemRegex by comparing it to the state-of-the-art approaches. We also study how using different measurements of correctness impacts the effectiveness of Sem- Regex.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Experiment Setup</head><p>Datasets. We conduct our experiments on three public datasets for the task of generating regular expressions from NL specifications.</p><p>• KB13. KB13 ( <ref type="bibr" target="#b19">Kushman and Barzilay, 2013)</ref> includes 824 pairs of NL and regular expres- sion. When conducting data labeling, label- ing workers are asked to generate the NL specifications to capture a subset of the lines in a file. Then programmers are asked to gen- erate regular expressions for these NL speci- fications written by the labeling workers. We split the data into 75% training and 25% test- ing sets, following what the authors of KB13 do.</p><p>• NL-RX-Synth. NL-RX-Synth ( <ref type="bibr" target="#b23">Locascio et al., 2016</ref>) is a synthetic dataset much larger than KB13. Its authors define a small gram- mar for parsing regular expressions to NL. The grammar is used to stochastically gener- ate 10, 000 regular expressions and their cor- responding synthetic NL specifications. We split the pairs into 65% training, 10% devel- opment, and 25% testing sets, following what the authors of NL-RX-Synth do.</p><p>• NL-RX-Turk. NL-RX-Turk ( <ref type="bibr" target="#b23">Locascio et al., 2016</ref>) comes from the NL-RX-Synth dataset. Instead of directly using synthetic NL de- scriptions in the dataset, the authors of NL- RX-Turk ask labeling workers to paraphrase the synthetic specifications. The dataset also consists of 10, 000 pairs of NL and regular expression. We split the pairs into 65% train- ing, 10% development, and 25% testing sets, following what the authors of NL-RX-Turk do.</p><p>Training Setting. We use a two-layer stacked LSTM architecture in both the encoder and de- coder networks. The dimensions of encoder and decoder hidden states are set to 256. We use ran- dom embedding layers with the dimension of 128 for both input and output words. We also tune our hyper-parameters on the development set. The best results are obtained when the learning rate = 0.001 and the batch size = 25. We use the Monte-Carlo method to sample M = 10 regular expressions to estimate the gradient. To generate distinguishing string examples, we perform Beam Search to obtain B = 10 most likely samples. Be- fore performing the policy-gradient method, we pre-train the model using MLE for 100 epochs.</p><p>Then we train the model for 40 epochs using the policy-gradient method, and choose the model with the best effectiveness on the development set.</p><p>Our model is implemented in TensorFlow ( <ref type="bibr">Abadi et al., 2016</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results and Analysis</head><p>Comparison Results. We demonstrate the ef- fectiveness of our approach by comparing it to the existing approaches including Semantic- Unify ( <ref type="bibr" target="#b19">Kushman and Barzilay, 2013)</ref> and Deep- Regex(MLE) ( <ref type="bibr" target="#b23">Locascio et al., 2016</ref>). We also compare the results of our approach with differ- ent measurements of semantic correctness. Ta- ble 2 shows the comparison results of different ap- proaches, with detailed discussion as follows.</p><p>• Semantic-Unify. Semantic-Unify ( <ref type="bibr" target="#b19">Kushman and Barzilay, 2013</ref>) learns to parse NL to regular expressions. Similarly, DFA equiv- alence is applied as a semantic unification when training the parser.</p><p>• Deep-Regex(MLE). Deep- Regex(MLE) ( <ref type="bibr" target="#b23">Locascio et al., 2016)</ref> regards the problem as a black-box task of machine translation without utilizing any domain knowledge of regular expressions. A syntax-based objective (MLE) is used to train the model. To the best of our knowledge, Deep-Regex(MLE) is the state-of-the-art approach on these three datasets.</p><p>• SemRegex(DFA Oracle). In SemRegex (DFA Oracle), we use the oracle of DFA equivalence to measure semantic correctness. SemRegex(DFA Oracle) outperforms Deep- Regex(MLE), the existing state-of-the-art ap- proach, by an accuracy increase of 12.6% on KB13, 2.9% on NL-RX-Synth, and 4.1% on NL-RX-Turk, respectively. Compared to Deep-Regex(MLE), the results demon- strate the effectiveness of maximizing se- mantic correctness during the training phase. SemRegex(DFA Oracle) shows more im- provement on the KB13 dataset over Deep- Regex(MLE) than on other datasets. Such re- sult indicates that supervised learning based on MLE is less effective to learn from a small training set. When the policy-gradient method is used, Monte-Carlo samples can provide more information beyond only train- ing samples especially on a small training set; <ref type="table">Table 2</ref>: Effectiveness comparison of different approaches (using DFA-equivalence accuracy as metrics)</p><p>Approach KB13 NL-RX-Synth NL-RX-Turk Semantic-Unify 65.5% 46.3% 38.6% Deep-Regex(MLE) 65.6% 88.7% 58. <ref type="table">2%  SemRegex(DFA Oracle)</ref> 78.2% 91.6% 62.3% SemRegex(Distinguishing Test Cases) 77.5% 90.2% 61.3% SemRegex <ref type="figure">(Random Test Cases)</ref> 66.5% 90.2% 59.5%</p><p>such more information significantly improves the effectiveness.</p><p>• SemRegex(Distinguishing Test Cases).</p><p>When we do not have access to an oracle such as DFA equivalence, we can generate test cases to define semantic correctness. SemRegex(Distinguishing Test Cases) uses Algorithm 2 to generate distinguishing test cases (10 positive examples and 10 negative examples) that differentiate the results re- turned by Beam Search and the ground truth. The results show that by using distinguishing test cases, SemRegex(Distinguishing Test Cases) outperforms Deep-Regex(MLE), an existing syntax-based approach, on all of three datasets. Meanwhile, the effectiveness of SemRegex(Distinguishing Test Cases) drops no more than 1.4% on accuracy compared to SemRegex(DFA Oracle). Such result indicates that limited distinguishing test cases generated by the proposed strategy can well represent the semantics.</p><p>• SemRegex(Random Test Cases). Sem- Regex(Random Test Cases) generates ran- dom test cases instead of distinguishing test cases. It outperforms the exist- ing approaches (Semantic-Unify and Deep- Regex(MLE)) because random test cases can still represent the semantics and differenti- ate some inequivalent regular expressions. Compared to SemRegex(Distinguishing Test Cases), its effectiveness shows a big drop on KB13 and a slight drop on NL-RX-Turk. Such results indicate the benefit of distin- guishing test cases over random test cases.</p><p>Effectiveness of Semantics-Based Objective. To understand the effect of using a semantics-based learning objective, we record the semantic accu- racy (DFA equivalence) and syntactic accuracy (exact-match) on the NL-RL-Turk testing set af- ter each epoch as shown in <ref type="figure" target="#fig_1">Figure 2</ref>. During pre- training (epochs 1 to 100), we use MLE to train the model to increase both semantic accuracy and syn- tactic accuracy iteratively. Then, we alter the train- ing objective to maximize the expected semantic correctness. We notice that while semantic accu- racy continues increasing for about 10%, the syn- tactic accuracy does not show a significant growth after pre-training. Such result indicates that the model is no longer encouraged to generate regular expressions that are syntactically equivalent to the ground truths. Instead, the model learns to gener- ate semantically correct regular expressions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Analysis of Semantic Correctness Based on Test</head><p>Cases. The correctness measurements based on test cases serve as an approximate oracle. <ref type="figure">Figure 3</ref> shows an example of how the approximate oracle helps make improvement. Furthermore, we evalu- ate how the correctness based on test cases is close to the DFA-equivalence oracle. In Monte-Carlo estimate, we count the samples with the approxi- mate oracle that equals to the minimal DFA oracle. When using random test cases, there are 89.8% samples with the approximate oracle that equals to the minimal DFA oracle. When using distinguish-</p><formula xml:id="formula_21">R 3 :(([0-9]){2,})(.*) R 1 :(([0-9])(.+)){2,} Pos: "74i" R 2 :([0-9])((.*){2,})</formula><p>S: Strings that begin with at least two digits Neg: "8aa"</p><p>Figure 3: An example of how test cases help with training. At the beginning of the policy-gradient method, the model outputs an incorrect answer R 1 , which cannot pass a positive test case. R 1 gets penalized because it receives a reward 0. Then the model changes to output an incorrect answer R 2 , which cannot pass a negative test case. Similarly, R 2 gets penalized as training continues. R 3 re- ceives a reward 1 because it passes all test cases, resulting in an increase of its likelihood from the model in iterations. Finally, the model outputs the correct answer R 3 .</p><p>ing test cases, such percentage increases to 96.3%. Such result illustrates that test cases are able to ap- proximately check the semantic equivalence even when the test cases are generated randomly. The result also suggests that distinguishing test cases represent the semantics more effectively than ran- dom test cases. Impact of the Number of Test Cases. We study how the number of test cases impacts the effective- ness. We enumerate the number of distinguishing or random positive/negative string examples from T = 1 to T = 10 to show the impact on the ef- fectiveness (T = 0 refers to using MLE to train the model). As shown in <ref type="figure">Figure 4</ref>, when more dis- tinguishing test cases are used, higher accuracy is reached. However, more random test cases make limited improvement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>Program Synthesis. Our work falls into the gen- eral topic of program synthesis. Program syn- thesis is the problem of automatically generating programs from high-level specifications <ref type="bibr" target="#b13">(Gulwani et al., 2017</ref>  <ref type="formula">(2016)</ref> regard the problem as a black-box task of machine translation, and train a sequence- to-sequence learning model to address the prob- lem. There exists also a lot of work focusing on generating regular expressions from string exam- ples. Recent work typically uses an evolutionary algorithm to address the problem <ref type="bibr" target="#b31">(Svingen, 1998;</ref><ref type="bibr" target="#b9">Cetinkaya, 2007;</ref><ref type="bibr" target="#b5">Bartoli et al., 2012</ref><ref type="bibr" target="#b6">Bartoli et al., , 2016</ref>. Inspired by our previous study ( <ref type="bibr" target="#b38">Zhong et al., 2018)</ref>, in this paper, we leverage the help of string examples generated from ground truths to im- prove the state of the art for the problem of gen- erating regular expressions from NL. Compared with previous state-of-the-art approaches <ref type="bibr" target="#b23">(Locascio et al., 2016</ref>) that maximize the likelihood of ground truths in the training set, SemRegex lever- ages the policy-gradient method to encourage the model to generate semantically correct regular ex- pressions. Generating Test Cases. When SemRegex is ap-plied on domains other than synthesizing regu- lar expressions, a perfect equivalence oracle such as using the minimal DFA may not be feasi- bly available. In order to handle a more gen- eral case, we propose to generate test cases from the ground truths to measure the semantic cor- rectness of a program candidate. State-of-the-art test-generation techniques are typically based on Dynamic Symbolic Execution (DSE) ( <ref type="bibr" target="#b11">Godefroid et al., 2005</ref>). Given a program that we want to generate test cases for, DSE executes the program for some seed test cases, and at the same time collects symbolic constraints from branch state- ments along the execution path. Then DSE gen- erates new test cases to cover different branches in iterations by flipping a branching node in previ- ous execution path. In this way, DSE is able to generate test cases that can be used to approxi- mately check the semantic equivalence. Further- more, DSE can effectively generate distinguishing test cases for two executable programs by relating these two programs in a single execution <ref type="bibr" target="#b32">(Taneja and Xie, 2008)</ref>. Various DSE tools have been im- plemented for different programming languages, such as PyExZ3 (Python) ( <ref type="bibr" target="#b3">Ball and Daniel, 2015)</ref>, JPF-SE (Java) <ref type="bibr" target="#b1">(Anand et al., 2007)</ref>, Pex (C#) <ref type="bibr" target="#b33">(Tillmann and De Halleux, 2008;</ref><ref type="bibr" target="#b34">Tillmann et al., 2014;</ref><ref type="bibr" target="#b20">Li et al., 2009)</ref>, and CUTE (C) ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have proposed SemRegex, a semantics-based approach to generate regular expressions from NL specifications. SemRegex trains a sequence-to- sequence model by maximizing the expected se- mantic correctness. We measure the semantic cor- rectness using the DFA-equivalence oracle, ran- dom test cases, and distinguishing test cases. Our evaluation results show that SemRegex outper- forms the existing start-of-the-art approaches on three public datasets.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Semantic accuracy (DFA equivalence) and syntactic accuracy (exact-match) on the NLRL-Turk testing set after each epoch. The training objective is replaced to maximize expected correctness after 100 epochs. The correctness is measured by the DFA-equivalence oracle in this figure.</figDesc></figure>

			<note place="foot" n="1"> https://stackoverflow.com/questions/ tagged/regex</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The work from the authors at the University of Illinois at Urbana-Champaign was supported in part by National Science Foundation under grants no. CNS-1513939, CNS-1564274, and CCF-1816615. The work from the authors at Xi'an Jiaotong University was supported by National Natural Science Foundation of China (61632015, 61772408, 61721002).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martín</forename><surname>Abadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashish</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Barham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eugene</forename><surname>Brevdo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhifeng</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Citro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">S</forename><surname>Corrado</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andy</forename><surname>Davis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Dean</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthieu</forename><surname>Devin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sanjay</forename><surname>Ghemawat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ian</forename><forename type="middle">J</forename><surname>Goodfellow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Harp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoffrey</forename><surname>Irving</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Isard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yangqing</forename><surname>Jia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rafal</forename><surname>Józefowicz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lukasz</forename><surname>Kaiser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Manjunath</forename><surname>Kudlur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Josh</forename><surname>Levenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Oriol Vinyals</title>
		<editor>Talwar, Paul A. Tucker, Vincent Vanhoucke, Vijay Vasudevan, Fernanda B. Viégas</editor>
		<imprint/>
	</monogr>
	<note>and Xiaoqiang Zheng. 2016. TensorFlow: Large-scale machine learning on heterogeneous distributed systems. CoRR, abs/1603.04467</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">JPF-SE: A symbolic execution extension to Java PathFinder</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Saswat</forename><surname>Anand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Corina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Willem</forename><surname>Visser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Tools and Algorithms for the Construction and Analysis of Systems</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="134" to="138" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Neural machine translation by jointly learning to align and translate</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dzmitry</forename><surname>Bahdanau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kyunghyun</forename><surname>Cho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yoshua</forename><surname>Bengio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Deconstructing dynamic symbolic execution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Ball</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jakub</forename><surname>Daniel</surname></persName>
		</author>
		<idno>MSR-TR-2015-95</idno>
		<imprint>
			<date type="published" when="2015" />
			<pubPlace>Microsoft</pubPlace>
		</imprint>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">DeepCoder: Learning to write programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matej</forename><surname>Balog</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><forename type="middle">L</forename><surname>Gaunt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brockschmidt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sebastian</forename><surname>Nowozin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Tarlow</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Automatic generation of regular expressions from examples with genetic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alberto</forename><surname>Bartoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Giorgio</forename><surname>Davanzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">De</forename><surname>Lorenzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marco</forename><surname>Mauri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Medvet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Enrico</forename><surname>Sorio</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Companion on Genetic and Evolutionary Computation</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="1477" to="1478" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Inference of regular expressions for text extraction from examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alberto</forename><surname>Bartoli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrea</forename><forename type="middle">De</forename><surname>Lorenzo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Medvet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Fabiano</forename><surname>Tarlao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Knowledge and Data Engineering</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1217" to="1230" />
			<date type="published" when="2016" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">The inference of regular LISP programs from examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alan</forename><forename type="middle">W</forename><surname>Biermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Systems, Man, and Cybernetics</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="585" to="600" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Leveraging grammar and reinforcement learning for neural program synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rudy</forename><surname>Bunel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthew</forename><surname>Hausknecht</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jacob</forename><surname>Devlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pushmeet</forename><surname>Kohli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Regular expression generation through grammatical evolution</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ahmet</forename><surname>Cetinkaya</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference Companion on Genetic and Evolutionary Computation</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="2643" to="2646" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Towards synthesizing complex programs from inputoutput examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xinyun</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dawn</forename><surname>Song</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">DART: directed automated random testing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Patrice</forename><surname>Godefroid</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nils</forename><surname>Klarlund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Conference on Programming Language Design and Implementation</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="213" to="223" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Automating string processing in spreadsheets using input-output examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM SIGPLAN Symposium on Principles of Programming Languages</title>
		<imprint>
			<date type="published" when="2011" />
			<biblScope unit="page" from="317" to="330" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Program synthesis. Foundations and Trends in Programming Languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Polozov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rishabh</forename><surname>Singh</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="1" to="119" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">From language to programs: Bridging reinforcement learning and maximum marginal likelihood</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kelvin</forename><surname>Guu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Panupong</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evan</forename><forename type="middle">Zheran</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1051" to="1062" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Long short-term memory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sepp</forename><surname>Hochreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jürgen</forename><surname>Schmidhuber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Neural Computation</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1735" to="1780" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">Introduction to automata theory, languages, and computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rajeev</forename><surname>John E Hopcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Motwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1979" />
			<publisher>Addison-wesley Reading</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Neural-guided deductive search for real-time program synthesis from examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ashwin</forename><surname>Kalyan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Abhishek</forename><surname>Mohta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Polozov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dhruv</forename><surname>Batra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Prateek</forename><surname>Jain</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Weakly supervised training of semantic parsers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jayant</forename><surname>Krishnamurthy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Tom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Mitchell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint Conference on Empirical Methods in Natural Language Processing and Computational Natural Language Learning</title>
		<imprint>
			<date type="published" when="2012" />
			<biblScope unit="page" from="754" to="765" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Using semantic unification to generate regular expressions from natural language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference of the North American Chapter of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="826" to="836" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Reggae: Automated test generation for programs using complex regular expressions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nuo</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolai</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>De Halleux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfram</forename><surname>Schulte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering</title>
		<imprint>
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Program synthesis from natural language using recurrent neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chenglong</forename><surname>Xi Victoria Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deric</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Pang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Vu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">D</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ernst</surname></persName>
		</author>
		<idno>UW- CSE-17-03-01</idno>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
		<respStmt>
			<orgName>University of Washington Department of Computer Science and Engineering</orgName>
		</respStmt>
	</monogr>
<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Reinforcement learning on web interfaces using workflow-guided exploration</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Evan</forename><forename type="middle">Zheran</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kelvin</forename><surname>Guu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Panupong</forename><surname>Pasupat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Percy</forename><surname>Liang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Learning Representations</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Neural generation of regular expressions from natural language with minimal domain knowledge</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nicholas</forename><surname>Locascio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karthik</forename><surname>Narasimhan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eduardo</forename><surname>Deleon</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nate</forename><surname>Kushman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Regina</forename><surname>Barzilay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Empirical Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="1918" to="1923" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Integrating programming by example and natural language programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Mehdi Hafezi Manshadi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James F</forename><surname>Gildea</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Allen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">AAAI Conference on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="661" to="667" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Abstract syntax networks for code generation and semantic parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Maxim</forename><surname>Rabinovich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mitchell</forename><surname>Stern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Klein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="1139" to="1149" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">A multilingual natural-language interface to regular expressions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Aarne</forename><surname>Ranta</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Workshop on Finite State Methods in Natural Language Processing</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="79" to="90" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Compositional program synthesis from natural language and examples</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mohammad</forename><surname>Raza</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sumit</forename><surname>Gulwani</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Natasa</forename><surname>Milicfrayling</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Joint Conferences on Artificial Intelligence</title>
		<imprint>
			<date type="published" when="2015" />
			<biblScope unit="page" from="792" to="800" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">CUTE: a concolic unit testing engine for C</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koushik</forename><surname>Sen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darko</forename><surname>Marinov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gul</forename><surname>Agha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Joint Meeting of the European Software Engineering Conference and the ACM SIGSOFT Symposium on the Foundations of Software Engineering</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="263" to="272" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Semantic parsing with syntaxand table-aware SQL generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yibo</forename><surname>Sun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Duyu</forename><surname>Tang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nan</forename><surname>Duan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianshu</forename><surname>Ji</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guihong</forename><surname>Cao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Xiaocheng</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bing</forename><surname>Qin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ting</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ming</forename><surname>Zhou</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2018" />
			<biblScope unit="page" from="361" to="372" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">Sequence to sequence learning with neural networks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ilya</forename><surname>Sutskever</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oriol</forename><surname>Vinyals</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Quoc V</forename><surname>Le</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Conference on Neural Information Processing Systems</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="3104" to="3112" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Learning regular languages using genetic programming</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Borge</forename><surname>Svingen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Genetic Programming</title>
		<imprint>
			<date type="published" when="1998" />
			<biblScope unit="page" from="374" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<analytic>
		<title level="a" type="main">DiffGen: Automated regression unit-test generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kunal</forename><surname>Taneja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="407" to="410" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Pex-White box test generation for .NET</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolai</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">De</forename><surname>Halleux</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Tests and Proofs</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="134" to="153" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Transferring an automated test generation tool to practice: From Pex to Fakes and Code Digger</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nikolai</forename><surname>Tillmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>De Halleux</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE/ACM International Conference on Automated Software Engineering</title>
		<imprint>
			<date type="published" when="2014" />
			<biblScope unit="page" from="385" to="396" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Simple statistical gradientfollowing algorithms for connectionist reinforcement learning</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ronald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Machine Learning</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="229" to="256" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">A syntactic neural model for general-purpose code generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pengcheng</forename><surname>Yin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Graham</forename><surname>Neubig</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="440" to="450" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<monogr>
				<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Victor</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Caiming</forename><surname>Xiong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Socher</surname></persName>
		</author>
		<idno type="arXiv">arXiv:1709.00103</idno>
		<title level="m">Seq2SQL: Generating structured queries from natural language using reinforcement learning</title>
		<imprint>
			<date type="published" when="2017" />
		</imprint>
	</monogr>
<note type="report_type">arXiv preprint</note>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Generating regular expressions from natural language specifications: Are we there yet?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zexuan</forename><surname>Zhong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jiaqi</forename><surname>Guo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wei</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tao</forename><surname>Xie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jianguang</forename><surname>Lou</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ting</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dongmei</forename><surname>Zhang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop on NLP for Software Engineering</title>
		<imprint>
			<date type="published" when="2018" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
