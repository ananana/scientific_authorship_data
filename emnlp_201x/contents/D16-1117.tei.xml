<?xml version="1.0" encoding="UTF-8"?>
<TEI xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/ana/installs/grobid/grobid-0.5.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<encodingDesc>
			<appInfo>
				<application version="0.5.1-SNAPSHOT" ident="GROBID" when="2019-04-18T12:02+0000">
					<ref target="https://github.com/kermitt2/grobid">GROBID - A machine learning software for extracting information from scholarly documents</ref>
				</application>
			</appInfo>
		</encodingDesc>
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">EQUATION PARSING : Mapping Sentences to Grounded Equations</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
				<date>November 1-5, 2016</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subhro</forename><surname>Roy</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<country>Urbana Champaign</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Shyam</forename><surname>Upadhyay</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<country>Urbana Champaign</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dan</forename><surname>Roth</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">University of Illinois</orgName>
								<address>
									<country>Urbana Champaign</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">EQUATION PARSING : Mapping Sentences to Grounded Equations</title>
					</analytic>
					<monogr>
						<title level="m">Proceedings of the 2016 Conference on Empirical Methods in Natural Language Processing</title>
						<meeting>the 2016 Conference on Empirical Methods in Natural Language Processing <address><addrLine>Austin, Texas</addrLine></address>
						</meeting>
						<imprint>
							<biblScope unit="page" from="1088" to="1097"/>
							<date type="published">November 1-5, 2016</date>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<profileDesc>
			<abstract>
				<p>Identifying mathematical relations expressed in text is essential to understanding a broad range of natural language text from election reports, to financial news, to sport commentaries to mathematical word problems. This paper focuses on identifying and understanding mathematical relations described within a single sentence. We introduce the problem of Equation Parsing-given a sentence, identify noun phrases which represent variables, and generate the mathematical equation expressing the relation described in the sentence. We introduce the notion of projective equation parsing and provide an efficient algorithm to parse text to projective equations. Our system makes use of a high precision lexicon of mathematical expressions and a pipeline of struc-tured predictors, and generates correct equations in 70% of the cases. In 60% of the time, it also identifies the correct noun phrase → variables mapping, significantly outperform-ing baselines. We also release a new annotated dataset for task evaluation.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Understanding text often involves reasoning with re- spect to quantities mentioned in it. Understanding the news article statement in Example 1 requires identifying relevant entities and the mathematical re- lations expressed among them in text, and determin- ing how to compose them. Similarly, solving a math word problem with a sentence like Example 2, re- quires realizing that it deals with a single number, knowing the meaning of "difference" and compos- Example 1 Emanuel's campaign contribu- tions total three times those of his opponents put together. Example 2 Twice a number equals 25 less than triple the same number. Example 3 Flying with the wind , a bird was able to make 150 kilometers per hour. Example 4 The sum of two numbers is 80. Example 5 There are 54 5-dollar and 10- dollar notes.</p><p>ing the right equation -"25" needs to be subtracted from a number only after it is multiplied by 3.</p><p>As a first step towards understanding such rela- tions, we introduce the Equation Parsing task -given a sentence expressing a mathematical relation, the goal is to generate an equation representing the rela- tion, and to map the variables in the equation to their corresponding noun phrases. To keep the problem tractable, in this paper we restrict the final output equation form to have at most two (possibly coref- erent) variables, and assume that each quantity men- tioned in the sentence can be used at most once in the final equation. <ref type="bibr">1</ref> In example 1, the gold out- put of an equation parse should be V 1 = 3 × V 2 , with V 1 = "Emanuel's campaign contributions" and V 2 = "those of his opponents put together".</p><p>The task can be seen as a form of semantic parsing ( <ref type="bibr" target="#b3">Goldwasser and Roth, 2011;</ref><ref type="bibr" target="#b5">Kwiatkowski et al., 2013</ref>) where instead of mapping a sentence to a logi- cal form, we want to map it to an equation. However, there are some key differences that make this prob- lem very challenging in ways that differ from the "standard" semantic parsing. In Equation Parsing, not all the components of the sentence are mapped to the final equation. There is a need to identify noun phrases that correspond to variables in the rela- tions and determine that some are irrelevant and can be dropped. Moreover, in difference from seman- tic parsing into logical forms, in Equation Parsing multiple phrases in the text could correspond to the same variable, and identical phrases in the text could correspond to multiple variables.</p><p>We call the problem of mapping noun phrases to variables the problem of grounding variables. Grounding is challenging for various reasons, key among them are that: (i) The text often does not mention "variables" explicitly, e.g., the sentence in example 3 describes a mathematical relation be- tween the speed of bird and the speed of wind, with- out mentioning "speed" explicitly. (ii) Sometimes, multiple noun phrases could refer to the same vari- able. For instance, in example 2, both "a number" and "the same number" refer to the same variable. On the other hand, the same noun phrase might re- fer to multiple variables, as in example 4, where the noun phrase "two numbers" refer to two variables. In addition, the task involves deciding which of the quantities identified in the sentence are relevant to the final equation generation. In example 5, both "5" and "10" are not relevant for the final equation "V 1 + V 2 = 54". Finally, the equation needs to be constructed from a list of relevant quantities and grounded variables. Overall, the output space be- comes exponential in the number of quantities men- tioned in the sentence.</p><p>Determining the final equation that corresponds to the text is an inference step over a very large space. To address this, we define the concept of "projectivity" -a condition where the final equation can be generated by combining adjacent numbers or variables, and show that most sentences expressing mathematical relations exhibit the projectivity prop- erty. Finally, we restrict our inference procedure to only search over equations which have this property.</p><p>Our approach builds on a pipeline of structured predictors that identify irrelevant quantities, recog- nize coreferent variables, and, finally, generate equa- tions. We also leverage a high precision lexicon of mathematical expressions and develop a greedy lex- icon matching strategy to guide inference. We dis- cuss and exemplify the advantages of this approach and, in particular, explain where the "standard" NLP pipeline fails to support equation parsing, and ne- cessitates the new approach proposed here. Another contribution of this work is the development of a new annotated data set for the task of equation pars- ing. We evaluate our method on this dataset and show that our method predicts the correct equation in 70% of the cases and that in 60% of the time we also ground all variables correctly.</p><p>The next section presents a discussion of related work. Next we formally describe the task of equa- tion parsing. The following sections describe our equation representation and the concept of projectiv- ity, followed by the description of our algorithm to generate the equations and variable groundings from text. We conclude with experimental results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Related Work</head><p>The work most related to this paper is ( <ref type="bibr" target="#b5">Madaan et al., 2016)</ref>, which focuses on extracting relation triples where one of the arguments is a number. In contrast, our work deals with multiple variables and complex equations involving them. There has been a lot of re- cent work in automatic math word problem solving ( <ref type="bibr" target="#b7">Roy et al., 2015;</ref><ref type="bibr" target="#b4">Hosseini et al., 2014;</ref><ref type="bibr" target="#b7">Roy and Roth, 2015)</ref>. These solvers cannot handle sentences individually. They require the input to be a complete math word problem, and even then, they only focus on retrieving a set of an- swer values without mentioning what each answer value corresponds to. Our work is also conceptually related to work on semantic parsing -mapping natu- ral language text to a formal meaning representation <ref type="bibr">(Wong and Mooney, 2007;</ref><ref type="bibr" target="#b3">Clarke et al., 2010;</ref><ref type="bibr" target="#b2">Cai and Yates, 2013;</ref><ref type="bibr" target="#b5">Kwiatkowski et al., 2013;</ref><ref type="bibr" target="#b3">Goldwasser and Roth, 2011</ref>). However, as mentioned earlier, there are some significant differences in the task definition that necessitate the development of a new approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Equation Parsing Task</head><p>Equation parsing takes as input a sentence x describ- ing a single mathematical equation, comprising one or two variables and other quantities mentioned in x.</p><p>Let N be the set of noun phrases in the sentence x. The output of the task is the mathematical equation described in x, along with a mapping of each vari- able in the equation to its corresponding noun phrase in N . We refer to this mapping as the "grounding" of the variable; the noun phrase represents what the variable stands for in the equation. <ref type="table" target="#tab_0">Table 1</ref> gives an example of an input and output for the equation parsing of the text in example 2. Since an equation can be written in various forms, we use the form which most agrees with text, as our target output. So, for example 1, we will choose V 1 = 3 × V 2 and not V 2 = V 1 ÷ 3. In cases where several equation forms seem to be equally likely to be the target equa- tion, we randomly choose one of them, and keep this choice consistent across the dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The Equation Parsing Task Input</head><p>Twice a number equals 25 less than triple the same number. </p><formula xml:id="formula_0">Output 2 × V 1 = (3 × V 1 ) − 25 (Equation) V 1 = "a number" (Grounding)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Equation Parse Representation</head><p>In this section, we introduce an equation parse for a sentence. An equation parse of a sentence x is a pair (T, E), where T represents a set of triggers extracted from x, and E represents an equation tree formed with the set T as leaves. We now describe these terms in detail.</p><p>Trigger Given a sentence x mentioning a mathemat- ical relation, a trigger can either be a quantity trigger expressed in x, or variable trigger which is a noun phrase in x corresponding to a variable. A quantity trigger is a tuple (q, s), where q is the numeric value of the quantity mentioned in text, and s is the span of text from the sentence x which refers to the quan- tity. A variable trigger is a tuple (l, s), where l rep- resents the label of the variable, and s represents the noun phrase representing the variable. For example, for the sentence in <ref type="figure" target="#fig_0">Fig 1,</ref> the spans "Twice", "25", and "triple" generate quantity triggers, whereas "a number" and "the same number" generate variable triggers, with label V 1 .</p><p>Trigger List The trigger list T for a sentence x con- tains one trigger for each variable mention and each numeric value used in the final equation expressed Binary tree representation of equa- tion lc(n), rc(n)</p><p>Left and right child of node n EXPR(n)</p><p>Expression represented by node n (n)</p><p>Operation at node n ORDER(n)</p><p>Order of operation at node n Location(n)</p><p>Character offset of trigger represent- ing leaf node n Span-Start(n), Span-End(n)</p><p>Start and end character offsets of span covered by node n <ref type="table">Table 2</ref>: Summary of notations used in the paper by the sentence x. The trigger list might consist of multiple triggers having the same label, or extracted from the same span of text. In the example sentence in <ref type="figure" target="#fig_0">Fig 1,</ref> the trigger list comprises two triggers hav- ing the same label V 1 . The final trigger list for the example in <ref type="figure" target="#fig_0">Fig 1</ref> is {(2, "2"), (V 1 , "a number"), (25, "25"), (3, "triple"), (V 1 , "the same number")}. Note that there can be multiple valid trigger lists. In our example, we could have chosen both variable trig- gers to point to the same mention "a number". Quan- tity triggers in the trigger list form the quantity trig- ger list, and the variable triggers in trigger list form the variable trigger list. Equation Tree An equation tree of a sentence x is a binary tree whose leaves constitute the trigger list of x, and internal nodes (except the root) are labeled with one of the following operations -addition, sub- traction, multiplication, division. In addition, for nodes which are labeled with subtraction or division, we maintain a separate variable to determine order of its children. The root of the tree is always labeled with the operation equal.</p><p>An equation tree is a natural representation for an equation. Each node n in an equation tree repre- sents an expression EXPR(n), and the label of the parent node determines how the expressions of its children are to be composed to construct its own ex- pression. Let us denote the label for a non-leaf node Twice a number equals 25 less than triple the same number. Sentence n to be (n), where (n) ∈ {+, −, ×, ÷, =} and the order of a node n's children by ORDER(n) (de- fined only for subtraction and division nodes), which takes values lr (Left-Right) or rl (Right-Left). For a leaf node n, the expression EXPR(n) represents the variable label, if n is a variable trigger, and the nu- meric value of the quantity, if it is a quantity trigger. Finally, we use lc(n) and rc(n) to represent the left and right child of node n, respectively. The equation represented by the tree can be generated as follows.</p><p>For all non-leaf nodes n, we have</p><formula xml:id="formula_1">EXPR(n) =                      EXPR(lc(n)) (n) EXPR(rc(n)) if (n) ∈ {+, ×, =} EXPR(lc(n)) (n) EXPR(rc(n)) if (n) ∈ {−, ÷} ∧ ORDER(n) = lr EXPR(rc(n)) (n) EXPR(lc(n)) if (n) ∈ {−, ÷} ∧ ORDER(n) = rl<label>(1)</label></formula><p>Given an equation tree T of a sentence, the equation represented by it is the expression generated by the root of T (following Equation 1). Referring to the equation tree in <ref type="figure" target="#fig_0">Fig 1,</ref> the node marked "− r " repre- sents (3 × V 1 ) − 25, and the root represents the full equation</p><formula xml:id="formula_2">2 × V 1 = (3 × V 1 ) − 25.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Projectivity</head><p>For each leaf n of an equation tree T , we de- fine a function Location(·), to indicate the posi- tion of the corresponding trigger in text. We also define for each node n of equation tree T , func- tions Span-Start(n) and Span-End(n) to denote the minimum span of text containing the leaves of the subtree rooted at n. We define them as follows:</p><formula xml:id="formula_3">Span-Start(n) =      Location(n) if n is a leaf min(Span-Start(lc(n)), Span-Start(rc(n))) otherwise Span-End(n) =      Location(n) if n is a leaf max(Span-End(lc(n)), Span-End(rc(n))) otherwise</formula><p>An equation tree T is called projec- tive iff for every node n of T , either</p><formula xml:id="formula_4">Span-End(lc(n)) ≤ Span-Start(rc(n)) or Span-End(rc(n)) ≤ Span-Start(lc(n))</formula><p>. In other words, the span of the left child and the right child cannot intersect in a projective equation tree 2 .</p><p>The key observation, as our corpus analysis indi- cates, is that for most sentences, there exists a trig- ger list, such that the equation tree representing the relation in the sentence is projective. However this might involve mapping two mentions of the same variable to different noun phrases. <ref type="figure" target="#fig_0">Figure 1</ref> shows an example of a projective equation tree, which re- quires different mentions of V 1 to be mapped to dif- ferent noun phrases. If we had mapped both men- tions of V 1 to same noun phrase "a number", the resulting equation tree would not have been projec- tive. We collected 385 sentences which represent an equation with one or two mentions of variables, and each number in the sentence used at most once in the equation. We found that only one sentence among these could not generate a projective equa- tion tree. (See Section 6.1 for details on dataset creation). Therefore, we develop an algorithmic ap- proach for predicting projective equation trees, and show empirically that it compares favourably with ones which do not make the projective assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Predicting Equation Parse</head><p>Equation parsing of a sentence involves predicting three components -Quantity Trigger List, Variable Trigger List and Equation Tree. We develop three structured prediction modules to predict each of the above components.</p><p>All our prediction modules take a similar form: given input x and output y, we learn a scoring func- tion f w (x, y), which scores how likely is the output y given input x. The scoring function f w (x, y) is linear, f w (y) = w T φ(x, y), where φ(x, y) is a fea- ture vector extracted from x and y. The inference problem, that is, the prediction y * for an input x is then: y * = arg max y∈Y f w (y), where Y is the set of all allowed values of y.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Predicting Quantity Trigger List</head><p>Given input text and the quantities mentioned in it, the role of this step is to identify , for each quan- tity in the text, whether it should be part of the fi- nal equation. For instance, in example 5 in Section 1, both "5" and "10" are not relevant for the final equation "V 1 + V 2 = 54". Similarly, in example 4, the number "two" is irrelevant for the equation "V 1 + V 2 = 80".</p><p>We define for each quantity q in the sentence, a boolean value Relevance(q), which is set to true if q is relevant for the final equation, and to f alse otherwise. For the structured classification, the in- put x is the sentence along with a set of recognized quantities mentioned in it, and the output y is the relevance values for all quantities in the sentence. We empirically found that predicting all relevance values jointly performs better than having a binary classifier predict each one separately. The feature function φ(x, y) used for the classification gener- ates neighborhood features (from neighborhood of q) and quantity features (properties of the quantity mention). Details added to the appendix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Predicting Variable Trigger List</head><p>The goal of this step is to predict the variable trigger list for the equation. Our structured classifier takes as input the sentence x, and the output y is either one or two noun-phrases, representing variables in the final equation. As we pointed out earlier, mul- tiple groundings might be valid for any given vari- able, hence there can be multiple valid variable trig- ger lists. For every sentence</p><note type="other">x, we construct a set Y of valid outputs. Each element in Y corresponds to a valid variable trigger list. Finally, we aim to output only one of the elements of Y .</note><p>We modified the standard structured prediction al- gorithm to consider "superset supervision" and take into account multiple gold structures for an input x. We assume access to N training examples of the form :</p><formula xml:id="formula_5">(x 1 , Y 1 ), (x 2 , Y 2 ), . . . , (x N , Y N )</formula><p>, where each Y i is a set of valid outputs for the sentence x i . Since we want to output only one variable trigger list, we want to score at least one y from Y i higher than all other possible outputs, for each x i . We use a modi- fied latent structured SVM to learn the weight vector w. The algorithm treats the best choice among all of Y i as a latent variable. At each iteration, for all x i , the algorithm chooses the best choice y * i from the set Y i , according to the weight vector w. Then, w is updated by learning on all (x i , y * i ) by a standard structured SVM algorithm. The details of the algo- rithm are in Algorithm 1. The distinction from stan-</p><formula xml:id="formula_6">Algorithm 1 Structural SVM with Superset Super- vision Input: Training data T = {(x 1 , Y 1 ), (x 2 , Y 2 ), . . . , (x N , Y N )} Output: Trained weight vector w 1: w ← w 0 2: repeat 3:</formula><p>T ← ∅</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4:</head><p>for all (x i , Y i ) ∈ T do 5:</p><formula xml:id="formula_7">y * i ← arg max y∈Y i w T φ(x i , y) 6: T ← T ∪ {(x i , y * i )} 7:</formula><p>end for 8:</p><p>Update w by running standard Structural SVM algorithm on T 9: until convergence 10: return w dard latent structural SVM is in line 5 of Algorithm 1. In order to get the best choice y * i for input x i , we search only inside Y i , instead of all of Y. A similar formulation can be found in <ref type="bibr" target="#b0">Björkelund and Kuhn (2014)</ref>. The features φ(x, y) used for variable trig- ger prediction include variable features (properties of noun phrase indicating variable) and neighbor- hood features (lexical features from neighborhood of variable mention). Details added to the appendix.</p><p>If the output of the classifier is a pair of noun phrases, we use a rule based variable coreference detector, to determine whether both noun phrases should have the same variable label or not. The rules for variable coreference are as follows :</p><p>1. If both noun phrases are the same, and they do not have the token "two" or "2", they have the same label.</p><p>2. If the noun phrases are different, and the noun phrase appearing later in the sentence contains tokens "itself", "the same number", they have the same label.</p><p>3. In all other cases, they have different labels.</p><p>Finally, each noun phrase contributes one variable trigger to the variable trigger list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Predicting Equation Tree</head><p>It is natural to assume that the syntactic parse of the sentence could be very useful in addressing all the predictions we are making in the equation parsing tasks. However, it turns out that this is not the case -large portions of the syntactic parse will not be part of the equation parse, hence we need the afore- mentioned modules to address this. Nevertheless, in the next task of predicting the equation tree, we attempted to constraint the output space using guid- ance from the syntactic tree; we found, though, that even enforcing this weak level of output expectation is not productive. This was due to the poor perfor- mance of current syntactic parsers on the equation data (eg., in 32% of sentences, the Stanford parser made a mistake which does not allow recovering the correct equation). The tree prediction module receives the trigger list predicted by the previous two modules, and the goal is to create an equation tree using the trigger list as the leaves of that tree. The input x is the sentence and the trigger list, and the output y is the equation tree representing the relation described in the sen- tence. We assume that the output will be a projective equation tree. For features φ(x, y), we extract for each non-leaf node n of the equation tree y, neigh- borhood features (from neighborhood of node spans of n's children), connecting text features (from text between the spans of n's children) and number fea- tures (properties of number in case of leaf nodes). Details are included in the appendix.</p><p>The projectivity assumption implies that the final equation tree can be generated by combining only adjacent nodes, once the set of leaves is sorted based on Span-Start(·) values. This allows us to use CKY algorithm for inference. A natural approach to fur- ther reduce the output space is to conform to the projective structure of the syntactic parse of the sen- tence. However, we found this to adversely affect performance, due to the poor performance of syn- tactic parser on equation data. Lexicon To bootstrap the equation parsing process, we developed a high precision lexicon to translate mathematical expressions to operations and orders, like "sum of A and B" translates to "A+B", "A minus B" translates to "A-B", etc. (where A and B denote placeholder numbers or expressions). At each step of CKY, while constructing a node n of the equation tree, we check for a lexicon text expression corre- sponding to node n. If found, we allow only the corresponding operation (and order) for node n, and do not explore other operations or orders. We show empirically that reducing the space using this greedy lexicon matching help improve performance. We found that using the lexicon rules as features instead of hard constraints do not help as much. Note that our lexicon comprises only generic math concepts, and around 50% of the sentences in our dataset do not contain any pattern from the lexicon.</p><p>Finally, given input sentence, we first predict the quantity trigger and the variable trigger lists. Given the complete trigger list, we predict the equation tree relating the components of the trigger list.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Alternatives</head><p>A natural approach could be to jointly learn to pre- dict all three components, to capture the dependen- cies among them. To investigate this, we developed a structured SVM which predicts all components jointly, using the union of the features of each com- ponent. We use approximate inference, first enumer- ating possible trigger lists, and then equation trees, and find the best scoring structure. However, this method did not outperform the pipeline method. The worse performance of joint learning is due to: (1) search space being too large for the joint model to do well given our dataset size of 385, and (2) our inde- pendent classifiers being good enough, thus support- ing better joint inference. This tradeoff is strongly supported in the literature ( <ref type="bibr" target="#b5">Punyakanok et al., 2005;</ref><ref type="bibr">Sutton and McCallum, 2007)</ref>.</p><p>Another option is to enforce constraints between trigger list predictions, such as, variable triggers should not overlap with the quantity triggers. How- ever, we noticed that often noun phrases returned by the Stanford parser were noisy, and would in- clude neighboring numbers within the extracted noun phrases. This prevented us from enforcing such constraints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Experimental Results</head><p>We now describe the data set, and the annotation procedure used. We then evaluate the system's per- formance on predicting trigger list, equation tree, and the complete equation parse.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Dataset</head><p>We created a new dataset consisting of 385 sen- tences extracted from algebra word problems and fi- nancial news headlines. For algebra word problems, we used the MIT dataset ( ), and two high school mathematics textbooks, Ele- mentary Algebra (College of Redwoods) and Begin- ning and Intermediate Algebra (Tyler Wallace). Fi- nancial news headlines were extracted from The Lat- est News feed of MarketWatch, over the month of February, 2015. All sentences with information de- scribing a mathematical relation among at most two (possibly coreferent) variables, were chosen. Next, we pruned sentences which require multiple uses of a number to create the equation. This only removed a few time related sentences like "In 10 years, John will be twice as old as his son.". We empirically found that around 97% of sentences describing a re- lation fall under the scope of our dataset.</p><p>The annotators were shown each sentence paired with the normalized equation representing the rela- tion in the sentence. For each variable in the equa- tion, the annotators were asked to mark spans of text which best describe what the variable repre- sents. The annotation guidelines are provided in the appendix. We wanted to consider only noun phrase constituents for variable grounding. There- fore, for each annotated span, we extracted the noun phrase with maximum overlap with the span, and used it to represent the variables. Finally, a tu- ple with each variable being mapped to one of the noun phrases representing it, forms a valid output grounding (variable trigger list). We computed inter- annotator agreement on the final annotations where only noun phrases represent variables. The agree- ment (kappa) was 0.668, indicating good agreement. The average number of mention annotations per sen- tence was 1.74.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Equation Parsing Modules</head><p>In this section, we evaluate the performance of the individual modules of the equation parsing process. We report Accuracy -the fraction of correct predic- tions. <ref type="table" target="#tab_3">Table 3</ref> shows the 5-fold cross validation ac- curacy of the various modules. In each case, we also report accuracy by removing each feature group, one at a time. In addition, for equation tree prediction, we also show the effect of lexicon, projectivity, con- forming to syntactic parse constraints, and using lex- icon as features instead of hard constraints. For all our experiments, we use the Stanford Parser ( <ref type="bibr" target="#b7">Socher et al., 2013)</ref>, the Illinois POS tagger <ref type="bibr" target="#b6">(Roth and Zelenko, 1998</ref>) and the Illinois-SL structured predic- tion package <ref type="bibr" target="#b3">(Chang et al., 2015</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Equation Parsing Results</head><p>In this section, we evaluate the performance of our system on the overall equation parsing task. We re- port Equation Accuracy -the fraction of sentences for which the system got the equation correct, and Equation+Grounding Accuracy -the fraction of sen- tences for which the system got both the equation and the grounding of variables correct. <ref type="table" target="#tab_4">Table 4</ref> shows the overall performance of our system, on a 5-fold cross validation. We compare against Joint Learning -a system which jointly learns to predict all relevant components of an equation parse (Sec- tion 5.4). We also compare with SPF , a publicly available semantic parser, which can learn from sentence-logical form pairs. We train SPF with sentence-equation pairs   and a seed lexicon for mathematical terms (similar to ours), and report equation accuracy. Our structured predictors pipeline approach is shown to be superior to both Joint Learning and SPF.</p><p>SPF gets only a few sentences correct. We at- tribute this to the inability of SPF to handle over- lapping mentions (like in Example 4), as well as its approach of parsing the whole sentence to the fi- nal output form. The developers of SPF also con- firmed 3 that it is not suitable for equation parsing and that these results are expected. Since equation parsing is a more involved process, a slight adapta- tion of SPF does not seem possible, necessitating a more involved process , of the type we propose. Our approach, in contrast to SPF, can handle overlapping mentions, selects triggers from text, and parses the trigger list to form equations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Private communication</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Error Analysis</head><p>For variable trigger list prediction, around 25% of the errors were due to the predictor choosing a span which is contained within the correct span, e.g., when the target noun phrase is "The cost of a child's ticket", our predictor chose only "child's ticket". Although this choice might be sufficient for down- stream tasks, we consider it to be incorrect in our current evaluation. Another 25% of the errors were due to selection of entities which do not participate in the relation. For example, in "A rancher raises 5 times as many cows as horses.", our predictor chose "A rancher" and "cows" as variables, whereas the relation exists between "cows" and "horses". For the prediction of the equation tree, we found that 35% of the errors were due to rare math concepts expressed in text. For example, "7 dollars short of the price" represents 7 dollars should be subtracted from the price. These errors can be handled by care- fully augmenting the lexicon. Another 15% of the errors were due to lack of world knowledge, requir- ing understanding of time, speed, and distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>This paper investigates methods that identify and understand mathematical relations expressed in text. We introduce the equation parsing task, which involves generating an equation from a sentence and identifying what the variables represent. We define the notion of projectivity, and construct a high precision lexicon, and use these to reduce the equation search space. Our experimental results are quite satisfying and raise a few interesting issues. In particular, it suggests that predicting equation parses using a pipeline of structured predictors performs better than jointly trained alternatives. As discussed, it also points out the limitation of the current NLP tools in supporting these tasks. Our current formu- lation has one key limitation; we only deal with expressions that are described within a sentence. Our future work will focus on lifting this restriction, in order to allow relations expressed across multiple sentences and multiple relations expressed in the same sentence. Code and dataset are available at http://cogcomp.cs.illinois.edu/ page/publication_view/800.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work is funded by DARPA under agree- ment number FA8750-13-2-0008, and a grant from the Allen Institute for Artificial Intelligence (al- lenai.org).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A Features</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.1 Quantity Trigger List Prediction</head><p>The feature function φ(x, y) used for the classifica- tion generates the following features :</p><p>1. Neighborhood features : For each quantity q in the input sentence, we add unigrams and bi- grams generated from a window around q, part of speech tags of neighborhood tokens of q. We conjoin these features with Relevance(q).</p><p>2. Quantity Features : For each quantity q, we add unigrams and bigrams of the phrase repre- senting the quantity. Also, we add a feature in- dicating whether the number is associated with number one or two, and whether it is the only number present in the sentence. These features are also conjoined with Relevance(q).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.2 Variable Trigger List Prediction</head><p>The features φ(x, y) used for variable trigger predic- tion are as follows:</p><p>1. Variable features : Unigrams and bigrams generated from the noun phrase representing variables, part of speech tags of tokens in noun phrase representing variables.</p><p>2. Neighborhood Features : Unigrams and POS tags from neighborhood of variables.</p><p>All the above features are conjoined with two labels, one denoting whether y has two variables or one, and the second denoting whether y has two variables represented by the same noun phrase.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A.3 Equation Tree Prediction</head><p>For features φ(x, y), we extract for each non-leaf node n of the equation tree y, the following:</p><p>1. Neighborhood Features : Unigrams, bi- grams and POS tags from neighborhood of Span-Start(lc(n)), Span-Start(rc(n)), Span-End(lc(n)) and Span-End(rc(n)), conjoined with (n) and ORDER(n).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Connecting Text Features : Unigrams, bigrams and part of speech tags between</head><p>min(Span-End(lc(n)), Span-End(rc(n))) and max(Span-Start(lc(n)), Span-Start(rc(n))), conjoined with (n) and ORDER(n).</p><p>3. Number Features : In case we are combining two leaf nodes representing quantity triggers, we add a feature signifying whether one num- ber is larger than the other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>B Annotation Guidelines</head><p>The annotators were shown each sentence paired with the normalized equation representing the rela- tion in the sentence. For each variable in the equa- tion, the annotators were asked to mark spans of text which best describe what the variable represents. They were asked to annotate associated entities if exact variable description was not present. For in- stance, in example 3 (Section 1), the relation holds between the speed of bird and the speed of wind. However, "speed" is not explicitly mentioned in the sentence. In such cases, the annotators were asked to annotate the associated entities "the wind" and "a bird" as representing variables. The guidelines also directed annotators to choose the longest possible mention, in case they feel the mention boundary is ambiguous. As a result, in the sentence, "City Rentals rent an intermediate-size car for 18.95 dollars plus 0.21 per mile.", the phrase "City Rentals rent an intermediate-size car" was an- notated as representing variable. We allow multiple mentions to be annotated for the same variable. In example 2 (Section 1), both "a number" and "the same number" were annotated as representing the same variable.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: A sentence with its trigger list and equation tree. −r indicates subtraction with order rl.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0" validated="false"><head>Table 1 : Input and output for Equation Parsing</head><label>1</label><figDesc></figDesc><table></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3" validated="true"><head>Table 3 : Performance of system components</head><label>3</label><figDesc></figDesc><table>Source 
Equation 
Accuracy 

Equation + 
Grounding 
Accuracy 

Our System 
71.3 
61.2 
Joint Learning 
60.9 
50.0 
SPF 
3.1 
N/A 

</table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4" validated="false"><head>Table 4 : Performance on equation parsing</head><label>4</label><figDesc></figDesc><table></table></figure>

			<note place="foot" n="1"> We empirically found that around 97% of sentences describing a relation have this property.</note>

			<note place="foot" n="2"> This is more general than the definition of projective trees used in dependency parsing (McDonald et al., 2005).</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Learning structured perceptrons for coreference resolution with latent antecedents and non-local features</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zettlemoyer2013] Yoav</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luke</forename><surname>Artzi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anders</forename><surname>Zettlemoyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonas</forename><surname>Björkelund</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kuhn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 52nd</title>
		<meeting>the 52nd</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
	<note>UW SPF: The University of Washington Semantic Parsing Framework</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
				<title level="m">Annual Meeting of the Association for Computational Linguistics</title>
		<imprint>
			<publisher>Long Papers</publisher>
			<biblScope unit="volume">1</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Semantic Parsing Freebase: Towards Opendomain Semantic Parsing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yates2013] Qingqing</forename><surname>Cai</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alexander</forename><surname>Yates</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Second Joint Conference on Lexical and Computational Semantics (*SEM)</title>
		<meeting>the Second Joint Conference on Lexical and Computational Semantics (*SEM)</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Illinoissl: A JAVA library for structured prediction. In Arxiv Preprint, volume abs/1509.07179</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chang</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the International Joint Conference on Artificial Intelligence (IJCAI)</title>
		<meeting>of the International Joint Conference on Artificial Intelligence (IJCAI)</meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="volume">7</biblScope>
		</imprint>
	</monogr>
	<note>Proc. of the Conference on Computational Natural Language Learning (CoNLL)</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Learning to solve arithmetic word problems with verb categorization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Hosseini</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conference on Empirical Methods in Natural Language Processing (EMNLP)</title>
		<meeting>of the Conference on Empirical Methods in Natural Language essing (EMNLP)</meeting>
		<imprint>
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Nonprojective dependency parsing using spanning tree algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Kushman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Conference on Human Language Technology and Empirical Methods in Natural Language Processing</title>
		<meeting>the Conference on Human Language Technology and Empirical Methods in Natural Language Processing</meeting>
		<imprint>
			<date type="published" when="2005-01" />
			<biblScope unit="page" from="1124" to="1129" />
		</imprint>
	</monogr>
	<note>Proc. of the International Joint Conference on Artificial Intelligence (IJCAI)</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Part of speech tagging using a network of linear separators</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roth</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zelenko1998] D</forename><surname>Roth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Zelenko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of the Conference on Empirical Methods in Natural Language Processing</title>
		<editor>Roy and Roth2015] S. Roy and D. Roth</editor>
		<meeting>of the Conference on Empirical Methods in Natural Language essing</meeting>
		<imprint>
			<publisher>EMNLP</publisher>
			<date type="published" when="1998" />
			<biblScope unit="page" from="1136" to="1142" />
		</imprint>
	</monogr>
	<note>The 17th International Conference on Computational Linguistics</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Piecewise pseudolikelihood for efficient training of conditional random fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Roy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Reasoning about quantities in natural language. Transactions of the Association for Computational Linguistics</title>
		<editor>Mooney2007] Y.-W. Wong and R. Mooney</editor>
		<meeting><address><addrLine>Prague</addrLine></address></meeting>
		<imprint>
			<publisher>Omnipress</publisher>
			<date type="published" when="2007-06" />
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="page" from="960" to="967" />
		</imprint>
	</monogr>
	<note>Proceedings of the Annual Meeting of the Association for Computational Linguistics (ACL). Czech Republic. Association for Computational Linguistics</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
